GM.Name = "Zombie Survival" GM.Author = "William \"JetBoom\" Moodhe" GM.Email = "williammoodhe@gmail.com" GM.Website = "http://www.noxiousnet.com"    GM.Credits = {     {"William \"JetBoom\" Moodhe", "williammoodhe@gmail.com (www.noxiousnet.com)", "Creator / Programmer"},     {"11k", "tjd113@gmail.com", "Zombie view models"},     {"Eisiger", "k2deseve@gmail.com", "Zombie kill icons"},     {"Austin \"Little Nemo\" Killey", "austin_odyssey@yahoo.com", "Ambient music"},     {"Zombie Panic: Source", "http://www.zombiepanic.org/", "Melee weapon sounds"},     {"Samuel", "samuel_games@hotmail.com", "Board Kit models"},     {"Gormaoife", "", "Art contributions"},     {"Typhon", "lukas-tinel@hotmail.com", "Fear-o-meter textures"},     {"Benjy, The Darker One, Raox, Scott", "", "Code contributions"},      {"Mr. Darkness", "", "Russian translation"},     {"honsal", "", "Korean translation"},     {"rui_troia", "", "Portuguese translation"},     {"Shinyshark", "", "Dutch translation"},     {"Kradar", "", "Italian translation"},     {"Raptor", "", "German translation"},     {"The Special Duckling", "", "Danish translation"},     {"ptown, Dr. Broly", "", "Spanish translation"},      {"Anyone else on GitHub or who I've forgotten", "", "Various contributions"}, }  if file.Exists(GM.FolderName.."/gamemode/maps/"..game.GetMap()..".lua", "LUA") then     include("maps/"..game.GetMap()..".lua") end  function GM:GetNumberOfWaves()     local default = GetGlobalBool("classicmode") and 10 or self.NumberOfWaves     local num = GetGlobalInt("numwaves", default)       return num == -2 and default or num end  function GM:GetWaveOneLength()     return GetGlobalBool("classicmode") and self.WaveOneLengthClassic or self.WaveOneLength end  include("sh_customhooks.lua")  include("obj_vector_extend.lua") include("obj_entity_extend.lua") include("obj_player_extend.lua") include("obj_weapon_extend.lua")  include("sh_translate.lua") include("sh_colors.lua") include("sh_serialization.lua") include("sh_util.lua")  include("skillweb/sh_skillweb.lua")  include("sh_options.lua") include("sh_zombieclasses.lua") include("sh_animations.lua") include("sh_sigils.lua") include("sh_controlpoints.lua") include("sh_channel.lua") include("sh_weaponquality.lua")  include("vault/shared.lua")  include("workshopfix.lua")  include_library("perf") include_library("player_movement") include_library("inventory") include_library("mechanics") include_library("ammoexpand")     GM.EndRound = false GM.StartingWorth = 100 GM.ZombieVolunteers = {}  team.SetUp(TEAM_ZOMBIE, "The Undead", Color(0, 255, 0, 255)) team.SetUp(TEAM_SURVIVORS, "Survivors", Color(0, 160, 255, 255))  local validmodels = player_manager.AllValidModels() validmodels["tf01"] = nil validmodels["tf02"] = nil  vector_tiny = Vector(0.001, 0.001, 0.001)    GM.SoundDuration = {     ["zombiesurvival/music_win.ogg"] = 33.149,     ["zombiesurvival/music_lose.ogg"] = 45.714,     ["zombiesurvival/lasthuman.ogg"] = 120.503,     ["zombiesurvival/sr_music_escape_trim_2.ogg"] = 5.647,      ["zombiesurvival/beats/defaulthuman/1.ogg"] = 7.111,     ["zombiesurvival/beats/defaulthuman/2.ogg"] = 7.111,     ["zombiesurvival/beats/defaulthuman/3.ogg"] = 7.111,     ["zombiesurvival/beats/defaulthuman/4.ogg"] = 7.111,     ["zombiesurvival/beats/defaulthuman/5.ogg"] = 7.111,     ["zombiesurvival/beats/defaulthuman/6.ogg"] = 14.222,     ["zombiesurvival/beats/defaulthuman/7.ogg"] = 14.222,     ["zombiesurvival/beats/defaulthuman/8.ogg"] = 7.111,     ["zombiesurvival/beats/defaulthuman/9.ogg"] = 14.222,      ["zombiesurvival/beats/defaultzombiev2/1.ogg"] = 8,     ["zombiesurvival/beats/defaultzombiev2/2.ogg"] = 8,     ["zombiesurvival/beats/defaultzombiev2/3.ogg"] = 8,     ["zombiesurvival/beats/defaultzombiev2/4.ogg"] = 8,     ["zombiesurvival/beats/defaultzombiev2/5.ogg"] = 8,     ["zombiesurvival/beats/defaultzombiev2/6.ogg"] = 6.038,     ["zombiesurvival/beats/defaultzombiev2/7.ogg"] = 6.038,     ["zombiesurvival/beats/defaultzombiev2/8.ogg"] = 6.038,     ["zombiesurvival/beats/defaultzombiev2/9.ogg"] = 6.038,     ["zombiesurvival/beats/defaultzombiev2/10.ogg"] = 6.038 }  local SERVER = SERVER local CLIENT = CLIENT local HITGROUP_HEAD = HITGROUP_HEAD local HITGROUP_LEFTARM = HITGROUP_LEFTARM local HITGROUP_RIGHTARM = HITGROUP_RIGHTARM local HITGROUP_GEAR = HITGROUP_GEAR local HITGROUP_STOMACH = HITGROUP_STOMACH local HITGROUP_LEFTLEG = HITGROUP_LEFTLEG local HITGROUP_RIGHTLEG = HITGROUP_RIGHTLEG local PTeam = FindMetaTable("Player").Team  function GM:AddCustomAmmo()     game.AddAmmoType({name = "dummy"})     game.AddAmmoType({name = "pulse"})     game.AddAmmoType({name = "impactmine"})     game.AddAmmoType({name = "chemical"})     game.AddAmmoType({name = "scrap"})      game.AddAmmoType({name = "stone"})     game.AddAmmoType({name = "flashbomb"})     game.AddAmmoType({name = "betty"})     game.AddAmmoType({name = "molotov"})     game.AddAmmoType({name = "corgasgrenade"})     game.AddAmmoType({name = "crygasgrenade"})     game.AddAmmoType({name = "bloodshot"})      game.AddAmmoType({name = "spotlamp"})     game.AddAmmoType({name = "manhack"})     game.AddAmmoType({name = "manhack_saw"})     game.AddAmmoType({name = "drone"})     game.AddAmmoType({name = "pulse_cutter"})     game.AddAmmoType({name = "drone_hauler"})     game.AddAmmoType({name = "rollermine"})     game.AddAmmoType({name = "sigilfragment"})     game.AddAmmoType({name = "corruptedfragment"})     game.AddAmmoType({name = "mediccloudbomb"})     game.AddAmmoType({name = "nanitecloudbomb"})     game.AddAmmoType({name = "repairfield"})     game.AddAmmoType({name = "zapper"})     game.AddAmmoType({name = "nullifier"})     game.AddAmmoType({name = "zapper_arc"})     game.AddAmmoType({name = "remantler"})     game.AddAmmoType({name = "fridge"})     game.AddAmmoType({name = "turret_buckshot"})     game.AddAmmoType({name = "turret_assault"})     game.AddAmmoType({name = "turret_rocket"})     game.AddAmmoType({name = "sensor"})     game.AddAmmoType({name = "tv"})      game.AddAmmoType({name = "foodwatermelon"})     game.AddAmmoType({name = "foodorange"})     game.AddAmmoType({name = "foodbanana"})     game.AddAmmoType({name = "foodsoda"})     game.AddAmmoType({name = "foodmilk"})     game.AddAmmoType({name = "foodtakeout"})     game.AddAmmoType({name = "foodwater"})     game.AddAmmoType({name = "foodhotdog"})     game.AddAmmoType({name = "foodcannedbeans"})     game.AddAmmoType({name = "foodburger"})     game.AddAmmoType({name = "foodbeer"})      game.AddAmmoType({name = "flask_soft"})     game.AddAmmoType({name = "flask_conductive"})     game.AddAmmoType({name = "flask_sap"})     game.AddAmmoType({name = "flask_oil"}) end  GM.BasicFood = {     "weapon_zs_f_soda",     "weapon_zs_f_water",     "weapon_zs_f_banana",     "weapon_zs_f_cannedbeans",     "weapon_zs_f_orange",     "weapon_zs_f_milk", } GM.HighFood = {     "weapon_zs_f_beer",     "weapon_zs_f_burger",     "weapon_zs_f_hotdog",     "weapon_zs_f_takeout",     "weapon_zs_f_watermelon", }  function GM:RefreshMapIsObjective()     local mapname = string.lower(game.GetMap())     if string.find(mapname, "_obj_", 1, true) or string.find(mapname, "objective", 1, true) then         self.ObjectiveMap = true     else         self.ObjectiveMap = false     end end  function GM:AssignItemProperties()     for _, tab in ipairs(self.Items) do         if tab.SWEP then             local sweptab = self.ZSInventoryItemData[tab.SWEP] or weapons.Get(tab.SWEP)             if sweptab then                 if not tab.Description then                     tab.Description = sweptab.Description                 end                 if not tab.Tier then                     tab.Tier = sweptab.Tier                 end                 if not tab.MaxStock then                     tab.MaxStock = sweptab.MaxStock                 end                 if tab.Name == "?" then                     tab.Name = sweptab.PrintName or tab.Name                 end             end         end     end end    function GM:SetupDefaultClip(tab)     tab.DefaultClip = math.ceil(tab.ClipSize * self.SurvivalClips * (tab.ClipMultiplier or 1)) end    function GM:FixWeaponBase()     local base = weapons.GetStored("weapon_base")      base.TranslateActivity = function(me, act)         if me.ActivityTranslate[act] ~= nil then             return me.ActivityTranslate[act]         end          return -1     end      base.TakePrimaryAmmo = function(me, num)         if me.Weapon:Clip1() <= 0 then             if me:Ammo1() <= 0 then return end              me:GetOwner():RemoveAmmo(num, me.Weapon:GetPrimaryAmmoType())              return         end          me.Weapon:SetClip1(me.Weapon:Clip1() - num)     end      base.Ammo1 = function(me)         return me:GetOwner():GetAmmoCount(me.Weapon:GetPrimaryAmmoType())     end end  function GM:GetRedeemBrains()     return GetGlobalInt("redeembrains", self.DefaultRedeem) - (not self.ObjectiveMap and not self.ZombieEscape and self:GetWave() < 3 and 1 or 0) end  function GM:PlayerIsAdmin(pl)     return pl:IsAdmin() end  function GM:GetFallDamage(pl, fallspeed)     return 0   end  function GM:ValidMenuLockOnTarget(pl, ent)     if ent and ent:IsValidLivingHuman() and not ent:GetDTBool(DT_PLAYER_BOOL_SELFSS) then         local startpos = pl:EyePos()         local endpos = ent:NearestPoint(startpos)         if startpos:DistToSqr(endpos) <= 2304 and TrueVisible(startpos, endpos) then               return true         end     end      return false end  function GM:GetHandsModel(pl)     return player_manager.TranslatePlayerHands(player_manager.TranslateToPlayerModelName(pl:GetModel())) end  function GM:GetBestAvailableZombieClass(baseclass_id)     if self:ShouldUseBetterVersionSystem() then         local baseclass          while true do             baseclass = self.ZombieClasses[baseclass_id]             if baseclass and baseclass.BetterVersion and self:IsClassUnlocked(baseclass.BetterVersion) then                 baseclass_id = baseclass.BetterVersion             else                 break             end         end     end      return self.ZombieClasses[baseclass_id].Index end  function GM:ShouldUseBetterVersionSystem()     return true   end  local playerheight = Vector(0, 0, 72) local playermins = Vector(-17, -17, 0) local playermaxs = Vector(17, 17, 4) local SkewedDistance = util.SkewedDistance  GM.DynamicSpawnDistVisOld = 2048 GM.DynamicSpawnDistOld = 640 function GM:DynamicSpawnIsValidOld(zombie, humans, allplayers)                 if SERVER and zombie.LastHitWithTriggerHurt and CurTime() < zombie.LastHitWithTriggerHurt + 2 then         return false     end      local hpos, nearest, dist            if not humans then humans = team.GetPlayers(TEAM_HUMAN) end     if not allplayers then allplayers = player.GetAll() end      local pos = zombie:GetPos() + Vector(0, 0, 1)     if zombie:Alive() and zombie:GetMoveType() == MOVETYPE_WALK and zombie:OnGround()     and not util.TraceHull({start = pos, endpos = pos + playerheight, mins = playermins, maxs = playermaxs, mask = MASK_SOLID_BRUSHONLY, filter = allplayers}).Hit then         local vtr = util.TraceHull({start = pos, endpos = pos - playerheight, mins = playermins, maxs = playermaxs, mask = MASK_SOLID_BRUSHONLY})         if not vtr.HitSky and not vtr.HitNoDraw then             local valid = true              for _, human in pairs(humans) do                 hpos = human:GetPos()                 nearest = zombie:NearestPoint(hpos)                 dist = SkewedDistance(hpos, nearest, 2.75)                   if dist <= self.DynamicSpawnDistOld or dist <= self.DynamicSpawnDistVisOld and WorldVisible(hpos, nearest) then                       valid = false                     break                 end             end              return valid         end     end      return false end  function GM:GetBestDynamicSpawnOld(pl, pos)     local spawns = self:GetDynamicSpawnsOld(pl)     if #spawns == 0 then return end      return self:GetClosestSpawnPoint(spawns, pos or self:GetTeamEpicentre(TEAM_HUMAN)) or table.Random(spawns) end  function GM:GetDynamicSpawnsOld(pl)     local tab = {}      local allplayers = player.GetAll()     local humans = team.GetPlayers(TEAM_HUMAN)     for _, zombie in pairs(team.GetPlayers(TEAM_UNDEAD)) do         if zombie ~= pl and self:DynamicSpawnIsValidOld(zombie, humans, allplayers) then             table.insert(tab, zombie)         end     end      return tab end  GM.DynamicSpawnDist = 512 GM.DynamicSpawnDistVis = 2048 GM.CreeperNestDist = 150 GM.CreeperNestDistBuild = 420 GM.CreeperNestDistBuildNest = 128 GM.CreeperNestDistBuildZSpawn = 256 local trace_dynspawn = {mins = playermins, maxs = playermaxs, mask = MASK_SOLID_BRUSHONLY}   function GM:DynamicSpawnIsValid(ent, humans, allplayers)     if self:ShouldUseAlternateDynamicSpawn() then         return self:DynamicSpawnIsValidOld(ent, humans, allplayers)     end            if not humans then humans = team.GetPlayers(TEAM_HUMAN) end     if not allplayers then allplayers = player.GetAll() end      if not ent:IsValid() then         return false     end      local pos = ent:GetPos() + Vector(0, 0, 1)     local is_nest = ent:GetClass() == "prop_creepernest"                  if is_nest and not ent:GetNestBuilt() then         return false     end            trace_dynspawn.start = pos     trace_dynspawn.endpos = pos + playerheight     trace_dynspawn.filter = allplayers     table.insert(trace_dynspawn.filter, ent)     local tr = util.TraceHull(trace_dynspawn)     if tr.Hit then         return false     end                                                                                                                                                                    return true end  function GM:NearestSigilDataToNest(nest, sigil_table)     local closest_dist_to_a_sigil = math.huge     local nearest_sigil     local nest_position = nest:GetPos()      for i = 1, #sigil_table do         local sigil = sigil_table[i]         local dist_to_sigil = sigil:GetPos():Distance(nest_position)          if dist_to_sigil < closest_dist_to_a_sigil then             closest_dist_to_a_sigil = dist_to_sigil             nearest_sigil           = sigil         end     end      return closest_dist_to_a_sigil, nearest_sigil end  local sort_nest_to_sigil_mapping = function(a, b)     return a.Dist < b.Dist end  function GM:GetNestCloseToSigil(spawns)     local sigils = self:GetUncorruptedSigils()     local nest_table = {}     for i = 1, #sigils do         nest_table[sigils[i]] = {}     end      for _, nest in ipairs(spawns) do         local dist, nearest_sigil = self:NearestSigilDataToNest(nest, sigils)         if nearest_sigil then             nest_table[nearest_sigil][#nest_table + 1] = {                 Dist    = dist,                 Nest    = nest             }         end     end      local lowest_for_sigil_tbl = {}     for i = 1, #sigils do         local sigil = sigils[i]         local nest_bucket_for_sigil = nest_table[sigil]         local lowest_for_sigil = math.huge         local lowest_nest         for _, nest_data in ipairs(nest_bucket_for_sigil) do             local nest_dist = nest_data.Dist             if nest_dist < lowest_for_sigil then                 lowest_for_sigil = nest_dist                 lowest_nest      = nest_data.Nest             end         end          lowest_for_sigil_tbl[#lowest_for_sigil_tbl + 1] = {             Dist = lowest_for_sigil,             Nest = lowest_nest         }     end      if #lowest_for_sigil_tbl == 0 then return end      table.sort(lowest_for_sigil_tbl, sort_nest_to_sigil_mapping)      local winner, runner_up = lowest_for_sigil_tbl[1], lowest_for_sigil_tbl[2]     if runner_up and (runner_up.Dist - winner.Dist) < 80 then         return (math.random(2) == 1 and winner or runner_up).Nest     else         return winner.Nest     end end  function GM:GetBestDynamicSpawn(pl)     if self:ShouldUseAlternateDynamicSpawn() then         return self:GetBestDynamicSpawnOld(pl, pos)     end      local spawns = self:GetDynamicSpawns(pl)     if #spawns == 0 then return end            return self:GetNestCloseToSigil(spawns) or table.Random(spawns) end  function GM:GetDynamicSpawns(pl)     if self:ShouldUseAlternateDynamicSpawn() then         return self:GetDynamicSpawnsOld(pl)     end      local tab = {}      local humans = team.GetPlayers(TEAM_HUMAN)     for _, nest in pairs(ents.FindByClass("prop_creepernest")) do         if self:DynamicSpawnIsValid(nest, humans) then             table.insert(tab, nest)         end     end      return tab end  function GM:GetDesiredStartingZombies()     local numplayers = #player.GetAllActive()     local waveonecount = self.WaveOneZombies       local percent = self.StartZombiePercent or waveonecount      return math.Clamp(math.ceil(numplayers * percent), 1, numplayers - 1) end  function GM:GetEndRound()     return self.RoundEnded end  local function CacheSwepModel(tb, cached)     cached = cached or {}      for _, ele in pairs(tb) do         if ele.model and not cached[ele.model] then             util.PrecacheModel(ele.model)             cached[ele.model] = true         end     end      return cached end  function GM:PrecacheResources()     util.PrecacheSound("physics/body/body_medium_break2.wav")     util.PrecacheSound("physics/body/body_medium_break3.wav")     util.PrecacheSound("physics/body/body_medium_break4.wav")     for name, mdl in pairs(player_manager.AllValidModels()) do         util.PrecacheModel(mdl)     end      local cached = {}      for name, wep in pairs(weapons.GetList()) do         if wep.QualityTier or wep.Branch then continue end          if wep.ViewModel then             util.PrecacheModel(wep.ViewModel)         end         if wep.WorldModel then             util.PrecacheModel(wep.WorldModel)         end          if CLIENT then             if wep.VElements then                 cached = CacheSwepModel(wep.VElements, cached)             end             if wep.WElements then                 cached = CacheSwepModel(wep.WElements, cached)             end         end     end      game.AddParticles("particles/vman_explosion.pcf")      PrecacheParticleSystem("dusty_explosion_rockets") end  function GM:DoChangeDeploySpeed(wep)     if wep:IsValid() and wep.SetDeploySpeed and not wep.NoDeploySpeedChange then         local owner = wep:GetOwner()         wep:SetDeploySpeed(             self.BaseDeploySpeed *              (owner:IsValid() and owner.DeploySpeedMultiplier or 1) *              (owner:IsValid() and owner:GetStatus("debuff_frost") and 0.7 or 1) *             (wep.DeploySpeedMulti or 1)         )     end end  function GM:OnPlayerHitGround(pl, inwater, hitfloater, speed)     if inwater then return true end      if speed > 64 then         pl.LandSlow = true     end      local isundead = PTeam(pl) == TEAM_UNDEAD     if isundead and (pl:GetZombieClassTable().NoFallDamage or self.NoZombieFallDamage) then return true end      local threshold_mul     local slowdown_mul     local recovery_mul     local damage_mul      if isundead then         speed = math.max(0, speed - 200)          threshold_mul = 1         slowdown_mul = 1         recovery_mul = 1         damage_mul = 1     else         threshold_mul = pl.FallDamageThresholdMul or 1         slowdown_mul = pl.FallDamageSlowDownMul or 1         recovery_mul = pl.FallDamageRecoveryMul or 1         damage_mul = pl.FallDamageDamageMul or 1     end      local damage = (0.1 * (speed - 525 * threshold_mul)) ^ 1.45     if hitfloater then damage = damage / 2 end      if SERVER then         local groundent = pl:GetGroundEntity()         if groundent:IsValid() and groundent:GetDTBool(DT_PROP_BOOL_BARBEDWIRE) and pl:CooldownReady("BarbedWire") then             pl:AddNewCooldown("BarbedWire", 1)              local placer = groundent.BarbedWireOwner             if placer:IsValidLivingHuman() then                 pl:TakeSpecialDamage(14, DMG_SLASH, placer, self)             end         end     end      if math.floor(damage) > 0 then         if SERVER then             local h = pl:Health()             pl:TakeSpecialDamage(damage * damage_mul, DMG_FALL, game.GetWorld(), game.GetWorld(), pl:GetPos())             damage = h - pl:Health()              if not self.ZombieEscape and damage >= 5 and pl:Health() > 0 then                 if damage >= 30 then                     pl:KnockDown(damage * 0.05 * recovery_mul)                 end                 if not isundead or not pl:GetZombieClassTable().NoFallSlowdown then                     pl:RawCapLegDamage(CurTime() + math.min(2, damage * 0.038 * slowdown_mul))                 end             end              pl:EmitSound("player/pl_fallpain"..(math.random(2) == 1 and 3 or 1)..".wav")         elseif not self.ZombieEscape and damage >= 5 and (not isundead or not pl:GetZombieClassTable().NoFallSlowdown) then             pl:RawCapLegDamage(CurTime() + math.min(2, damage * 0.038 * slowdown_mul))         end     end      return true end  function GM:PlayerCanBeHealed(pl)     local frail = pl:IsSkillActive(SKILL_D_FRAIL)      return pl:Health() < pl:GetMaxHealth() or (not frail and (pl:GetPoisonDamage() > 0 or pl:GetBleedDamage() > 0)) end  function GM:PlayerCanPurchase(pl)     if CLIENT and self.CanPurchaseCacheTime and self.CanPurchaseCacheTime >= CurTime() then         return self.CanPurchaseCache     end     local canpurchase = PTeam(pl) == TEAM_HUMAN and self:GetWave() > 0 and pl:Alive() and pl:NearArsenalCrate()      if CLIENT then         self.CanPurchaseCache = canpurchase         self.CanPurchaseCacheTime = CurTime() + 0.5     end     return canpurchase end  function GM:PlayerTraceAttack(pl, dmginfo, dir, trace) end  shoot_system = "fire" function GM:DeriveIndex()     shoot_system = "game_shoot" .. game.GetMap() end  function GM:GetDamageResistance(fearpower)     if self.MaxSigils > 0 and self:GetUseSigils() then         local num_corrupted = self.CachedCorruptedSigilCount          return fearpower * 0.1 + num_corrupted / self.MaxSigils * 0.25     end      return fearpower * 0.1 end  function GM:FindUseEntity(pl, ent)     if not ent:IsValid() then         local e = pl:TraceLine(90, MASK_SOLID, pl:GetDynamicTraceFilter()).Entity         if e:IsValid() then return e end     end      return ent end  function GM:ShouldUseAlternateDynamicSpawn()     return self.ZombieEscape or self:IsClassicMode() or self.PantsMode end  function GM:GetZombieDamageScale(pos, ignore)     if LASTHUMAN then return self.ZombieDamageMultiplier end      return self.ZombieDamageMultiplier * (1 - self:GetDamageResistance(self:GetFearMeterPower(pos, TEAM_UNDEAD, ignore))) end  local temppos local function SortByDistance(a, b)     return a:GetPos():DistToSqr(temppos) < b:GetPos():DistToSqr(temppos) end  local function GetSortedSpawnPoints(teamid, pos)     temppos = pos     local spawnpoints     if type(teamid) == "table" then         spawnpoints = teamid     else         spawnpoints = team.GetValidSpawnPoint(teamid)     end      table.sort(spawnpoints, SortByDistance)     return spawnpoints end  function GM:GetClosestSpawnPoint(teamid, pos)     return GetSortedSpawnPoints(teamid, pos)[1] end  function GM:GetClosestSpecSpawnPoint(teamid, pos)     local closest_to_me, sel, spawnpoints = math.huge     if type(teamid) == "table" then         spawnpoints = teamid     else         spawnpoints = team.GetValidSpawnPoint(teamid)     end      for _,v in pairs(spawnpoints) do         if pos:DistToSqr(v:GetPos()) < closest_to_me then             sel = v             closest_to_me = pos:DistToSqr(v:GetPos())         end     end      return sel end  function GM:GetFurthestSpawnPoint(teamid, pos)     local spawnpoints = GetSortedSpawnPoints(teamid, pos)     return spawnpoints[#spawnpoints] end  local FEAR_RANGE = 768^2 local FEAR_PERINSTANCE = 0.075 local RALLYPOINT_THRESHOLD = 0.3  local function GetEpicenter(tab)     local vec = Vector(0, 0, 0)     if #tab == 0 then return vec end      for k, v in pairs(tab) do         vec = vec + v:GetPos()     end      return vec / #tab end  function GM:GetTeamRallyGroups(teamid)     local groups = {}     local ingroup = {}      local plys = team.GetPlayers(teamid)     local plpos, group      for _, pl in pairs(plys) do         if not ingroup[pl] and pl:Alive() then             plpos = pl:GetPos()             group = {pl}              for __, otherpl in pairs(plys) do                 if otherpl ~= pl and not ingroup[otherpl] and otherpl:Alive() and otherpl:GetPos():DistToSqr(plpos) <= FEAR_RANGE then                     group[#group + 1] = otherpl                 end             end              if #group * FEAR_PERINSTANCE >= RALLYPOINT_THRESHOLD then                 for k, v in pairs(group) do                     ingroup[v] = true                 end                 groups[#groups + 1] = group             end         end     end      return groups end  function GM:GetTeamRallyPoints(teamid)     local points = {}      for _, group in pairs(self:GetTeamRallyGroups(teamid)) do         points[#points + 1] = {GetEpicenter(group), math.min(1, (#group * FEAR_PERINSTANCE - RALLYPOINT_THRESHOLD) / (1 - RALLYPOINT_THRESHOLD))}     end      return points end  local CachedEpicentreTimes = {} local CachedEpicentres = {} function GM:GetTeamEpicentre(teamid, nocache)     if not nocache and CachedEpicentres[teamid] and CurTime() < CachedEpicentreTimes[teamid] then         return CachedEpicentres[teamid]     end      local plys = team.GetPlayers(teamid)     local vVec = Vector(0, 0, 0)     local considered = 0     for _, pl in pairs(plys) do         if pl:Alive() and pl:GetAuraRange() == 2048 then             vVec = vVec + pl:GetPos()             considered = considered + 1         end     end      local epicentre = vVec / considered     if not nocache then         CachedEpicentreTimes[teamid] = CurTime() + 0.5         CachedEpicentres[teamid] = epicentre     end      return epicentre end GM.GetTeamEpicenter = GM.GetTeamEpicentre  local ent_by_class_table = {} local function FindNumClassInEntTable(class)     local count = 0      for i = 1, #ent_by_class_table do         local opt_ent = ent_by_class_table[i]         if opt_ent and opt_ent:IsValid() then             local ent_class = opt_ent:GetClass()             local stripped_quality = string.sub(ent_class, 1, -4)              if stripped_quality == class or ent_class == class then                 count = count + 1             end         end     end      return count end  function GM:GetCurrentEquipmentCount(id)     local count = 0      ent_by_class_table = ents.GetAll()      local item = self.Items[id]     if item then         if item.Countables then             if type(item.Countables) == "table" then                 for k, v in pairs(item.Countables) do                     count = count + FindNumClassInEntTable(v)                 end             else                 count = count + FindNumClassInEntTable(item.Countables)             end         end          if item.SWEP then             count = count + FindNumClassInEntTable(item.SWEP)         end     end      return count end  function GM:GetFearMeterPower(pos, teamid, ignore)     if LASTHUMAN then return 1, FEAR_PERINSTANCE * 40 end      local dist      local power = 0      local pl_table = SERVER and player.GetAllFastMutable() or player.GetAll()     for _, pl in pairs(pl_table) do         if pl ~= ignore and PTeam(pl) == teamid and not pl:CallZombieFunction0("DoesntGiveFear") and pl:Alive() then             dist = pl:GetPos():DistToSqr(pos)             if dist <= FEAR_RANGE then                 power = power + (1 - dist / FEAR_RANGE) * (pl:GetZombieClassTable().FearPerInstance or FEAR_PERINSTANCE)             end         end     end      return math.min(1, power), power end  function GM:GetRagdollEyes(pl)     local Ragdoll = pl:GetRagdollEntity()     if not IsValid(Ragdoll) then return end      local att = Ragdoll:GetAttachment(Ragdoll:LookupAttachment("eyes"))     if att then         att.Pos = att.Pos + att.Ang:Forward() * -2         att.Ang = att.Ang          return att.Pos, att.Ang     end end  function GM:PlayerNoClip(pl, on)     if pl:IsAdmin() then         if SERVER then             PrintMessage(HUD_PRINTCONSOLE, translate.Format(on and "x_turned_on_noclip" or "x_turned_off_noclip", pl:Name()))         end          if SERVER then             pl:MarkAsBadProfile()         end          return true     end      return false end  function GM:IsSpecialPerson(pl, image)     local img, tooltip      if pl:SteamID() == "STEAM_0:1:19045957" then         img = "VGUI/servers/icon_robotron"         tooltip = "Developer"     elseif pl:IsAdmin() then         img = "VGUI/servers/icon_robotron"         tooltip = "Admin"     end      if img then         if CLIENT then             image:SetImage(img)             image:SetTooltip(tooltip)         end          return true     end      return false end  function GM:GetWaveEnd()     return GetGlobalFloat("waveend", 0) end  function GM:SetWaveEnd(time)     SetGlobalFloat("waveend", time) end  function GM:GetWaveStart()     return GetGlobalFloat("wavestart", self.WaveZeroLength) end  function GM:SetWaveStart(time)     SetGlobalFloat("wavestart", time) end  function GM:GetWave()     return GetGlobalInt("wave", 0) end  if GM:GetWave() == 0 then     GM:SetWaveStart(GM.WaveZeroLength)     GM:SetWaveEnd(GM.WaveZeroLength + GM:GetWaveOneLength()) end  function GM:GetWaveActive()     return GetGlobalBool("waveactive", false) end  function GM:SetWaveActive(active)     if self.RoundEnded then return end      if self:GetWaveActive() ~= active then         SetGlobalBool("waveactive", active)          if SERVER then             gamemode.Call("WaveStateChanged", active)         end     end end  if not FixedSoundDuration then FixedSoundDuration = true local OldSoundDuration = SoundDuration function SoundDuration(snd)     if snd then         local ft = string.sub(snd, -4)         if ft == ".mp3" then             return OldSoundDuration(snd) * 2.25         end         if ft == ".ogg" then             return OldSoundDuration(snd) * 3         end     end      return OldSoundDuration(snd) end end  function GM:VehicleMove() end  function GM:EntityEmitSound( data )     if CLIENT and data then         local ent = data.Entity         if ent:IsPlayer() then             local activ_weapon = ent:GetActiveWeapon()             if IsValid(activ_weapon) and activ_weapon.ReplaceSounds then                 local tbl = activ_weapon.ReplaceSounds                 if tbl[ data.SoundName ] then                     if tbl[ data.SoundName ].suppress then                         return false                     end                     if tbl[ data.SoundName ].override then                                                   if tbl[ data.SoundName ].pitch then                             data.Pitch = tbl[ data.SoundName ].pitch                         end                         data.SoundName = tbl[ data.SoundName ].override                         return true                     end                 end             end         end     end end