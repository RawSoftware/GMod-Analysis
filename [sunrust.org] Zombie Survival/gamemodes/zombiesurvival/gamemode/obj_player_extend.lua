local meta = FindMetaTable("Player")  local util_SharedRandom = util.SharedRandom local PLAYERANIMEVENT_FLINCH_HEAD = PLAYERANIMEVENT_FLINCH_HEAD local PLAYERANIMEVENT_ATTACK_PRIMARY = PLAYERANIMEVENT_ATTACK_PRIMARY local GESTURE_SLOT_FLINCH = GESTURE_SLOT_FLINCH local GESTURE_SLOT_ATTACK_AND_RELOAD = GESTURE_SLOT_ATTACK_AND_RELOAD local HITGROUP_HEAD = HITGROUP_HEAD local HITGROUP_CHEST = HITGROUP_CHEST local HITGROUP_STOMACH = HITGROUP_STOMACH local HITGROUP_LEFTLEG = HITGROUP_LEFTLEG local HITGROUP_RIGHTLEG = HITGROUP_RIGHTLEG local HITGROUP_LEFTARM = HITGROUP_LEFTARM local HITGROUP_RIGHTARM = HITGROUP_RIGHTARM local TEAM_UNDEAD = TEAM_UNDEAD local TEAM_SPECTATOR = TEAM_SPECTATOR local TEAM_HUMAN = TEAM_HUMAN local IN_ZOOM = IN_ZOOM local MASK_SOLID = MASK_SOLID local MASK_SOLID_BRUSHONLY = MASK_SOLID_BRUSHONLY local util_TraceLine = util.TraceLine local util_TraceHull = util.TraceHull  local getmetatable = getmetatable  local M_Entity = FindMetaTable("Entity")  local P_Team = meta.Team  local E_GetDTBool = M_Entity.GetDTBool local E_GetTable = M_Entity.GetTable  function meta:GetMaxHealthEx()     if P_Team(self) == TEAM_UNDEAD then         return self:GetMaxZombieHealth()     end      return self:GetMaxHealth() end  function meta:Dismember(dismembermenttype)     local effectdata = EffectData()         effectdata:SetOrigin(self:EyePos())         effectdata:SetEntity(self)         effectdata:SetScale(dismembermenttype)     util.Effect("dismemberment", effectdata, true, true) end  function meta:DoRandomEvent(event, maxrandom_s1)     self:DoCustomAnimEvent(event, math.ceil(util_SharedRandom("anim", 0, maxrandom_s1, self:EntIndex()))) end  function meta:DoZombieEvent()     self:DoRandomEvent(PLAYERANIMEVENT_ATTACK_PRIMARY, 7) end  function meta:DoFlinchEvent(hitgroup)     local base = util_SharedRandom("flinch", 1, self:EntIndex())     if hitgroup == HITGROUP_HEAD then         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base * 2 + 4)     elseif hitgroup == HITGROUP_CHEST  then         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base * 2 + 1)     elseif hitgroup == HITGROUP_STOMACH then         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base * 2 + 10)     elseif hitgroup == HITGROUP_LEFTARM then         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base + 8)     elseif hitgroup == HITGROUP_RIGHTARM then         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base + 9)     elseif hitgroup == HITGROUP_LEFTLEG then         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base + 6)     elseif hitgroup == HITGROUP_RIGHTLEG then         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base + 7)     elseif hitgroup == HITGROUP_BELT then         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base + 3)     else         self:DoCustomAnimEvent(PLAYERANIMEVENT_FLINCH_HEAD, base * 2)     end end  function meta:DoRandomFlinchEvent()     self:DoRandomEvent(PLAYERANIMEVENT_FLINCH_HEAD, 12) end  local FlinchSequences = {     "flinch_01",     "flinch_02",     "flinch_back_01",     "flinch_head_01",     "flinch_head_02",     "flinch_phys_01",     "flinch_phys_02",     "flinch_shoulder_l",     "flinch_shoulder_r",     "flinch_stomach_01",     "flinch_stomach_02", } function meta:DoFlinchAnim(data)     local seq = FlinchSequences[data] or FlinchSequences[1]     if seq then         local seqid = self:LookupSequence(seq)         if seqid > 0 then             self:AddVCDSequenceToGestureSlot(GESTURE_SLOT_FLINCH, seqid, 0, true)         end     end end  local ZombieAttackSequences = {     "zombie_attack_01",     "zombie_attack_02",     "zombie_attack_03",     "zombie_attack_04",     "zombie_attack_05",     "zombie_attack_06" } function meta:DoZombieAttackAnim(data)     local seq = ZombieAttackSequences[data] or ZombieAttackSequences[1]     if seq then         local seqid = self:LookupSequence(seq)         if seqid > 0 then             self:AddVCDSequenceToGestureSlot(GESTURE_SLOT_ATTACK_AND_RELOAD, seqid, 0, true)         end     end end  function meta:IsSpectator()     return P_Team(self) == TEAM_SPECTATOR end  function meta:GetAuraRange()     if GAMEMODE.ZombieEscape then         return 8192     end      local wep = self:GetActiveWeapon()     local aura_range = wep:IsValid() and wep.GetAuraRange     return aura_range and wep:GetAuraRange() or 2048, aura_range end  function meta:GetAuraRangeSqr()     local r, inverted = self:GetAuraRange()     return r * r, inverted end  function meta:GetPoisonDamage()     return self.Poison and self.Poison:IsValid() and self.Poison:GetDamage() or 0 end  function meta:GetBleedDamage()     return self.Bleed and self.Bleed:IsValid() and self.Bleed:GetDamage() or 0 end  function meta:CallWeaponFunction(funcname, ...)     local wep = self:GetActiveWeapon()     if wep:IsValid() and wep[funcname] then         return wep[funcname](wep, self, ...)     end end  function meta:ClippedName()     local name = self:Name()     if #name > 16 then         name = string.sub(name, 1, 14)..".."     end      return name end  function meta:SigilTeleportDestination(not_from_sigil, corrupted)     local sigils = corrupted and GAMEMODE:GetCorruptedSigils() or GAMEMODE:GetUncorruptedSigils()      if not_from_sigil then         if #sigils == 0 then return end     elseif #sigils <= 1 then return end      local mypos = self:GetPos()     local eyevector = self:GetAimVector()      local dist = 999999999999     local spos, d, icurrent, target, itarget      if not not_from_sigil then         for i, sigil in pairs(sigils) do             d = sigil:GetPos():DistToSqr(mypos)             if d < dist then                 dist = d                 icurrent = i             end         end     end      dist = -1     for i, sigil in pairs(sigils) do         if i == icurrent then continue end          spos = sigil:GetPos() - mypos         spos:Normalize()         d = spos:Dot(eyevector)         if d > dist then             dist = d             target = sigil             itarget = i         end     end      return target, itarget end  function meta:DispatchAltUse()     local tpexist = self:GetStatus("sigilteleport")     if tpexist and tpexist:IsValid() then         self:RemoveStatus("sigilteleport", false, true)         return     end      GAMEMODE:SetMeleeButRepairFlag(true)     local tr = self:CompensatedMeleeTrace(64, 4, nil, nil, nil, true)     GAMEMODE:SetMeleeButRepairFlag()      local ent = tr.Entity     if ent and ent:IsValid() and ent.AltUse then         return ent:AltUse(self, tr)     end end  function meta:MeleeViewPunch(damage)     if self:GetStatus("redmarrow") then return end      local boss_tier = self:GetBossTier() + 1      local maxpunch = math.max(3, 70 * damage / (damage + 70)) / boss_tier     local minpunch = -maxpunch      self:ViewPunch(Angle(math.Rand(minpunch, maxpunch), math.Rand(minpunch, maxpunch), 0)) end  function meta:NearArsenalCrate()     local pos = self:EyePos()     if GAMEMODE.BuyAnywhere then return true, true end     if self.ArsenalZone and self.ArsenalZone:IsValid() then return true end      local function IsNear(ent)         local nearest = ent:NearestPoint(pos)         if pos:DistToSqr(nearest) <= 22500 and (WorldVisible(pos, nearest) or self:TraceLine(150).Entity == ent) then               return true, ent.Sigil         end     end      local arseents = {}     table.Add(arseents, GAMEMODE:GetUncorruptedSigils())      for _, ent in pairs(arseents) do         local near, sigil = IsNear(ent)         if near then             return near, sigil         end     end      arseents = {}     table.Add(arseents, ents.FindByClass("prop_arsenalcrate"))     table.Add(arseents, ents.FindByClass("status_arsenalpack"))      for _, ent in pairs(arseents) do         local near, sigil = IsNear(ent)         if near then             return near, sigil         end     end      return false end meta.IsNearArsenalCrate = meta.NearArsenalCrate  function meta:NearRemantler()     local pos = self:EyePos()      local remantlers = ents.FindByClass("prop_remantler")      for _, ent in pairs(remantlers) do         local nearest = ent:NearestPoint(pos)         if pos:DistToSqr(nearest) <= 10000 and (WorldVisible(pos, nearest) or self:TraceLine(100).Entity == ent) then               return true         end     end      return false end  function meta:GetResupplyAmmoType()     local ammotype     if not self.ResupplyChoice then         local wep = self:GetActiveWeapon()         if wep:IsValid() then             ammotype = wep.GetResupplyAmmoType and wep:GetResupplyAmmoType() or wep.ResupplyAmmoType or wep:GetPrimaryAmmoTypeString()         end     end      ammotype = ammotype and ammotype:lower() or self.ResupplyChoice      if not ammotype or not GAMEMODE.AmmoResupply[ammotype] then         return "scrap"     end      return ammotype end  function meta:SetZombieClassName(classname)     if GAMEMODE.ZombieClasses[classname] then         self:SetZombieClass(GAMEMODE.ZombieClasses[classname].Index)     end end  function meta:GetPoints()     return self:GetDTInt(1) end  function meta:GetBloodArmor()     return self:GetDTInt(DT_PLAYER_INT_BLOODARMOR) end  function meta:GetBloodArmorMax()     return self:GetDTInt(DT_PLAYER_INT_BLOODARMOR_MAX) end  function meta:GetScore()     return self:GetDTInt(DT_PLAYER_INT_SCORE) end  function meta:GetSecondaryHands()  return self:GetDTEntity(DT_PLAYER_ENTITY_AKIMBO) end  function meta:AddLegDamage(damage)     if self.SpawnProtection then return end      local legdmg = self:GetLegDamage() + damage      if self:GetFlatLegDamage() - damage * 0.25 > damage then         legdmg = self:GetFlatLegDamage()     end      self:SetLegDamage(legdmg) end  function meta:AddLegDamageExt(damage, attacker, inflictor, type)     inflictor = inflictor or attacker      local base_damage = damage     local corrosion = self:GetStatus("dot_corrosion")     if not corrosion then         damage = damage * GAMEMODE:GetZombieDamageScale(self:WorldSpaceCenter(), self)     end      if type == SLOWTYPE_PULSE then         local legdmg = damage * (attacker.PulseWeaponSlowMul or 1)         local startleg = self:GetFlatLegDamage()          if SERVER then             self:PulseEffect(self:GetFlatLegDamage(), "hit_pulse")         end          self:AddLegDamage(legdmg)         if attacker.PulseImpedance then             self:AddArmDamage(legdmg * 0.6)         end          if SERVER then             local reso_thres = attacker.ResonanceThreshold             local difference = self:GetFlatLegDamage() - startleg             if reso_thres and reso_thres > 0 then                 attacker.AccuPulse = (attacker.AccuPulse or 0) + difference                  if attacker.AccuPulse > reso_thres then                     self:PulseResonance(attacker, inflictor)                 end             end              local ful_damage = attacker.FulminaricArc             if ful_damage and ful_damage > 0 then                 attacker.FulPulse = (attacker.FulPulse or 0) + difference                 if attacker.FulPulse > 45 then                     timer.Create("FulArc" .. attacker:UniqueID(), 0.06, 1, function()                         attacker.FulPulse = 0                          self:SlowingArc(attacker, inflictor, self, ful_damage, 5, 0)                          GAMEMODE:IncrementLightStat(attacker, PERSONAL_STAT_PULSE_DAMAGE_DEALT, ful_damage * 2.5)                     end)                 end             end              if difference > 5.5 and math.random(4) == 1 and attacker:HasInventoryItem("trinket_amethyst") then                 local status = self:GiveStatus("dot_shock")                 if status and status:IsValid() then                     status:AddDamage((difference - 4) * 10, attacker, inflictor)                 end             end         end     elseif type == SLOWTYPE_COLD then         if self:IsValidLivingZombie() and self:GetZombieClassTable().ResistFrost then return end          local cold_slow = attacker.ColdWeaponSlowMul or 1         local newdamage = damage * cold_slow         local scaled_base = base_damage * cold_slow          if SERVER then             self:PulseEffect(self:GetFlatLegDamage(), "hit_cold")         end          self:AddLegDamage(newdamage)         self:AddArmDamage(newdamage * 0.6)          local induct_chance = attacker.IceShatterChance         if SERVER and induct_chance and induct_chance > 0 then             self:CryogenicInduction(attacker, inflictor, scaled_base)         end     end end  function meta:GetMaxLegDamage()     local max = GAMEMODE.MaxLegDamage     if self:IsValidLivingZombie() and self:GetBossTier() >= 1 then         max = max/2     end      return max end  function meta:SetLegDamage(damage)     self.LegDamage = CurTime() + math.min(self:GetMaxLegDamage(), damage * 0.125)     if SERVER then         self:UpdateLegDamage()     end end  function meta:RawSetLegDamage(time)     self.LegDamage = math.min(CurTime() + self:GetMaxLegDamage(), time)     if SERVER then         self:UpdateLegDamage()     end end  function meta:RawCapLegDamage(time)     self:RawSetLegDamage(math.max(self.LegDamage or 0, time)) end  function meta:GetLegDamage()     return math.max(0, (self.LegDamage or 0) - CurTime()) end  function meta:GetFlatLegDamage()     return math.max(0, ((self.LegDamage or 0) - CurTime()) * 8) end  function meta:AddArmDamage(damage)     if self.SpawnProtection then return end      local armdmg = self:GetArmDamage() + damage      if self:GetFlatArmDamage() - damage * 0.25 > damage  then         armdmg = self:GetFlatArmDamage()     end      self:SetArmDamage(armdmg) end  function meta:GetMaxArmDamage()     local max = GAMEMODE.MaxArmDamage     if self:IsValidLivingZombie() and self:GetBossTier() >= 1 then         max = max/2     end      return max end  function meta:SetArmDamage(damage)     self.ArmDamage = CurTime() + math.min(self:GetMaxArmDamage(), damage * 0.125)     if SERVER then         self:UpdateArmDamage()     end end  function meta:RawSetArmDamage(time)     self.ArmDamage = math.min(CurTime() + self:GetMaxArmDamage(), time)     if SERVER then         self:UpdateArmDamage()     end end  function meta:RawCapArmDamage(time)     self:RawSetArmDamage(math.max(self.ArmDamage or 0, time)) end  function meta:GetArmDamage()     return math.max(0, (self.ArmDamage or 0) - CurTime()) end  function meta:GetFlatArmDamage()     return math.max(0, ((self.ArmDamage or 0) - CurTime()) * 8) end  function meta:GetZombieClass()     return E_GetTable(self).Class or GAMEMODE.DefaultZombieClass end  local ZombieClasses = {} if GAMEMODE then     ZombieClasses = GAMEMODE.ZombieClasses end hook.Add("Initialize", "LocalizeZombieClasses", function() ZombieClasses = GAMEMODE.ZombieClasses end) function meta:GetZombieClassTable()     return ZombieClasses[E_GetTable(self).Class or GAMEMODE.DefaultZombieClass] end      local zctab local zcfunc function meta:CallZombieFunction0(funcname)     if P_Team(self) == TEAM_UNDEAD then         zctab = ZombieClasses[E_GetTable(self).Class or GAMEMODE.DefaultZombieClass]         zcfunc = zctab[funcname]         if zcfunc then             return zcfunc(zctab, self)         end     end end  function meta:CallZombieFunction1(funcname, a1)     if P_Team(self) == TEAM_UNDEAD then         zctab = ZombieClasses[E_GetTable(self).Class or GAMEMODE.DefaultZombieClass]         zcfunc = zctab[funcname]         if zcfunc then             return zcfunc(zctab, self, a1)         end     end end  function meta:CallZombieFunction2(funcname, a1, a2)     if P_Team(self) == TEAM_UNDEAD then         zctab = ZombieClasses[E_GetTable(self).Class or GAMEMODE.DefaultZombieClass]         zcfunc = zctab[funcname]         if zcfunc then             return zcfunc(zctab, self, a1, a2)         end     end end  function meta:CallZombieFunction3(funcname, a1, a2, a3)     if P_Team(self) == TEAM_UNDEAD then         zctab = ZombieClasses[E_GetTable(self).Class or GAMEMODE.DefaultZombieClass]         zcfunc = zctab[funcname]         if zcfunc then             return zcfunc(zctab, self, a1, a2, a3)         end     end end  function meta:CallZombieFunction4(funcname, a1, a2, a3, a4)     if P_Team(self) == TEAM_UNDEAD then         zctab = ZombieClasses[E_GetTable(self).Class or GAMEMODE.DefaultZombieClass]         zcfunc = zctab[funcname]         if zcfunc then             return zcfunc(zctab, self, a1, a2, a3, a4)         end     end end meta.CallZombieFunction = meta.CallZombieFunction4    function meta:CallZombieFunction5(funcname, a1, a2, a3, a4, a5)     if P_Team(self) == TEAM_UNDEAD then         zctab = ZombieClasses[E_GetTable(self).Class or GAMEMODE.DefaultZombieClass]         zcfunc = zctab[funcname]         if zcfunc then             return zcfunc(zctab, self, a1, a2, a3, a4, a5)         end     end end  function meta:TraceLine(distance, mask, filter, start)     start = start or self:GetShootPos()     return util_TraceLine({start = start, endpos = start + self:GetAimVector() * distance, filter = filter or self, mask = mask}) end  function meta:TraceHull(distance, mask, size, filter, start)     start = start or self:GetShootPos()     return util_TraceHull({start = start, endpos = start + self:GetAimVector() * distance, filter = filter or self, mask = mask, mins = Vector(-size, -size, -size), maxs = Vector(size, size, size)}) end  function meta:SetSpeed(speed)     if not speed then speed = 200 end      local running = self:CurrentDecimalStamina() > 0 and self:IsSkillActive(SKILL_CARDIOTONIC) and self:KeyDown(IN_SPEED)     local runspeed = running and speed + 40 or speed      self:SetWalkSpeed(speed)     self:SetRunSpeed(runspeed)     self:SetMaxSpeed(runspeed)      self.IsRunning = running end  function meta:SetHumanSpeed(speed)     if P_Team(self) == TEAM_HUMAN then self:SetSpeed(speed) end end  function meta:ResetSpeed(noset, health)     if not self:IsValid() then return end      if P_Team(self) == TEAM_UNDEAD then         local class_tbl = self:GetZombieClassTable()          local speed = class_tbl.Speed * GAMEMODE.ZombieSpeedMultiplier * (class_tbl.Wave and class_tbl.Wave == 0 and GAMEMODE.ZombieEarlyEasySpeedMultiplier or 1)          self:SetSpeed(speed)         return speed     end      local wep = self:GetActiveWeapon()     local speed      if wep:IsValid() and wep.GetWalkSpeed then         speed = wep:GetWalkSpeed()     end      if not speed then         speed = wep.WalkSpeed or SPEED_NORMAL     end      if wep:IsValid() and self:IsSkillActive(SKILL_GUARDIAN) and wep.Stability and         (wep.GetBlockEnd and wep:GetBlockEnd() > CurTime() or wep.IsBlocking and wep:IsBlocking()) then          speed = speed * 0.7     end      if wep:IsValid() and wep.Exceed and wep:GetRevving() then         speed = speed * 0.4     end      if speed < SPEED_NORMAL then         speed = SPEED_NORMAL - (SPEED_NORMAL - speed) * (self.WeaponWeightSlowMul or 1)     end      if self.SkillSpeedAdd and P_Team(self) == TEAM_HUMAN then         speed = speed + self.SkillSpeedAdd     end      if self:IsSkillActive(SKILL_LIGHTWEIGHT) and wep:IsValid() and wep.IsMelee then         speed = speed + 6     end      speed = math.max(1, speed)      if 32 < speed and not GAMEMODE.ZombieEscape and not self:GetStatus("laststand") then         health = health or self:Health()         local maxhealth = self:GetMaxHealth() * 0.6666         if health < maxhealth then             speed = math.max(88, speed - speed * 0.4 * (1 - health / maxhealth) * (self.LowHealthSlowMul or 1))         end     end      if not noset then         self:SetSpeed(speed)     end      return speed end  function meta:ResetJumpPower(noset)     local power = DEFAULT_JUMP_POWER      if P_Team(self) == TEAM_UNDEAD then         power = self:CallZombieFunction0("GetJumpPower") or power          local classtab = self:GetZombieClassTable()         if classtab and classtab.JumpPower then             power = classtab.JumpPower         end     else         power = power * (self.JumpPowerMul or 1)          if self:GetBarricadeGhosting() and not self:GetStatus("buff_slipstream") then             power = power * 0.25             if not noset then                 self:SetJumpPower(power)             end              return power         end     end      local wep = self:GetActiveWeapon()     if wep and wep.ResetJumpPower then         power = wep:ResetJumpPower(power) or power     end      if not noset then         self:SetJumpPower(power)     end      return power end  function meta:GetBarricadeGhosting()     return E_GetDTBool(self, 0) end meta.IsBarricadeGhosting = meta.GetBarricadeGhosting  function meta:ShouldBarricadeGhostWith(ent)     return ent:IsBarricadeProp() end  function meta:BarricadeGhostingThink()     if self:KeyDown(IN_ZOOM) or self:ActiveBarricadeGhosting() then         if self.FirstGhostThink then             self:SetLocalVelocity(vector_origin)             self.FirstGhostThink = false         end          return     end      self.FirstGhostThink = true     self:SetBarricadeGhosting(false) end  meta.OldSetHealth = FindMetaTable("Entity").SetHealth function meta:SetHealth(health)     self:OldSetHealth(health)     if P_Team(self) == TEAM_HUMAN and 1 <= health then         self:ResetSpeed(nil, health)     end end  function meta:IsHeadcrab()     return P_Team(self) == TEAM_UNDEAD and GAMEMODE.ZombieClasses[self:GetZombieClass()].IsHeadcrab end  function meta:IsTorso()     return P_Team(self) == TEAM_UNDEAD and GAMEMODE.ZombieClasses[self:GetZombieClass()].IsTorso end  function meta:AirBrake()     local vel = self:GetVelocity()      vel.x = vel.x * 0.15     vel.y = vel.y * 0.15     if vel.z > 0 then         vel.z = vel.z * 0.15     end      self:SetLocalVelocity(vel) end  local temp_attacker = NULL local temp_attacker_team = -1 local temp_pen_ents = {} local temp_override_team local temp_melee_but_repair  function GM:SetMeleeButRepairFlag(res)     temp_melee_but_repair = res end  local function MeleeTraceFilter(ent)     local e_tb = E_GetTable(ent)      if ent == temp_attacker or e_tb.IgnoreMelee then         return false     end      local ent_team = getmetatable(ent) == meta and P_Team(ent)      if not temp_melee_but_repair and e_tb.IgnoreMeleeButRepair and temp_attacker_team == TEAM_HUMAN         or ent_team and ent_team == temp_attacker_team         or not temp_override_team and e_tb.IgnoreMeleeTeam and e_tb.IgnoreMeleeTeam == temp_attacker_team         or temp_pen_ents[ent]         or e_tb.IFrames and e_tb.IFrames > CurTime() then          return false     end      return true end  local function DynamicTraceFilter(ent)     if ent.IgnoreTraces or ent:IsPlayer() then         return false     end      return true end  local function MeleeTraceFilterFFA(ent)     local e_tb = E_GetTable(ent)     if ent == temp_attacker or e_tb.IgnoreMelee then         return false     end      if temp_pen_ents[ent] then         return false     end      return true end  local melee_trace = {filter = MeleeTraceFilter, mask = MASK_SOLID, mins = Vector(), maxs = Vector()}  function meta:GetDynamicTraceFilter()     return DynamicTraceFilter end  local function CheckFHB(tr, att)     local ent = tr.Entity      if ent:IsValid() then         local att_team = P_Team(att)         local e_tb = E_GetTable(ent)          if not temp_melee_but_repair and e_tb.IgnoreMeleeButRepair and att_team == TEAM_HUMAN then             return         end          if e_tb.FHB then             tr.Entity = tr.Entity:GetParent()         end     end end  function meta:MeleeTrace(distance, size, start, dir, hit_team_members, override_team, override_mask, trace_extend)     start = start or self:GetShootPos()     dir = dir or self:GetAimVector()     hit_team_members = hit_team_members or GAMEMODE.RoundEnded      local tr      temp_attacker = self     temp_attacker_team = P_Team(self)     temp_override_team = override_team     melee_trace.start = start     melee_trace.endpos = start + dir * distance     melee_trace.mask = override_mask or MASK_SOLID     melee_trace.mins.x = -size     melee_trace.mins.y = -size     melee_trace.mins.z = -size     melee_trace.maxs.x = size     melee_trace.maxs.y = size     melee_trace.maxs.z = size     melee_trace.filter = hit_team_members and MeleeTraceFilterFFA or MeleeTraceFilter      melee_trace.endpos = melee_trace.endpos + dir * (trace_extend and 16 or 0)     tr = util_TraceLine(melee_trace)     tr.extended = trace_extend     melee_trace.endpos = melee_trace.endpos - dir * (trace_extend and 16 or 0)      CheckFHB(tr, self)      if trace_extend and self:Team() == TEAM_HUMAN and tr.Hit and not tr.Entity:IsValidPlayer() and start:DistToSqr(tr.HitPos) > distance * distance then         tr.Hit = false         tr.HitNonWorld = false         tr.Entity = NULL     end      if not tr.Hit then         tr = util_TraceHull(melee_trace)         tr.extended = nil     end      return tr end  local function InvalidateCompensatedTrace(tr, start, distance, ping)           distance = distance + (tr.extended and 16 or 0)     if tr.Entity:IsValid() and tr.Entity:IsPlayer() and tr.HitPos:DistToSqr(start) > distance * distance + 9 then           tr.Hit = false         tr.HitNonWorld = false         tr.Entity = NULL     end end  function meta:CompensatedMeleeTrace(distance, size, start, dir, hit_team_members, override_team, trace_extend)     start = start or self:GetShootPos()     dir = dir or self:GetAimVector()      self:LagCompensation(true)     local tr = self:MeleeTrace(distance, size, start, dir, hit_team_members, override_team, nil, trace_extend)     CheckFHB(tr, self)     self:LagCompensation(false)      InvalidateCompensatedTrace(tr, start, distance)      return tr end  function meta:CompensatedPenetratingMeleeTrace(distance, size, start, dir, hit_team_members, trace_extend)     start = start or self:GetShootPos()     dir = dir or self:GetAimVector()      self:LagCompensation(true)     local t = self:PenetratingMeleeTrace(distance, size, start, dir, hit_team_members, trace_extend)     self:LagCompensation(false)      for _, tr in pairs(t) do         InvalidateCompensatedTrace(tr, start, distance)     end      return t end  function meta:CompensatedZombieMeleeTrace(distance, size, start, dir, hit_team_members)     start = start or self:GetShootPos()     dir = dir or self:GetAimVector()      local ping_reduction = math.max(0, (self:Ping() - 170)/13)     local ping_adj_distance = distance - ping_reduction      self:LagCompensation(true)     local t = self:PenetratingMeleeTrace(distance, size, start, dir, hit_team_members)     self:LagCompensation(false)      local guardians     local guardian_tab = {}     for _, tr in pairs(t) do         InvalidateCompensatedTrace(tr, tr.StartPos, ping_adj_distance)          local ent = tr.Entity         local activ = ent:IsValidLivingHuman() and ent:GetActiveWeapon()         if activ and ent:IsSkillActive(SKILL_GUARDIAN) and activ.IsBlocking and activ:IsBlocking() then             table.insert(guardian_tab, tr)             guardians = true         end     end      return guardians and guardian_tab or t, guardians and t end  function meta:PenetratingMeleeTrace(distance, size, start, dir, hit_team_members, trace_extend)     start = start or self:GetShootPos()     dir = dir or self:GetAimVector()     hit_team_members = hit_team_members or GAMEMODE.RoundEnded      local tr, ent      temp_attacker = self     temp_attacker_team = P_Team(self)     temp_pen_ents = {}     melee_trace.start = start     melee_trace.endpos = start + dir * distance     melee_trace.mask = MASK_SOLID     melee_trace.mins.x = -size     melee_trace.mins.y = -size     melee_trace.mins.z = -size     melee_trace.maxs.x = size     melee_trace.maxs.y = size     melee_trace.maxs.z = size     melee_trace.filter = hit_team_members and MeleeTraceFilterFFA or MeleeTraceFilter      local t = {}     local onlyhitworld     for i=1, 50 do         melee_trace.endpos = melee_trace.endpos + dir * (trace_extend and 16 or 0)         tr = util_TraceLine(melee_trace)         tr.extended = trace_extend         melee_trace.endpos = melee_trace.endpos - dir * (trace_extend and 16 or 0)          if trace_extend and tr.Hit and not tr.Entity:IsValidPlayer() and start:DistToSqr(tr.HitPos) > distance * distance then             tr.Hit = false             tr.HitNonWorld = false             tr.Entity = NULL         end          if not tr.Hit then             tr = util_TraceHull(melee_trace)             tr.extended = nil         end          if not tr.Hit then break end          if tr.HitWorld then             table.insert(t, tr)             break         end          if onlyhitworld then break end          CheckFHB(tr, self)          ent = tr.Entity         if ent:IsValid() then             if not ent:IsPlayer() then                 melee_trace.mask = MASK_SOLID_BRUSHONLY                 onlyhitworld = true             end              table.insert(t, tr)             temp_pen_ents[ent] = true         end     end      temp_pen_ents = {}      return t, onlyhitworld end  function meta:ActiveBarricadeGhosting(override)     if P_Team(self) ~= TEAM_HUMAN and not override or not self:GetBarricadeGhosting() then return false end      local min, max = self:WorldSpaceAABB()     min.x = min.x + 1     min.y = min.y + 1      max.x = max.x - 1     max.y = max.y - 1      for _, ent in pairs(ents.FindInBox(min, max)) do         if ent and ent:IsValid() and self:ShouldBarricadeGhostWith(ent) then return true end     end      return false end  function meta:IsHolding()     return self:GetHolding():IsValid() end meta.IsCarrying = meta.IsHolding  function meta:GetHolding()     local status = self.status_human_holding     if status and status:IsValid() then         local obj = status:GetObject()         if obj:IsValid() then return obj end     end      return NULL end  function meta:NearestRemantler()     local pos = self:EyePos()      local remantlers = ents.FindByClass("prop_remantler")     local min, remantler = 99999      for _, ent in pairs(remantlers) do         local nearpoint = ent:NearestPoint(pos)         local trmatch = self:TraceLine(100).Entity == ent         local dist = trmatch and 0 or pos:DistToSqr(nearpoint)         if pos:DistToSqr(nearpoint) <= 10000 and dist < min then             remantler = ent         end     end      return remantler end  function meta:GetMaxZombieHealth()     local zombieclass = ZombieClasses[E_GetTable(self).Class or GAMEMODE.DefaultZombieClass]     local class_wave  = zombieclass.Wave or 1     local hp_per_wave = zombieclass.HealthPerWave and (GAMEMODE:GetWave() - class_wave) * zombieclass.HealthPerWave or                         0      return (zombieclass.Health + math.max(0, hp_per_wave)) * self:GetBossHealthScaling() end  local oldmaxhealth = FindMetaTable("Entity").GetMaxHealth function meta:GetMaxHealth()     if P_Team(self) == TEAM_UNDEAD then         return self:GetMaxZombieHealth()     end      return oldmaxhealth(self) end  local P_ObserverMode = meta.GetObserverMode local OBS_MODE_NONE = OBS_MODE_NONE if not meta.OldAlive then     meta.OldAlive = meta.Alive     function meta:Alive()         return self:OldAlive() and P_ObserverMode(self) == OBS_MODE_NONE and not E_GetTable(self).NeverAlive     end end    function meta:SyncAngles()     local ang = self:EyeAngles()     ang.pitch = 0     ang.roll = 0     return ang end meta.GetAngles = meta.SyncAngles  function meta:GetForward()     return self:SyncAngles():Forward() end  function meta:GetUp()     return self:SyncAngles():Up() end  function meta:GetRight()     return self:SyncAngles():Right() end  function meta:GetZombieMeleeSpeedMul()     return 1 * (1 + math.Clamp(self:GetArmDamage() / GAMEMODE.MaxArmDamage, 0, 1)) / (self:GetStatus("zombie_battlecry") and 1.2 or 1) end  function meta:GetMeleeSpeedMul()     if P_Team(self) == TEAM_UNDEAD then         return self:GetZombieMeleeSpeedMul()     end      local fervor_bonus = self:GetStatus("buff_stack_fervor")     fervor_bonus     = fervor_bonus and (1 + fervor_bonus:GetDTInt(1) * 0.08) or 1      return (self.MeleeAttackSpeedMul or 1) * (1 + math.Clamp(self:GetArmDamage() / GAMEMODE.MaxArmDamage, 0, 1))         / (self:GetStatus("buff_agility") and 1.2 or 1)         / (self:GetStatus("laststand") and 1.3 or 1)         / fervor_bonus end  function meta:GetMeleeStaminaUseMul()     local fervor_bonus = self:GetStatus("buff_stack_fervor")     fervor_bonus     = fervor_bonus and (1 + fervor_bonus:GetDTInt(1) * 0.04) or 1      return (self.MeleeStaminaMul or 1)         / (self:GetStatus("buff_agility") and 1.1 or 1)         / fervor_bonus end  function meta:GetPhantomHealth()     return self:GetDTFloat(DT_PLAYER_FLOAT_PHANTOMHEALTH) end  local overlaps_vector = Vector() local overlaps_ent local overlaps_filter = function(ent)     if overlaps_ent and ent == overlaps_ent then         return true     end end  function meta:OverlapsEntity(check_ent)     local bottom, top     if self:Crouching() then         bottom, top = self:GetHullDuck()     else         bottom, top = self:GetHull()     end      overlaps_ent = check_ent     overlaps_vector.z = top.z      local tr_start = self:GetPos()     local tr_end = tr_start + overlaps_vector     top.z = 0            local tr = util_TraceHull({         start = tr_start,         endpos = tr_end,         filter = overlaps_filter,         mins = bottom,         maxs = top,         mask = MASK_PLAYERSOLID,         ignoreworld = true     })      return tr.Entity == check_ent end  function meta:SetBarricadeGhosting(b, fullspeed)     if self == NULL then return end        if fullspeed == nil then fullspeed = false end      self:SetDTBool(0, b)     self:SetDTFloat(19, b and fullspeed and CurTime() + 2.5 or 0)      if SERVER then         if b then             self:RemoveCollisionFlag(ZS_COLLISIONFLAGS_HUMAN_PHASE)         else             self:AddCollisionFlag(ZS_COLLISIONFLAGS_HUMAN_PHASE)         end     else         self:CollisionRulesChanged()     end      self:ResetJumpPower() end  function meta:GetBossTier()     local classtab = self:GetZombieClassTable()      return  classtab.GreatEvil and 3 or             classtab.Boss and 2 or             classtab.Demiboss and 1 or             0 end  function meta:GetBossHealthScaling(advance)     local boss_tier = self:GetBossTier()     if boss_tier == 0 then         return 1     end      local wave_scaling = GAMEMODE.BossHealthScalingWave[GAMEMODE:GetWave() + (advance or 0) + 1]     wave_scaling =  wave_scaling and boss_tier == 3 and math.max(1, wave_scaling * 1.25) or                     wave_scaling or 1      local player_count_scale = 0.85 + math.max(-0.25, (player.GetCount() - 30) * 0.006)      return wave_scaling * player_count_scale end