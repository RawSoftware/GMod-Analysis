include("registry_modifiers.lua") include("registry.lua")    function GM:LevelForXP(xp)     return math.floor(1 + 0.25 * math.sqrt(xp)) end  function GM:XPForLevel(level)     return 16 * level * level - 32 * level + 16 end  function GM:ProgressForXP(xp)  local current_level = self:LevelForXP(xp)  if current_level >= self.MaxLevel then return 1 end   local current_level_xp = self:XPForLevel(current_level)  local next_level_xp = self:XPForLevel(current_level + 1)   return (xp - current_level_xp) / (next_level_xp - current_level_xp) end  GM.MaxLevel = 50 GM.MaxXP = GM:XPForLevel(GM.MaxLevel)    function GM:FixSkillConnections()  for skillid, skill in pairs(self.Skills) do  for connectid, _ in pairs(skill.Connections) do  local otherskill = self.Skills[connectid]  if otherskill and not otherskill.Connections[skillid] then  otherskill.Connections[skillid] = true  end  end  end end  function GM:SkillIsNeighbor(skillid, otherskillid)  local myskill = self.Skills[skillid]  return myskill ~= nil and self.Skills[otherskillid] ~= nil and myskill.Connections[otherskillid] end  function GM:SkillCanUnlock(pl, skillid, skilllist)  local skill = self.Skills[skillid]  if skill then  if skill.RemortLevel and pl:GetZSRemortLevel() < skill.RemortLevel then  return false  end   local connections = skill.Connections   if connections[SKILL_NONE] then  return true  end   for _, myskillid in pairs(skilllist) do  if connections[myskillid] then  return true  end  end  end   return false end  local meta = FindMetaTable("Player") if not meta then return end  local M_Entity = FindMetaTable("Entity") local E_GetTable = M_Entity.GetTable  function meta:IsSkillUnlocked(skillid)  return table.HasValue(self:GetUnlockedSkills(), skillid) end  function meta:SkillCanUnlock(skillid)  return GAMEMODE:SkillCanUnlock(self, skillid, self:GetUnlockedSkills()) end  function meta:IsSkillDesired(skillid)  return table.HasValue(self:GetDesiredActiveSkills(), skillid) end  local dummy_tb = {} function meta:IsSkillActive(skillid)     local active_skills = E_GetTable(self).ActiveSkills   return active_skills and active_skills[skillid] end  local trinket_suffix = "trinket_" local function ImplicitHasTrinket(tb, tb_ilvl)  return function(item, level)  local itype = trinket_suffix .. item  return tb[itype] and tb[itype] > 0 and (not level or level and tb_ilvl[itype] == level)   end end  local return_table = {}  function meta:InventoryItemSingleton(trinket_using_func)  local pl_tb, pl_tb_ilvl = GAMEMODE.ZSInventory, GAMEMODE.ZSInventoryTrinketLevel  if SERVER then  local tb        = E_GetTable(self)  pl_tb, pl_tb_ilvl = tb.ZSInventory, tb.ZSInventoryTrinketLevel  end      return_table.includes = ImplicitHasTrinket(pl_tb, pl_tb_ilvl)  trinket_using_func(return_table) end  function meta:CreateTrinketStatus(status)  for _, ent in pairs(ents.FindByClass("status_" .. status)) do  if ent:GetOwner() == self then return end  end   local ent = ents.Create("status_" .. status)  if ent:IsValid() then  ent:SetPos(self:EyePos())  ent:SetParent(self)  ent:SetOwner(self)  ent:Spawn()  end end  function meta:ApplyAssocModifiers(assoc)  local skillmodifiers = {}  local gm_modifiers = GAMEMODE.SkillModifiers  for skillid in pairs(assoc) do  local modifiers = gm_modifiers[skillid]  if modifiers then  for modid, amount in pairs(modifiers) do  skillmodifiers[modid] = (skillmodifiers[modid] or 0) + amount  end  end  end   for modid, func in pairs(GAMEMODE.SkillModifierFunctions) do  func(self, skillmodifiers[modid] or 0)  end end    function meta:ApplySkills(override)  if GAMEMODE.ZombieEscape or GAMEMODE.ClassicMode then return end     local allskills = GAMEMODE.Skills  local desired = override or self:Alive() and self:Team() == TEAM_HUMAN and self:GetDesiredActiveSkills() or {}  local current_active = self:GetActiveSkills()  local desired_assoc = table.ToAssoc(desired)      if not override then  for skillid in pairs(desired_assoc) do  if not self:IsSkillUnlocked(skillid) or allskills[skillid] and allskills[skillid].Disabled then  desired_assoc[skillid] = nil  end  end  end   self:ApplyAssocModifiers(desired_assoc)      local funcs  local gm_functions = GAMEMODE.SkillFunctions  for skillid in pairs(allskills) do   funcs = gm_functions[skillid]  if funcs then  if current_active[skillid] and not desired_assoc[skillid] then    for _, func in pairs(funcs) do  func(self, false)  end  elseif desired_assoc[skillid] and not current_active[skillid] then    for _, func in pairs(funcs) do  func(self, true)  end  end    end  end      self:SetActiveSkills(desired_assoc, not self.PlayerReady)   if SERVER and self.ExtraStartingWorth ~= self.LastSentESW then  self.LastSentESW = self.ExtraStartingWorth  net.Start("zs_extrastartingworth")  net.WriteUInt(self.ExtraStartingWorth, 16)  net.Send(self)  end end    local trinket_env = meta.InventoryItemSingleton local paired_weapon_prefix = "weapon_zs_t_" function meta:ApplyTrinkets(override)  if GAMEMODE.ZombieEscape or GAMEMODE.ClassicMode then return end     local allskills = GAMEMODE.Skills  local current_active = self:GetActiveSkills()  local real_assoc = table.ToAssoc(current_active)   if not override then  trinket_env(self, function(trinkets)  for skillid, skilltbl in pairs(allskills) do  local skill_trinket = skilltbl.Trinket  if skill_trinket then  local hastrinket = trinkets.includes(skill_trinket, skilltbl.HasQuality)  real_assoc[skillid] = hastrinket and true or nil   if SERVER then  if skilltbl.PairedWeapon then  local pairedwep = paired_weapon_prefix .. skill_trinket  if hastrinket and not self:HasWeapon(pairedwep) then                                 self.CannotSwitchWeapon = true  self:Give(pairedwep)                                 self.CannotSwitchWeapon = nil  elseif not hastrinket and self:HasWeapon(pairedwep) then  self:StripWeapon(pairedwep)  end  end   if hastrinket and skilltbl.Status then  self:CreateTrinketStatus(skilltbl.Status)  end  end  end  end   end)  end   self:ApplyAssocModifiers(real_assoc)   local funcs  local gm_functions = GAMEMODE.SkillFunctions  for skillid in pairs(allskills) do  funcs = gm_functions[skillid]  if funcs then  if not real_assoc[skillid] then    for _, func in pairs(funcs) do  func(self, false)  end  elseif real_assoc[skillid] then    for _, func in pairs(funcs) do  func(self, true)  end  end  end  end end  function meta:CanSkillsRemort()  return self:GetZSLevel() >= GAMEMODE.MaxLevel end meta.CanSkillRemort = meta.CanSkillsRemort  function meta:SetSkillActive(skillid, active, nosend)  local skills = table.ToAssoc(self:GetActiveSkills())  skills[active] = active  self:SetActiveSkills(skills, nosend) end  function meta:GetZSLevel()  return math.floor(GAMEMODE:LevelForXP(self:GetZSXP())) end  function meta:GetZSRemortLevel()  return self:GetDTInt(DT_PLAYER_INT_REMORTLEVEL) end  function meta:GetZSRemortLevelGraded()  return math.floor(self:GetZSRemortLevel() / 4) end  function meta:GetZSXP()  return self:GetDTInt(DT_PLAYER_INT_XP) end  function meta:GetZSSPUsed()  return #self:GetUnlockedSkills() end  function meta:GetZSSPRemaining()  return self:GetZSSPTotal() - self:GetZSSPUsed() end  function meta:GetZSSPTotal()  return self:GetZSLevel() + self:GetZSRemortLevel() end  function meta:GetDesiredActiveSkills()     local e_tb = E_GetTable(self)   return e_tb["DesiredActiveSkills"] or dummy_tb end  function meta:GetActiveSkills()  return E_GetTable(self).ActiveSkills or dummy_tb end  function meta:GetUnlockedSkills()     local e_tb = E_GetTable(self)   return e_tb["UnlockedSkills"] or dummy_tb end  function meta:GetTotalAdditiveModifier(...)     local tb = E_GetTable(self)   local totalmod = 1  for i, modifier in ipairs({...}) do  totalmod = totalmod + (tb[modifier] or 1) - 1  end  return totalmod end 