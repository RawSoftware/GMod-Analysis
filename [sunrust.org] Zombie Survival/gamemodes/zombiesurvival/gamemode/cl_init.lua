include("sh_globals.lua")  include("obj_entity_extend_cl.lua") include("obj_player_extend_cl.lua") include("obj_particle_extend_cl.lua") include("obj_weapon_extend_cl.lua")  include("loader.lua")  include("shared.lua") include("cl_draw.lua") include("cl_hud.lua") include("cl_collision.lua") include("cl_util.lua") include("cl_options.lua") include("cl_scoreboard.lua") include("cl_targetid.lua") include("cl_postprocess.lua") include("cl_voicesets.lua") include("cl_net.lua")  include("skillweb/cl_skillweb.lua")  include("vgui/dteamcounter.lua") include("vgui/dmodelpanelex.lua") include("vgui/dammocounter.lua") include("vgui/dteamheading.lua") include("vgui/dmodelkillicon.lua")  include("vgui/dexroundedpanel.lua") include("vgui/dexroundedframe.lua") include("vgui/dexcheckbox.lua") include("vgui/dexrotatedimage.lua") include("vgui/dexnotificationslist.lua") include("vgui/dexchanginglabel.lua")  include("vgui/mainmenu.lua") include("vgui/pmainmenu.lua") include("vgui/poptions2.lua") include("vgui/phelp.lua") include("vgui/pclassselect.lua") include("vgui/pweapons.lua") include("vgui/pbestiary.lua") include("vgui/pendboard.lua") include("vgui/pworth.lua") include("vgui/parsenal.lua") include("vgui/preward.lua") include("vgui/premantle.lua") include("vgui/pstatuses.lua") include("vgui/pitemviewer.lua") include("vgui/dpingmeter.lua") include("vgui/dsidemenu.lua") include("vgui/dspawnmenu.lua") include("vgui/dprogressbar.lua") include("vgui/zsgamestate.lua") include("vgui/zshealtharea.lua") include("vgui/zsstatusarea.lua")  include("cl_dermaskin.lua") include("cl_deathnotice.lua") include("cl_floatingscore.lua") include("cl_hint.lua") include("cl_thirdperson.lua")  include("itemstocks/cl_stock.lua")  include("sck/cl_sck.lua")  include("cl_zombieescape.lua")         local collectgarbage = collectgarbage local render = render local surface = surface local draw = draw local cam = cam local player = player local ents = ents local util = util local math = math local string = string local bit = bit local gamemode = gamemode local hook = hook local Vector = Vector local VectorRand = VectorRand local Angle = Angle local AngleRand = AngleRand local Entity = Entity local Color = Color local FrameTime = FrameTime local RealTime = RealTime local CurTime = CurTime local SysTime = SysTime local EyePos = EyePos local EyeAngles = EyeAngles local pairs = pairs local ipairs = ipairs local tostring = tostring local tonumber = tonumber local type = type local ScrW = ScrW local ScrH = ScrH local Lerp = Lerp local EF_DIMLIGHT = EF_DIMLIGHT local TEXT_ALIGN_CENTER = TEXT_ALIGN_CENTER local TEXT_ALIGN_LEFT = TEXT_ALIGN_LEFT local TEXT_ALIGN_RIGHT = TEXT_ALIGN_RIGHT local TEXT_ALIGN_TOP = TEXT_ALIGN_TOP local TEXT_ALIGN_BOTTOM = TEXT_ALIGN_BOTTOM local TEXT_ALIGN_TOP_REAL = TEXT_ALIGN_TOP_REAL local TEXT_ALIGN_BOTTOM_REAL = TEXT_ALIGN_BOTTOM_REAL  local TEAM_HUMAN = TEAM_HUMAN local TEAM_UNDEAD = TEAM_UNDEAD local translate = translate  local COLOR_PURPLE = COLOR_PURPLE local COLOR_GRAY = COLOR_GRAY local COLOR_RED = COLOR_RED local COLOR_DARKRED = COLOR_DARKRED local COLOR_DARKGREEN = COLOR_DARKGREEN local COLOR_GREEN = COLOR_GREEN local COLOR_WHITE = COLOR_WHITE  local vector_up = Vector(0, 0, 1) local vector_down = Vector(0, 0, -1)  local surface_SetMaterial = surface.SetMaterial local surface_SetDrawColor = surface.SetDrawColor local surface_DrawTexturedRect = surface.DrawTexturedRect local surface_PlaySound = surface.PlaySound  local render_SetBlend = render.SetBlend local render_ModelMaterialOverride = render.ModelMaterialOverride local render_SetColorModulation = render.SetColorModulation local render_SuppressEngineLighting = render.SuppressEngineLighting local cam_IgnoreZ = cam.IgnoreZ local render_SetMaterial = render.SetMaterial local render_DrawQuadEasy = render.DrawQuadEasy local cam_Start3D = cam.Start3D local cam_End3D = cam.End3D local cam_Start3D2D = cam.Start3D2D local cam_End3D2D = cam.End3D2D local render_FogMode = render.FogMode local render_FogStart = render.FogStart local render_FogEnd = render.FogEnd local render_FogColor = render.FogColor local render_FogMaxDensity = render.FogMaxDensity local render_GetFogDistances = render.GetFogDistances local render_GetFogColor = render.GetFogColor  local math_abs = math.abs local math_Approach = math.Approach local math_max = math.max  local draw_SimpleTextBlur = draw.SimpleTextBlur  local MedicalAuraDistance = 800 ^ 2  local M_Player = FindMetaTable("Player") local M_Entity = FindMetaTable("Entity")  local P_Team = M_Player.Team  local E_GetTable = M_Entity.GetTable  w, h = ScrW(), ScrH()  MySelf = MySelf or NULL hook.Add("InitPostEntity", "GetLocal", function()     MySelf = LocalPlayer()      GAMEMODE.HookGetLocal = GAMEMODE.HookGetLocal or function(g) end     gamemode.Call("HookGetLocal", MySelf)     RunConsoleCommand("initpostentity")      MySelf:ApplySkills() end)    local dummy = CreateClientConVar("_zs_dummyconvar", 1, false, false) function CreateClientConVar( name, default, shouldsave, userdata, helptext )     local iFlags = 0     iFlags = bit.bor(iFlags, FCVAR_DONTRECORD)      if shouldsave or shouldsave == nil then         iFlags = bit.bor(iFlags, FCVAR_ARCHIVE)     end      if userdata then         iFlags = bit.bor(iFlags, FCVAR_USERINFO)     end      return CreateConVar(name, default, iFlags, helptext) or dummy end  GM.LifeStatsBrainsEaten = 0 GM.LifeStatsHumanDamage = 0 GM.LifeStatsBarricadeDamage = 0 GM.InputMouseX = 0 GM.InputMouseY = 0 GM.LastTimeDead = 0 GM.LastTimeAlive = 0 GM.HeartBeatTime = 0 GM.FOVLerp = 1 GM.HurtEffect = 0 GM.PrevHealth = 0 GM.SuppressArsenalTime = 0 GM.ZombieThirdPerson = false GM.Beats = {} GM.BeatsWave6 = {} GM.CurrentRound = 1  GM.DeathFog = 0 GM.FogStart = 0 GM.FogEnd = 8000 GM.FogRed = 30 GM.FogGreen = 30 GM.FogBlue = 30  function GM:ClickedPlayerButton(pl, button) end  function GM:ClickedEndBoardPlayerButton(pl, button) end  function GM:CenterNotify(...)     if self.CenterNotificationHUD and self.CenterNotificationHUD:IsValid() then         return self.CenterNotificationHUD:AddNotification(...)     end end  function GM:TopNotify(...)     if self.TopNotificationHUD and self.TopNotificationHUD:IsValid() then         return self.TopNotificationHUD:AddNotification(...)     end end  function GM:_InputMouseApply(cmd, x, y, ang)     if MySelf:KeyDown(IN_WALK) and MySelf:IsHolding() then         self.InputMouseX = math.NormalizeAngle(self.InputMouseX - x * 0.02 * GAMEMODE.PropRotationSensitivity)         self.InputMouseY = math.NormalizeAngle(self.InputMouseY - y * 0.02 * GAMEMODE.PropRotationSensitivity)          local snap = GAMEMODE.PropRotationSnap         local snapanglex, snapangley = self.InputMouseX, self.InputMouseY         if snap > 0 then             snapanglex = Angle(self.InputMouseX, 0, 0):SnapTo("p", snap).p             snapangley = Angle(self.InputMouseY, 0, 0):SnapTo("p", snap).p         end          RunConsoleCommand("_zs_rotateang", snapanglex, snapangley)         return true     end      if self:UseOverTheShoulder() and P_Team(MySelf) == TEAM_HUMAN then         self:InputMouseApplyOTS(cmd, x, y, ang)     end end  function GM:_GUIMousePressed(mc) end  function GM:TryHumanPickup(pl, entity) end  function GM:AddExtraOptions(list, window) end  function GM:SpawnMenuEnabled()     return false end  function GM:SpawnMenuOpen()     return false end  function GM:ContextMenuOpen()     return false end  function GM:_HUDWeaponPickedUp(wep)     if P_Team(MySelf) == TEAM_HUMAN and not wep.NoPickupNotification then         self:Rewarded(wep:GetClass())     end end  function GM:HUDItemPickedUp(itemname) end  function GM:HUDAmmoPickedUp(itemname, amount) end  function GM:InitPostEntity()     self:CreateLateVGUI()      self:AssignItemProperties()     self:FixWeaponBase()      self:LocalPlayerFound()      gamemode.Call("EvaluateFilmMode")      timer.Simple(2, function() GAMEMODE:GetFogData() end)      RunConsoleCommand("pp_bloom", "0") end  local fogstart = 0 local fogend = 0 local fogr = 0 local fogg = 0 local fogb = 0  function GM:SetupFog()     local power = self.DeathFog     local rpower = 1 - self.DeathFog      fogstart = self.FogStart * rpower     fogend = self.FogEnd * rpower + 150 * power     fogr = self.FogRed * rpower     fogg = self.FogGreen * rpower + 40 * power     fogb = self.FogBlue * rpower      local dimvision = MySelf.DimVision     if dimvision and dimvision:IsValid() then         power = math.max(0, dimvision:GetDim())          fogstart = Lerp(power, fogstart, 1)         fogend = Lerp(power, fogend, math.min(148 / math.max(0.01, MySelf.DimVisionEffMul), fogend))         fogr = Lerp(power, fogr, 0)         fogg = Lerp(power, fogg, 0)         fogb = Lerp(power, fogb, 0)     end end  function GM:_SetupWorldFog()     local dimvision = MySelf.DimVision     if self.DeathFog == 0 and not (dimvision and dimvision:IsValid()) then return end      self:SetupFog()      render_FogMode(1)      render_FogStart(fogstart)     render_FogEnd(fogend)     render_FogColor(fogr, fogg, fogb)     render_FogMaxDensity(1)      return true end  function GM:_SetupSkyboxFog(skyboxscale)     local dimvision = MySelf.DimVision     if self.DeathFog == 0 and not (dimvision and dimvision:IsValid()) then return end      self:SetupFog()      render_FogMode(1)      render_FogStart(fogstart * skyboxscale)     render_FogEnd(fogend * skyboxscale)     render_FogColor(fogr, fogg, fogb)     render_FogMaxDensity(1)      return true end  function GM:PreDrawSkyBox()     self.DrawingInSky = true end  local matSky = CreateMaterial("SkyOverride", "UnlitGeneric", {["$basetexture"] = "color/white", ["$vertexcolor"] = 1, ["$vertexalpha"] = 1, ["$model"] = 1}) local colSky = Color(0, 30, 0) function GM:PostDrawSkyBox()     self.DrawingInSky = false      local dimvision = MySelf.DimVision     dimvision = dimvision and dimvision:IsValid() and dimvision:GetDim()     if self.DeathFog > 0 or dimvision then         colSky.a = math.max(self.DeathFog, dimvision or 0) * 230         colSky.g = self.DeathFog * 30          cam_Start3D(EyePos(), EyeAngles())             render_SuppressEngineLighting(true)              render_SetMaterial(matSky)              render_DrawQuadEasy(Vector(0, 0, 10240), Vector(0, 0, -1), 20480, 20480, colSky, 0)             render_DrawQuadEasy(Vector(0, 10240, 0), Vector(0, -1, 0), 20480, 20480, colSky, 0)             render_DrawQuadEasy(Vector(0, -10240, 0), Vector(0, 1, 0), 20480, 20480, colSky, 0)             render_DrawQuadEasy(Vector(10240, 0, 0), Vector(-1, 0, 0), 20480, 20480, colSky, 0)             render_DrawQuadEasy(Vector(-10240, 0, 0), Vector(1, 0, 0), 20480, 20480, colSky, 0)              render_SuppressEngineLighting(false)         cam_End3D()     end end  function GM:GetFogData()     local _fogstart, _fogend = render_GetFogDistances()     local _fogr, _fogg, _fogb = render_GetFogColor()      self.FogStart = _fogstart     self.FogEnd = _fogend     self.FogRed = _fogr     self.FogGreen = _fogg     self.FogBlue = _fogb end  function GM:ShouldDraw3DWeaponHUD()     return GAMEMODE.WeaponHUDMode ~= 1 end  function GM:ShouldDraw2DWeaponHUD()     return GAMEMODE.WeaponHUDMode >= 1 or self:UseOverTheShoulder() end  local matAura = Material("models/debug/debugwhite") local skip = false local colHealthEmpty = GM.AuraColorEmpty local colHealthFull = GM.AuraColorFull  function GM.PostPlayerDrawMedical(pl)     if not GAMEMODE.DisableMedicalAura and not skip and P_Team(pl) == TEAM_HUMAN and pl ~= MySelf and (GAMEMODE.FriendOnlyHeal and GAMEMODE.ZSFriends[pl:SteamID()] or not GAMEMODE.FriendOnlyHeal) then         local eyepos = EyePos()         local dist = pl:GetPos():DistToSqr(eyepos)         if dist < MedicalAuraDistance then             local healthfrac = pl:Health() / pl:GetMaxHealth()              pl.SkipDrawHooks = true             skip = true              local med_r = math_Approach(colHealthEmpty.r, colHealthFull.r, math_abs(colHealthEmpty.r - colHealthFull.r) * healthfrac)             local med_g = math_Approach(colHealthEmpty.g, colHealthFull.g, math_abs(colHealthEmpty.g - colHealthFull.g) * healthfrac)             local med_b = math_Approach(colHealthEmpty.b, colHealthFull.b, math_abs(colHealthEmpty.b - colHealthFull.b) * healthfrac)              render_SuppressEngineLighting(true)             render_ModelMaterialOverride(matAura)             render_SetBlend((1 - dist / MedicalAuraDistance) * 0.1 * (1 + math.abs(math.sin((CurTime() + pl:EntIndex()) * 4)) * 0.05))             render_SetColorModulation(med_r/255, med_g/255, med_b/255)                 pl:DrawModel()             render_SetColorModulation(1, 1, 1)             render_SetBlend(1)             render_ModelMaterialOverride()             render_SuppressEngineLighting(false)              skip = false             pl.SkipDrawHooks = false         end     end end  function GM:OnReloaded()     self.BaseClass.OnReloaded(self)      timer.Simple(0, function() self:LocalPlayerFound() end) end      function GM:Think() end GM.HUDWeaponPickedUp = GM.Think GM.Think = GM._Think GM.HUDShouldDraw = GM.Think GM.CachedFearPower = GM.Think GM.CalcView = GM.Think GM.ShouldDrawLocalPlayer = GM.Think GM.PostDrawOpaqueRenderables = GM.Think GM.PostDrawTranslucentRenderables = GM.Think GM.HUDPaint = GM.Think GM.HUDPaintBackground = GM.Think GM.CreateMove = GM.Think GM.PrePlayerDraw = GM.Think GM.PostPlayerDraw = GM.Think GM.InputMouseApply = GM.Think GM.GUIMousePressed = GM.Think GM.HUDWeaponPickedUp = GM.Think function GM:LocalPlayerFound()     self.Think = self._Think     self.HUDShouldDraw = self._HUDShouldDraw     self.CachedFearPower = self._CachedFearPower     self.CalcView = self._CalcView     self.ShouldDrawLocalPlayer = self._ShouldDrawLocalPlayer     self.PostDrawTranslucentRenderables = self._PostDrawTranslucentRenderables     self.HUDPaint = self._HUDPaint     self.HUDPaintBackground = self._HUDPaintBackground     self.CreateMove = self._CreateMove     self.PrePlayerDraw = self._PrePlayerDraw     self.PostPlayerDraw = self._PostPlayerDraw     self.InputMouseApply = self._InputMouseApply     self.GUIMousePressed = self._GUIMousePressed     self.HUDWeaponPickedUp = self._HUDWeaponPickedUp     self.RenderScene = self._RenderScene     self.SetupSkyboxFog = self._SetupSkyboxFog     self.SetupWorldFog = self._SetupWorldFog      LocalPlayer().LegDamage = 0     LocalPlayer().ArmDamage = 0      if render.GetDXLevel() >= 80 then         self.RenderScreenspaceEffects = self._RenderScreenspaceEffects     end end  function GM:GetDynamicSpawning()     return not GetGlobalBool("DynamicSpawningDisabled", false) end  function GM:TrackLastDeath()     if MySelf:Alive() then         self.LastTimeAlive = CurTime()     else         self.LastTimeDead = CurTime()     end end  function GM:IsClassicMode()     return GetGlobalBool("classicmode", false) end  function GM:PostRender() end  local lastwarntim = -1   function GM:_Think()     local time = CurTime()      if self:GetEscapeStage() == ESCAPESTAGE_DEATH then         self.DeathFog = math.min(self.DeathFog + FrameTime() / 5, 1)     elseif self.DeathFog > 0 then         self.DeathFog = math.max(self.DeathFog - FrameTime() / 5, 0)     end      local health = MySelf:Health()     if self.PrevHealth and health < self.PrevHealth then         self.HurtEffect = math.min(self.HurtEffect + (self.PrevHealth - health) * 0.02, 1.5)     elseif self.HurtEffect > 0 then         self.HurtEffect = math.max(0, self.HurtEffect - FrameTime() * 0.65)     end     self.PrevHealth = health      local myteam = P_Team(MySelf)      self:TrackLastDeath()      local endtime = self:GetWaveActive() and self:GetWaveEnd() or self:GetWaveStart()     if endtime ~= -1 then         local timleft = math.max(0, endtime - time)         if timleft <= 10 and lastwarntim ~= math.ceil(timleft) then             lastwarntim = math.ceil(timleft)             if 0 < lastwarntim then                 LocalPlayer():EmitSound("buttons/lightswitch2.wav", 100, 110 - lastwarntim * 2)             end         end     end      self:PlayBeats(myteam, self:CachedFearPower())      local thirdperson     if myteam == TEAM_HUMAN then         local wep = MySelf:GetActiveWeapon()         if wep:IsValid() and wep.GetIronsights and wep:GetIronsights() then             self.FOVLerp = math.Approach(self.FOVLerp, wep.IsScoped and not self.DisableScopes and wep.IronsightsMultiplier or not wep.IsScoped and wep.IronsightsMultiplier or 0.6, FrameTime() * 5)             self.TransThird = true         elseif self.FOVLerp ~= 1 then             self.FOVLerp = math.Approach(self.FOVLerp, 1, FrameTime() * 5)             self.TransThird = false         end          if MySelf:GetBarricadeGhosting() then             MySelf:BarricadeGhostingThink()         end         thirdperson = self.OverTheShoulder     else         self.HeartBeatTime = self.HeartBeatTime + (6 + self:CachedFearPower() * 5) * FrameTime()         thirdperson = self.ZombieThirdPerson     end     self.TransparencyRadius = thirdperson and self.TransparencyRadius3p or self.TransparencyRadius1p      local frame_number = FrameNumber()     if MySelf then         MySelf.LastDrawFrame = frame_number     end      for _, pl in pairs(player.GetAll()) do         local pl_tb = E_GetTable(pl)          if pl_tb.LastDrawFrame and (frame_number - pl_tb.LastDrawFrame) < 5 then             if P_Team(pl) == TEAM_UNDEAD then                 tab = pl:GetZombieClassTable()                 if tab.BuildBonePositions then                     if not pl_tb.WasBuildingBonePositions then                         pl_tb.BuildingBones = pl:GetBoneCount() - 1                         pl_tb.WasBuildingBonePositions = true                     end                     pl:ResetBones()                     tab.BuildBonePositions(tab, pl)                 elseif pl_tb.WasBuildingBonePositions then                     pl_tb.WasBuildingBonePositions = nil                     pl:ResetBones()                      if pl_tb.ButcherCallback then                         pl:RemoveCallback("BuildBonePositions", pl_tb.ButcherCallback)                         pl_tb.ButcherCallback = false                     end                 end             elseif pl_tb.WasBuildingBonePositions then                 pl_tb.WasBuildingBonePositions = nil                 pl:ResetBones()                  if pl_tb.ButcherCallback then                     pl:RemoveCallback("BuildBonePositions", pl_tb.ButcherCallback)                     pl_tb.ButcherCallback = false                 end             end         end     end end  function GM:ShouldPlayBeats(teamid, fear)     return not self.RoundEnded and not self.ZombieEscape and not GetGlobalBool("beatsdisabled", false) end  local cv_ShouldPlayMusic = CreateClientConVar("zs_playmusic", 1, true, false) local cv_ShouldPlayMusicEscape = CreateClientConVar("zs_playescapedmusic", 1, true, false) local NextBeat = 0 local LastBeatLevel = 0 function GM:PlayBeats(teamid, fear)     if RealTime() <= NextBeat or not gamemode.Call("ShouldPlayBeats", teamid, fear) then return end            if LASTHUMAN and cv_ShouldPlayMusic:GetBool() then         local beats = self.BeatsEnabled and self.Beats[teamid == TEAM_HUMAN and self.BeatSetHuman or self.BeatSetZombie]         local last_human_sound = beats and beats.LastHuman or self.LastHumanSound          MySelf:EmitSound(last_human_sound, 0, 100, self.BeatsVolume)         NextBeat = RealTime() + SoundDuration(last_human_sound) - 0.025         return     end      if self:GetEscapeStage() > ESCAPESTAGE_NONE and cv_ShouldPlayMusicEscape:GetBool() then         MySelf:EmitSound(self.HumanEscapeSound, 0, 100, self.BeatsVolume)         NextBeat = RealTime() + self.SoundDuration[self.HumanEscapeSound] - 0.025         return     end      if fear <= 0 or not self.BeatsEnabled then return end      local beat_set = teamid == TEAM_HUMAN and self.BeatSetHuman or self.BeatSetZombie     local beats = self:GetWave() == 6 and self.BeatsWave6[beat_set] or self.Beats[beat_set]     if not beats then return end      LastBeatLevel = math.Approach(LastBeatLevel, math.ceil(fear * 10), 3)      local snd = beats[LastBeatLevel]     if snd then         MySelf:EmitSound(snd, 0, 100, self.BeatsVolume)         NextBeat = RealTime() + (self.SoundDuration[snd] or SoundDuration(snd)) - 0.025     end end  function GM:RequestedDefaultCart()     local defaultcart = GetConVar("zs_defaultcart"):GetString()     if #defaultcart > 0 then         defaultcart = string.lower(defaultcart)          for i, carttab in ipairs(self.SavedCarts) do             if carttab[1] and string.lower(carttab[1]) == defaultcart then                 gamemode.Call("SuppressArsenalUpgrades", 1)                 RunConsoleCommand("worthcheckout", unpack(carttab[2]))                  return             end         end          RunConsoleCommand("worthrandom")     end end  function GM:RestartRound()     self.TheLastHuman = nil     self.RoundEnded = nil     LASTHUMAN = nil      if pEndBoard and pEndBoard:IsValid() then         pEndBoard:Remove()         pEndBoard = nil     end      self:ClearItemStocks()      self:InitPostEntity()      self:RevertZombieClasses() end  function GM:_HUDShouldDraw(name)     if self.FilmMode and name ~= "CHudWeaponSelection" then return false end      return name ~= "CHudHealth" and name ~= "CHudBattery"     and name ~= "CHudAmmo" and name ~= "CHudSecondaryAmmo"     and name ~= "CHudDamageIndicator" end  local Current = 0 local NextCalculate = 0 local FEAR_PERINSTANCE = 0.075 function GM:_CachedFearPower()     if CurTime() >= NextCalculate then         NextCalculate = CurTime() + 0.15          local max_fear_power = FEAR_PERINSTANCE * math.min( math.max( #team.GetPlayers(TEAM_ZOMBIE), 10 ), 40 )         local fear_power, raw_fear_power = self:GetFearMeterPower(EyePos(), TEAM_UNDEAD, MySelf)          Current = math.min( raw_fear_power / max_fear_power, 1 )     end      return Current end  function surface.CreateLegacyFont(font, size, weight, antialias, additive, name, shadow, outline, blursize)     surface.CreateFont(name, {font = font, size = size, weight = weight, antialias = antialias, additive = additive, shadow = shadow, outline = outline, blursize = blursize}) end  local fontfamily = "Remington Noiseless" local fontfamilysm = "Remington Noiseless" local fontfamily3d = "hidden" local fontsizeadd = -1 local fontweight = 0 local fontsizeadd3D = 0 local fontweight3D = 0  function GM:Create3DFonts()      surface.CreateLegacyFont(fontfamily3d, 28 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DFontSmaller", false, true)     surface.CreateLegacyFont(fontfamily3d, 48 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DFontSmall", false, true)     surface.CreateLegacyFont(fontfamily3d, 72 + fontsizeadd3D, fontweight3D, false, false, "ZS3D2DFont", false, true)     surface.CreateLegacyFont(fontfamily3d, 128 + fontsizeadd3D, fontweight3D, false, false, "ZS3D2DFontBig", false, true)     surface.CreateLegacyFont(fontfamily3d, 28 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DFontSmallerBlur", false, false, 16)     surface.CreateLegacyFont(fontfamily3d, 48 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DFontSmallBlur", false, false, 16)     surface.CreateLegacyFont(fontfamily3d, 72 + fontsizeadd3D, fontweight3D, false, false, "ZS3D2DFontBlur", false, false, 16)     surface.CreateLegacyFont(fontfamily3d, 128 + fontsizeadd3D, fontweight3D, false, false, "ZS3D2DFontBigBlur", false, false, 16)     surface.CreateLegacyFont(fontfamily, 40 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DFont2Smaller", false, true)     surface.CreateLegacyFont(fontfamily, 48 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DFont2Small", false, true)     surface.CreateLegacyFont(fontfamily, 72 + fontsizeadd3D, fontweight3D, false, false, "ZS3D2DFont2", false, true)     surface.CreateLegacyFont(fontfamily, 128 + fontsizeadd3D, fontweight3D, false, false, "ZS3D2DFont2Big", false, true)     surface.CreateLegacyFont(fontfamily, 40 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DFont2SmallerBlur", false, false, 16)     surface.CreateLegacyFont(fontfamily, 48 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DFont2SmallBlur", false, false, 16)     surface.CreateLegacyFont(fontfamily, 72 + fontsizeadd3D, fontweight3D, false, false, "ZS3D2DFont2Blur", false, false, 16)     surface.CreateLegacyFont(fontfamily, 128 + fontsizeadd3D, fontweight3D, false, false, "ZS3D2DFont2BigBlur", false, false, 16)      surface.CreateLegacyFont(fontfamilysm, 14 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DUnstyleTiny", false, true)     surface.CreateLegacyFont(fontfamilysm, 24 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DUnstyleSmallest", false, true)     surface.CreateLegacyFont(fontfamilysm, 36 + fontsizeadd3D, fontweight3D, false, false,  "ZS3D2DUnstyleSmaller", false, true) end  function GM:CreateNonScaleFonts()     surface.CreateLegacyFont("tahoma", 96, 1000, true, false, "zshintfont", false, true)            surface.CreateFont("DefaultFontVerySmall", {font = "tahoma", size = 10, weight = 0, antialias = false})     surface.CreateFont("DefaultFontSmall", {font = "tahoma", size = 11, weight = 0, antialias = false})     surface.CreateFont("DefaultFontSmallDropShadow", {font = "tahoma", size = 11, weight = 0, shadow = true, antialias = false})     surface.CreateFont("DefaultFont", {font = "tahoma", size = 13, weight = 500, antialias = false})     surface.CreateFont("DefaultFontAA", {font = "tahoma", size = 13, weight = 500, antialias = true})     surface.CreateFont("DefaultFontBold", {font = "tahoma", size = 13, weight = 1000, antialias = false})     surface.CreateFont("DefaultFontLarge", {font = "tahoma", size = 16, weight = 0, antialias = false})     surface.CreateFont("DefaultFontLargeAA", {font = "tahoma", size = 16, weight = 0, antialias = true})     surface.CreateFont("DefaultFontLargest", {font = "tahoma", size = 22, weight = 0, antialias = false})     surface.CreateFont("DefaultFontLargestAA", {font = "tahoma", size = 22, weight = 0, antialias = true}) end  function GM:CreateScalingFonts()     local fontaa = true     local fontshadow = false     local fontoutline = true      local screenscale = BetterScreenScale()      surface.CreateLegacyFont("csd", screenscale * 42, 100, true, false, "zsdeathnoticecs", false, false)     surface.CreateLegacyFont("HL2MP", screenscale * 42, 100, true, false, "zsdeathnotice", false, false)      surface.CreateLegacyFont("csd", screenscale * 96, 100, true, false, "zsdeathnoticecsws", false, false)     surface.CreateLegacyFont("HL2MP", screenscale * 96, 100, true, false, "zsdeathnoticews", false, false)      surface.CreateLegacyFont("csd", screenscale * 72, 100, true, false, "zsdeathnoticecspa", false, false)     surface.CreateLegacyFont("HL2MP", screenscale * 72, 100, true, false, "zsdeathnoticepa", false, false)      surface.CreateLegacyFont(fontfamily, screenscale * (16 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontTiny", fontshadow, fontoutline)     surface.CreateLegacyFont(fontfamily, screenscale * (20 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontSmallest", fontshadow, fontoutline)     surface.CreateLegacyFont(fontfamily, screenscale * (22 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontSmaller", fontshadow, fontoutline)     surface.CreateLegacyFont(fontfamily, screenscale * (28 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontSmall", fontshadow, fontoutline)     surface.CreateLegacyFont(fontfamily, screenscale * (42 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFont", fontshadow, fontoutline)     surface.CreateLegacyFont(fontfamily, screenscale * (72 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontBig", fontshadow, fontoutline)     surface.CreateLegacyFont(fontfamily, screenscale * (16 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontTinyBlur", false, false, 8)     surface.CreateLegacyFont(fontfamily, screenscale * (22 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontSmallerBlur", false, false, 8)     surface.CreateLegacyFont(fontfamily, screenscale * (28 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontSmallBlur", false, false, 8)     surface.CreateLegacyFont(fontfamily, screenscale * (42 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontBlur", false, false, 8)     surface.CreateLegacyFont(fontfamily, screenscale * (72 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontBigBlur", false, false, 8)      surface.CreateLegacyFont(fontfamily, screenscale * (20 + fontsizeadd/2), 0, fontaa, false, "ZSAmmoName", false, false)      local liscreenscale = math.max(0.95, BetterScreenScale())      surface.CreateLegacyFont(fontfamily, liscreenscale * (32 + fontsizeadd), fontweight, true, false, "ZSScoreBoardTitle", false, true)     surface.CreateLegacyFont(fontfamily, liscreenscale * (22 + fontsizeadd), fontweight, true, false, "ZSScoreBoardSubTitle", false, true)     surface.CreateLegacyFont(fontfamily, liscreenscale * (16 + fontsizeadd), fontweight, true, false, "ZSScoreBoardPlayer", false, true)     surface.CreateLegacyFont(fontfamily, liscreenscale * (24 + fontsizeadd), fontweight, true, false, "ZSScoreBoardHeading", false, false)     surface.CreateLegacyFont("arial", 18 * liscreenscale, 0, true, false, "ZSScoreBoardPlayerSmall", false, true)     surface.CreateLegacyFont("arial", 15 * liscreenscale, 0, true, false, "ZSScoreBoardPlayerSmaller", false, true)     surface.CreateLegacyFont("tahoma", 11 * liscreenscale, 0, true, false, "ZSScoreBoardPing")      surface.CreateLegacyFont(fontfamily, screenscale * (16 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontTinyNS", false, false)     surface.CreateLegacyFont(fontfamily, screenscale * (20 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontSmallestNS", false, false)     surface.CreateLegacyFont(fontfamily, screenscale * (22 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontSmallerNS", false, false)     surface.CreateLegacyFont(fontfamily, screenscale * (28 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontSmallNS", false, false)     surface.CreateLegacyFont(fontfamily, screenscale * (42 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontNS", false, false)     surface.CreateLegacyFont(fontfamily, screenscale * (72 + fontsizeadd), fontweight, fontaa, false, "ZSHUDFontBigNS", false, false)      surface.CreateLegacyFont(fontfamilysm, screenscale * 13, fontweight, fontaa, false, "ZSBodyTextFontSmall", fontshadow)      surface.CreateLegacyFont(fontfamilysm, screenscale * 15, fontweight, fontaa, false, "ZSBodyTextFont", fontshadow, fontoutline)     surface.CreateLegacyFont(fontfamilysm, screenscale * 20, fontweight, fontaa, false, "ZSBodyTextFontBig", fontshadow, fontoutline)      surface.CreateLegacyFont(fontfamily, screenscale * (20 + fontsizeadd), 0, true, false, "ZSDamageResistance", false, true)     surface.CreateLegacyFont(fontfamily, screenscale * (20 + fontsizeadd), 0, true, false, "ZSDamageResistanceBlur", false, true)      surface.CreateFont("ZSXPBar", {font = "tahoma", size = screenscale * 14, weight = 500, antialias = false, shadow = true}) end  function GM:CreateFonts()     fontfamily =         self.ZSFont == 2 and "Typenoksidi" or         self.ZSFont == 1 and "Ghoulish Fright AOE" or         "Remington Noiseless"     fontsizeadd =         self.ZSFont == 2 and 0 or         self.ZSFont == 1 and 8 or         -1      self:Create3DFonts()     self:CreateNonScaleFonts()     self:CreateScalingFonts() end  function GM:Initialize()     self:FixSkillConnections()     self:CreateFonts()     self:PrecacheResources()     self:CreateVGUI()     self:InitializeBeats()     self:AddCustomAmmo()     self:CreateWeaponQualities()     self:CreateSpriteMaterials()     self:DeriveIndex()            RunConsoleCommand("r_drawmodeldecals", "0")           RunConsoleCommand("r_dynamic", "0")      self:RefreshMapIsObjective() end    function GM:CreateSpriteMaterials()     local params = {["$translucent"] = "1", ["$vertexcolor"] = "1", ["$vertexalpha"] = "1"}     for i=1, 8 do         params["$basetexture"] = "Decals/blood"..i         CreateMaterial("sprite_bloodspray"..i, "UnlitGeneric", params)     end      game.AddDecal("Decal.Gunk", "zombiesurvival/decal_gunk") end  function GM:ShutDown()     RunConsoleCommand("r_drawmodeldecals", "1")     RunConsoleCommand("r_dynamic", "1") end  local function FirstOfGoodType(a)     local ext      for _, v in pairs(a) do         ext = string.sub(v, -4)         if ext == ".wav" then             return v         end     end      for _, v in pairs(a) do         ext = string.sub(v, -4)         if ext == ".ogg" or ext == ".mp3" then             return v         end     end end  function GM:InitializeBeats()     local _, dirs = file.Find("sound/zombiesurvival/beats/*", "GAME")     for _, dirname in pairs(dirs) do         if dirname == "none" or dirname == "default" then continue end          self.Beats[dirname] = {}         local highestexist         for i=1, 10 do             local a, __ = file.Find("sound/zombiesurvival/beats/"..dirname.."/"..i..".*", "GAME")             local a1 = FirstOfGoodType(a)             if a1 then                 local filename = "zombiesurvival/beats/"..dirname.."/"..a1                 if file.Exists("sound/"..filename, "GAME") then                     self.Beats[dirname][i] = Sound(filename)                     highestexist = filename                      continue                 end             end              if highestexist then                 self.Beats[dirname][i] = highestexist             end         end          for i=1, 10 do             local a, __ = file.Find("sound/zombiesurvival/beats/"..dirname.."/w6_"..i..".*", "GAME")             local a1 = FirstOfGoodType(a)             if a1 then                 local filename = "zombiesurvival/beats/"..dirname.."/"..a1                 if file.Exists("sound/"..filename, "GAME") then                     if not self.BeatsWave6[dirname] then                         self.BeatsWave6[dirname] = {}                     end                      self.BeatsWave6[dirname][i] = Sound(filename)                     highestexist = filename                      continue                 end             end              if highestexist and self.BeatsWave6[dirname] then                 self.BeatsWave6[dirname][i] = highestexist             end         end          local a, __ = file.Find("sound/zombiesurvival/beats/"..dirname.."/last_human.*", "GAME")         local a1 = FirstOfGoodType(a)          if a1 then             local filename = "zombiesurvival/beats/"..dirname.."/"..a1             if file.Exists("sound/"..filename, "GAME") then                 self.Beats[dirname].LastHuman = Sound(filename)             end         end     end end  function GM:PlayerDeath(pl, attacker) end  function GM:ScalePlayerDamage(pl, hitgroup, dmginfo) end  function GM:LastHuman(pl)     if not IsValid(pl) then pl = nil end      self.TheLastHuman = pl      if not LASTHUMAN then         LASTHUMAN = true         timer.Simple(0.5, function() GAMEMODE:LastHumanMessage() end)     end end  function GM:LastHumanMessage()     if self.RoundEnded or not MySelf:IsValid() then return end      local icon = self.PantsMode and "weapon_zs_legs" or "default"     if P_Team(MySelf) == TEAM_UNDEAD or not MySelf:Alive() then         self:CenterNotify({killicon = icon}, {font = "ZSHUDFont"}, " ", COLOR_RED, translate.Get(self.PantsMode and "kick_the_last_human" or "kill_the_last_human"), {killicon = icon})     else         self:CenterNotify({font = "ZSHUDFont"}, " ", COLOR_RED, translate.Get("you_are_the_last_human"))         self:CenterNotify({killicon = icon}, " ", COLOR_RED, translate.Format(self.PantsMode and "x_pants_out_to_get_you" or "x_zombies_out_to_get_you", team.NumPlayers(TEAM_UNDEAD)), {killicon = icon})     end end  function GM:PlayerShouldTakeDamage(pl, attacker)     return pl == attacker or not attacker:IsPlayer() or P_Team(pl) ~= P_Team(attacker) or pl.AllowTeamDamage or attacker.AllowTeamDamage end  function GM:SetWave(wave)     SetGlobalInt("wave", wave) end  local matRing = Material("effects/select_ring") function GM:DrawCircle(x, y, radius, color)     surface.SetMaterial(matRing)     surface.SetDrawColor(color)     surface.DrawTexturedRect(x - radius, y - radius, radius * 2, radius * 2) end  function GM:_HUDPaintBackground()     local wep = MySelf:GetActiveWeapon()     if wep:IsValid() and wep.DrawHUDBackground then         wep:DrawHUDBackground()     end end  local function AltSelItemUpd()     local activeweapon = MySelf:GetActiveWeapon()     if not activeweapon or not activeweapon:IsValid() then return end      local actwclass = activeweapon:GetClass()     local label = GAMEMODE.InventoryMenu.SelectedItemLabel      label:SetText(weapons.Get(actwclass).PrintName)     label:SizeToContents()     label:CenterHorizontal()      local dismantle = GAMEMODE.InventoryMenu.DismantleButton     if activeweapon.NoDismantle or not (activeweapon.AllowQualityWeapons or activeweapon.PermitDismantle) then         dismantle:SetText("Cannot Dismantle")         return     end      local distext = string.format("Dismantle for %d scrap", GAMEMODE:GetDismantleScrap(activeweapon, GAMEMODE.InventoryMenu.SelInv, MySelf))     dismantle:SetText(distext) end  function GM:DoAltSelectedItemUpdate()     local sel_inv = self.InventoryMenu.SelInv     if sel_inv then         local label = self.InventoryMenu.SelectedItemLabel         local tbl_data = self:GetItemAssociatedSkill(sel_inv, MySelf:GetTrinketItemLevel(sel_inv) or 0)         local item_data = tbl_data.ItemData          local skill = tbl_data.Skill          local txt = skill and skill.Name or item_data.PrintName          label:SetText(txt)         label:SizeToContents()         label:CenterHorizontal()          local dismantle = GAMEMODE.InventoryMenu.DismantleButton         local distext = string.format("Dismantle for %d scrap", self:GetDismantleScrap(item_data, sel_inv, MySelf))          dismantle:SetText(distext)     else         timer.Simple(0.25, AltSelItemUpd)     end end  function GM:HumanMenu()     if self.ZombieEscape then return end      local ent = MySelf:MeleeTrace(48, 2, nil, nil, true).Entity     if self:ValidMenuLockOnTarget(MySelf, ent) then         self.HumanMenuLockOn = ent     else         self.HumanMenuLockOn = nil     end      self:OpenInventory()      if self.InventoryMenu and self.InventoryMenu:IsValid() then         self:DoAltSelectedItemUpdate()         return     end end  function GM:ZombieSpawnMenu()     if self.ZombieEscape then return end      if self.ZSpawnMenu and self.ZSpawnMenu:IsValid() then         self.ZSpawnMenu:SetVisible(true)         self.ZSpawnMenu:OpenMenu()         self.ZSpawnMenu:RefreshContents()          self.DemiBar:SetVisible(true)         return     end      local zombie_menu = vgui.Create("DZombieSpawnMenu")     self.ZSpawnMenu = zombie_menu      if not self.DemiBar then         local demi_bar = vgui.Create("DProgressBar")         self.DemiBar = demi_bar     end      zombie_menu:OpenMenu() end  function GM:PlayerBindPress(pl, bind, wasin)     if bind == "gmod_undo" or bind == "undo" then         RunConsoleCommand("+zoom")         timer.Create("ReleaseZoom", 1, 1, function() RunConsoleCommand("-zoom") end)     elseif bind == "+menu_context" then         if P_Team(pl) == TEAM_UNDEAD then             self.ZombieThirdPerson = not self.ZombieThirdPerson         elseif P_Team(pl) == TEAM_HUMAN then             self:ToggleOTSCamera()         end     elseif bind == "+menu" and P_Team(pl) == TEAM_HUMAN then         RunConsoleCommand("zs_firemode")     elseif P_Team(pl) == TEAM_UNDEAD and string.find(bind, "impulse 100") then         gamemode.Call("ToggleZombieVision")     end end  function GM:_ShouldDrawLocalPlayer(pl)     return P_Team(pl) == TEAM_UNDEAD and (self.ZombieThirdPerson or pl:CallZombieFunction0("ShouldDrawLocalPlayer"))     or P_Team(pl) == TEAM_HUMAN and self:UseOverTheShoulder()     or pl:IsPlayingTaunt()     or pl.Revive and pl.Revive:IsValid()     or pl.KnockedDown and pl.KnockedDown:IsValid() end  local roll = 0 function GM:_CalcView(pl, origin, angles, fov, znear, zfar)     if pl.Confusion and pl.Confusion:IsValid() then         pl.Confusion:CalcView(pl, origin, angles, fov, znear, zfar)     end      if pl.Revive and pl.Revive:IsValid() and pl.Revive.GetRagdollEyes then         if self.ThirdPersonKnockdown or self.ZombieThirdPerson then             origin = pl:GetThirdPersonCameraPos(origin, angles)         else             local rpos, rang = pl.Revive:GetRagdollEyes(pl)             if rpos then                 origin = rpos                 angles = rang             end         end     elseif pl.KnockedDown and pl.KnockedDown:IsValid() then         if self.ThirdPersonKnockdown or self:UseOverTheShoulder() then             origin = pl:GetThirdPersonCameraPos(origin, angles)         else             local rpos, rang = self:GetRagdollEyes(pl)             if rpos then                 origin = rpos                 angles = rang             end         end     elseif pl:ShouldDrawLocalPlayer() and pl:OldAlive() and not pl:HasWon() then         if P_Team(pl) == TEAM_UNDEAD then             origin = pl:GetThirdPersonCameraPos(origin, angles)         elseif self:UseOverTheShoulder() then             self:CalcViewOTS(pl, origin, angles, fov, znear, zfar)         end     end      local targetroll = 0      if pl:WaterLevel() >= 3 then         targetroll = targetroll + math.sin(CurTime()) * 7     end      roll = math.Approach(roll, targetroll, math.max(0.25, math.sqrt(math.abs(roll))) * 30 * FrameTime())     angles.roll = angles.roll + roll      if pl:IsPlayingTaunt() then         self:CalcViewTaunt(pl, origin, angles, fov, znear, zfar)     end      local target = pl:GetObserverTarget()     if target and target:IsValid() then         local lasttarget = self.LastObserverTarget         if lasttarget and lasttarget:IsValid() and target ~= lasttarget then             if self.LastObserverTargetLerp then                 if CurTime() >= self.LastObserverTargetLerp then                     self.LastObserverTarget = nil                     self.LastObserverTargetLerp = nil                 else                     local delta = math.Clamp((self.LastObserverTargetLerp - CurTime()) / 0.3333, 0, 1) ^ 0.5                     origin:Set(self.LastObserverTargetPos * delta + origin * (1 - delta))                 end             else                 self.LastObserverTargetLerp = CurTime() + 0.3333             end         else             self.LastObserverTarget = target             self.LastObserverTargetPos = origin         end     end      if pl:GetObserverMode() ~= OBS_MODE_NONE then         angles.roll = 0       end      pl:CallZombieFunction2("CalcView", origin, angles)      return self.BaseClass.CalcView(self, pl, origin, angles, fov, znear, zfar) end  function GM:ResetViewRoll()     roll = 0 end  function GM:CalcViewTaunt(pl, origin, angles, fov, znear, zfar)     local tr = util.TraceHull({start = origin, endpos = origin - angles:Forward() * 72, mins = Vector(-2, -2, -2), maxs = Vector(2, 2, 2), mask = MASK_OPAQUE, filter = pl})     origin:Set(tr.HitPos + tr.HitNormal * 2) end  function GM:CreateMoveTaunt(cmd)     cmd:ClearButtons(0)     cmd:ClearMovement() end  function GM:PostProcessPermitted(str)     return false end  function GM:HUDPaintEndRound() end  function GM:PreDrawViewModel(vm, pl, wep)     if pl and pl:IsValid() and (pl:IsHolding() or GAMEMODE.HideViewModels) then return true end      if wep and wep:IsValid() and wep.PreDrawViewModel then         return wep:PreDrawViewModel(vm)     end end  function GM:PostDrawViewModel(vm, pl, wep)     if wep and wep:IsValid() then         if wep.UseHands or not wep:IsScripted() then             local hands = pl:GetHands()             if hands and hands:IsValid() then                 hands:DrawModel()             end              if wep.DualHands then  local hands_dual = pl:GetSecondaryHands()  if hands_dual and hands_dual:IsValid() then  if wep.ViewModelFlipLeft then   render.CullMode( MATERIAL_CULLMODE_CW )  end   hands_dual:DrawModel()  render.CullMode( MATERIAL_CULLMODE_CCW )  end  end         end          if wep.PostDrawViewModel then             wep:PostDrawViewModel(vm)         end     end end  local undo = false local matWhite = Material("models/debug/debugwhite") local lowhealthcolor = GM.AuraColorEmpty local fullhealthcolor = GM.AuraColorFull  function GM:_PrePlayerDraw(pl)     local shadowman = false      if pl ~= MySelf and pl:IsEffectActive(EF_DIMLIGHT) then         pl:RemoveEffects(EF_DIMLIGHT)     end      local myteam = P_Team(MySelf)     local theirteam = P_Team(pl)      local radius = self.TransparencyRadius     local opaque = true      local affect_myself = not self.TransThird and pl ~= MySelf or self.TransThird      local pl_tb = E_GetTable(pl)      pl_tb.NotRendering = false      local lockon = self.HumanMenuLockOn     if lockon and lockon == pl then         render_SetBlend(0.1)         render_ModelMaterialOverride(matWhite)         render_SuppressEngineLighting(true)         render_SetColorModulation(0.2, 0.5, 0.8)          undo = true         return     end      local medic_skip = myteam == theirteam and (GAMEMODE.DisableMedicalAura or not self.MedicalAura or self.MedicalAura and pl:Health() == pl:GetMaxHealth())     if radius > 0 and myteam == theirteam and affect_myself and not (GAMEMODE.AlwaysDrawFriend and pl:IsFriend()) and medic_skip then         local dist = pl:GetPos():DistToSqr(EyePos())         if dist < radius then             local blend = (dist / radius) ^ 1.4             if pl ~= MySelf then                 if blend <= 0.1 then blend = 0 end             else                 blend = 0.2             end              if pl_tb.Transparency ~= blend then                 hook.Run("PlayerAlphaChanged", pl, blend)             end             pl_tb.Transparency = blend             opaque = false              if blend == 0 and not pl_tb.IsGuardianMode then                 pl_tb.ShadowMan = true                 pl_tb.NotRendering = true                 return true             end              render_SetBlend(blend)             if myteam == TEAM_HUMAN and blend < 0.5 then                 render_ModelMaterialOverride(matWhite)                 render_SetColorModulation(0.2, 0.2, 0.2)                 shadowman = true             end             undo = true         end     end      pl_tb.ShadowMan = shadowman      if pl:CallZombieFunction0("PrePlayerDraw") then return true end      if pl_tb.SpawnProtection and (not (pl_tb.status_overridemodel and pl_tb.status_overridemodel:IsValid()) or pl:GetZombieClassTable().NoHideMainModel) then         undo = true         render_ModelMaterialOverride(matWhite)         render_SetBlend(0.02 + (CurTime() + pl:EntIndex() * 0.2) % 0.05)         render_SetColorModulation(0, 0.3, 0)         render_SuppressEngineLighting(true)         if not pl_tb.Transparency then             hook.Run("PlayerAlphaChanged", pl, 0)         end         pl_tb.Transparency = 0         opaque = false     end      if self.m_ZombieVision and myteam == TEAM_UNDEAD and theirteam == TEAM_HUMAN then         local dist = pl:GetPos():DistToSqr(EyePos())         local range, inverted = pl:GetAuraRangeSqr()          local condition =  inverted   and dist >= range or                             not inverted and dist <= range         if condition and dist <= 4194304 then             undo = true             local healthfrac = pl:GetDTBool(DT_PLAYER_BOOL_NECRO) and 0 or (pl:Health() / pl:GetMaxHealth())              render_SetBlend(1)             render_ModelMaterialOverride(matWhite)             render_SetColorModulation(                 Lerp(healthfrac, lowhealthcolor.r, fullhealthcolor.r) / 255,                 Lerp(healthfrac, lowhealthcolor.g, fullhealthcolor.g) / 255,                 Lerp(healthfrac, lowhealthcolor.b, fullhealthcolor.b) / 255             )             render_SuppressEngineLighting(true)             cam_IgnoreZ(true)         end     end      if opaque and pl_tb.Transparency then         pl_tb.Transparency = nil         hook.Run("PlayerAlphaChanged", pl, 1)     end end  local last_draw_context = {} local default_class local zombie_classes = {} if GAMEMODE then     zombie_classes = GAMEMODE.ZombieClasses     default_class = GAMEMODE.DefaultZombieClass end hook.Add("Initialize", "LocalizeZombieClassesRender", function()     zombie_classes = GAMEMODE.ZombieClasses     default_class = GAMEMODE.DefaultZombieClass end) function PlayerRenderOverride(self)           if  WEAPON_WORLD_CONTEXT or         last_draw_context[self] and DRAW_CONTEXT_COUNTER == last_draw_context[self] then             return     end      local e_tb = E_GetTable(self)     local status_over = e_tb.status_overridemodel     if status_over and status_over:IsValid() then         local zombie_class = zombie_classes[e_tb.Class or default_class]         if not (zombie_class and zombie_class.NoHideMainModel) then return end     end      last_draw_context[self] = DRAW_CONTEXT_COUNTER     self:DrawModel() end  hook.Add( "OnEntityCreated", "PlayerRenderOverride", function(ent)     if ent:IsPlayer() then         ent.RenderOverride = PlayerRenderOverride     end end)  DRAW_CONTEXT_COUNTER = DRAW_CONTEXT_COUNTER or 0  hook.Add("PreDrawOpaqueRenderables", "draw_context_start", function(depth, sky)     DRAW_CONTEXT_COUNTER = DRAW_CONTEXT_COUNTER + 1 end)  function GM:CreateClientsideRagdoll(pl, ragdoll)     if pl:IsValidZombie() then         ragdoll.StartFadeTime = CurTime()         ragdoll.EndFadeTime = GAMEMODE.RagdollFadeTime         local nearby = 0         if GAMEMODE.RagdollFade and GAMEMODE.RagdollFadeMin > 0 then             for _, ent in pairs(ents.FindInSphere(pl:GetPos(), GAMEMODE.RagdollFadeDist)) do                 if ent ~= pl and ent:IsPlayer() and ent:Alive() and ent:Team() == TEAM_UNDEAD then                     nearby = nearby + 1                 end             end         end         ragdoll.FadeNearby = nearby         ragdoll.RenderOverride = function(rag)             if not pl:IsValidZombie() then return end              local lifetime = CurTime() - rag.StartFadeTime             local delta = math_max(0, 1 - (lifetime / rag.EndFadeTime))              local class_tbl = pl:GetZombieClassTable()              local minnearby = rag.FadeNearby >= GAMEMODE.RagdollFadeMin             local isboss = pl:GetBossTier() > 0             local dofade = GAMEMODE.RagdollFade and ((minnearby and (isboss and GAMEMODE.RagdollFadeBosses or not isboss)) or (class_tbl.IsHeadcrab and GAMEMODE.RagdollFadeHeadcrabs))              if not class_tbl.RagdollUseOverrideFunc and (not class_tbl.OverrideModel or class_tbl.NoHideMainModel or pl.status_overridemodel and pl.status_overridemodel:IsValid()) then                 if pl:CallZombieFunction0("PrePlayerDraw") then return true end                 if dofade then render_SetBlend(delta) end                 rag:DrawModel()                 pl:CallZombieFunction0("PostPlayerDraw")                 if dofade then render_SetBlend(1) end             else                 if pl:CallZombieFunction0("PrePlayerDrawOverrideModel") then return true end                 if dofade then render_SetBlend(delta) end                 rag:DrawModel()                 pl:CallZombieFunction0("PostPlayerDrawOverrideModel")                 if dofade then render_SetBlend(1) end             end         end     end end  local matFriendRing = Material("SGM/playercircle") local matTargetTri = Material("gui/point.png") function GM:_PostPlayerDraw(pl)     local pl_tb = E_GetTable(pl)      pl_tb.LastDrawFrame = FrameNumber()     pl:CallZombieFunction0("PostPlayerDraw")      if undo then         render_SetBlend(1)         render_ModelMaterialOverride()         render_SetColorModulation(1, 1, 1)         render_SuppressEngineLighting(false)         cam_IgnoreZ(false)          undo = false     end      local eyepos, ang, tpos, distance, hpf      local cond1 =   MySelf.AimAssistRange and                     MySelf.AimAssistRange > 0 and                     self.TraceTargetTeam == pl and                     pl:IsValidLivingZombie() and                     not pl:GetZombieClassTable().IgnoreTargetAssist     local cond2 = GAMEMODE.MedicalAura and not self.DisableMedicalAura and GAMEMODE.CachedSmartTargetting == pl      if cond1 or cond2 then         tpos = pl:GetPos()         tpos.z = tpos.z + 80          eyepos = MySelf:EyePos()         distance = eyepos:DistToSqr(tpos)          ang = (eyepos - tpos):Angle()         ang:RotateAroundAxis(ang:Right(), 270)         ang:RotateAroundAxis(ang:Up(), 90)          cam_IgnoreZ(true)         cam_Start3D2D(tpos, ang, math.max(750, math.sqrt(distance)) / 6500)             surface_SetMaterial(matTargetTri)              hpf = pl:Health() / pl:GetMaxHealthEx()              surface_SetDrawColor(255 - (255 * hpf), 255 * hpf, 0, 230)             surface_DrawTexturedRect(-96, -96, 96, 96)         cam_End3D2D()         cam_IgnoreZ(false)     end      if pl ~= MySelf and P_Team(MySelf) == P_Team(pl) and (pl_tb.IsGuardianMode or pl:IsFriend()) then         if pl.IsGuardianMode and pl:GetActiveWeapon() ~= pl.IsGuardianWep then             pl.IsGuardianMode = false         end          local pos = pl:GetPos()         pos.z = pos.z + 2         render_SetMaterial(matFriendRing)          friendcol = Color(0, 200, 200, 60)         if not pl_tb.IsGuardianMode and pl:IsFriend() then             hpf = pl:Health() / pl:GetMaxHealthEx()              friendcol = Color(255 - (255 * hpf), 255 * hpf, 0, 60)         end          render_DrawQuadEasy(pos, vector_up, 32, 32, friendcol)         render_DrawQuadEasy(pos, vector_down, 32, 32, friendcol)     end end  function GM:HUDPaintBackgroundEndRound()     local x, y = ScrW() / 2, ScrH() * 0.8     local timleft = math.max(0, self.EndTime + self.EndGameTime - CurTime())      if timleft <= 0 then         draw_SimpleTextBlur(translate.Get("loading"), "ZSHUDFont", x, y, COLOR_WHITE, TEXT_ALIGN_CENTER)     else         draw_SimpleTextBlur(translate.Format("next_round_in_x", util.ToMinutesSecondsCD(timleft)), "ZSHUDFontSmall", x, y, COLOR_WHITE, TEXT_ALIGN_CENTER)     end end  local function EndRoundCalcView(pl, origin, angles, fov, znear, zfar)     if GAMEMODE.EndTime and CurTime() < GAMEMODE.EndTime + 5 then         local endposition = GAMEMODE.LastHumanPosition         local override = GetGlobalVector("endcamerapos", vector_origin)         if override ~= vector_origin then             endposition = override         end         if endposition then             local delta = math.Clamp((CurTime() - GAMEMODE.EndTime) * 2, 0, 1)              local start = endposition * delta + origin * (1 - delta)             local tr = util.TraceHull({start = start, endpos = start + delta * 64 * Angle(0, CurTime() * 30, 0):Forward(), mins = Vector(-2, -2, -2), maxs = Vector(2, 2, 2), filter = player.GetAll(), mask = MASK_SOLID})             return {origin = tr.HitPos + tr.HitNormal, angles = (start - tr.HitPos):Angle()}         end          return     end      hook.Remove("CalcView", "EndRoundCalcView") end  local function EndRoundShouldDrawLocalPlayer(pl)     if GAMEMODE.EndTime and CurTime() < GAMEMODE.EndTime + 5 then         return true     end      hook.Remove("ShouldDrawLocalPlayer", "EndRoundShouldDrawLocalPlayer") end  function GM:EndRound(winner, nextmap)     if self.RoundEnded then return end     self.RoundEnded = true      ROUNDWINNER = winner      self.EndTime = CurTime()      RunConsoleCommand("stopsound")      self.HUDPaint = self.HUDPaintEndRound     self.HUDPaintBackground = self.HUDPaintBackgroundEndRound      if winner == TEAM_UNDEAD and GetGlobalBool("endcamera", true) then         hook.Add("CalcView", "EndRoundCalcView", EndRoundCalcView)         hook.Add("ShouldDrawLocalPlayer", "EndRoundShouldDrawLocalPlayer", EndRoundShouldDrawLocalPlayer)     end      local dvar = winner == TEAM_UNDEAD and self.AllLoseSound or                 (#team.GetPlayers(TEAM_HUMAN))/player.GetCount() < 0.15 and self.HumanWinSoloSound or                 self.HumanWinSound      local snd = GetGlobalString(winner == TEAM_UNDEAD and "losemusic" or "winmusic", dvar)     if snd == "default" then         snd = dvar     elseif snd == "none" then         snd = nil     end     if snd then         timer.Simple(0.5, function() surface_PlaySound(snd) end)     end      timer.Simple(5, function()         if not (pEndBoard and pEndBoard:IsValid()) then             MakepEndBoard(winner)         end     end) end  function GM:WeaponDeployed(pl, wep)     self:DoChangeDeploySpeed(wep) end  function GM:LocalPlayerDied(attackername)     LASTDEATH = RealTime()      surface_PlaySound(self.DeathSound)     if attackername then         self:CenterNotify(COLOR_RED, {font = "ZSHUDFont"}, translate.Get("you_have_died"))         self:CenterNotify(COLOR_RED, translate.Format(self.PantsMode and "you_were_kicked_by_x" or "you_were_killed_by_x", tostring(attackername)))     else         self:CenterNotify(COLOR_RED, {font = "ZSHUDFont"}, translate.Get("you_have_died"))     end end  function GM:KeyPress(pl, key)     if key == self.MenuKey and MySelf:IsValid() then         local pl_team = P_Team(pl)         if pl_team == TEAM_HUMAN and pl:Alive() and not pl:IsHolding() then             if not self.ZombieEscape then                 gamemode.Call("HumanMenu")             else                 RunConsoleCommand("ze_dropentity")             end         elseif pl_team == TEAM_ZOMBIE then             gamemode.Call("ZombieSpawnMenu")         end     elseif key == IN_SPEED then         if pl:Alive() then             if P_Team(pl) == TEAM_HUMAN then                 pl:DispatchAltUse()                  if not pl:IsCarrying() and pl:IsSkillActive(SKILL_CARDIOTONIC) and pl:CurrentDecimalStamina() > 0.4 then                     pl:ResetSpeed()                     pl:ResetStaminaRegen()                     pl:AddDecimalStamina(0)                 end             elseif P_Team(pl) == TEAM_UNDEAD then                 pl:CallZombieFunction0("AltUse")             end         end     end end  function GM:KeyRelease(pl, key)     if key == self.MenuKey and self.InventoryMenu and self.InventoryMenu:IsValid() then         local title = self.InventoryMenu.Title         title:SetText("Inventory")         title:SizeToContents()         title:CenterHorizontal()          self.InventoryMenu:SetVisible(false)         if self.m_InvViewer and self.m_InvViewer:IsValid() then             self.m_InvViewer:SetVisible(false)         end          if self.AmmoViewer and self.AmmoViewer:IsValid() then             self.AmmoViewer:SetVisible(false)         end          if self.InventoryMenu.SelInv then             self.InventoryMenu.SelInv = nil             self:DoAltSelectedItemUpdate()              local grid = self.InventoryMenu.Grid             for k, v in pairs(grid:GetChildren()) do                 v.On = false             end         end     end      if key == IN_SPEED and pl:IsValidLivingHuman() and pl:IsSkillActive(SKILL_CARDIOTONIC) then         pl:ResetSpeed()         pl:ResetStaminaRegen()     end end  function GM:PlayerStepSoundTime(pl, iType, bWalking)     local time = pl:CallZombieFunction2("PlayerStepSoundTime", iType, bWalking)     if time then         return time     end      if iType == STEPSOUNDTIME_NORMAL or iType == STEPSOUNDTIME_WATER_FOOT then         return 520 - pl:GetVelocity():Length()     end      if iType == STEPSOUNDTIME_ON_LADDER then         return 500     end      if iType == STEPSOUNDTIME_WATER_KNEE then         return 650     end      return 350 end  function GM:PlayerFootstep(pl, vFootPos, iFoot, strSoundName, fVolume)     return pl:CallZombieFunction4("PlayerFootstep", vFootPos, iFoot, strSoundName, fVolume) end  function GM:PlayerCanCheckout(pl)     return pl:IsValid() and P_Team(pl) == TEAM_HUMAN and pl:Alive() and self:GetWave() <= 0 end  function GM:OpenWorth()     if gamemode.Call("PlayerCanCheckout", MySelf) then         MakepWorth()     end end  function GM:CloseWorth()     if pWorth and pWorth:IsValid() then         pWorth:Remove()         pWorth = nil     end end  function GM:SuppressArsenalUpgrades(suppresstime)     self.SuppressArsenalTime = math.max(CurTime() + suppresstime, self.SuppressArsenalTime) end  function GM:Rewarded(class, amount)     if CurTime() < self.SuppressArsenalTime then return end      class = class or "0"      local toptext = translate.Get("arsenal_upgraded")      local wep = weapons.Get(class)     if wep and wep.PrintName and #wep.PrintName > 0 then         if killicon.Get(class) == killicon.Get("default") then             self:CenterNotify(COLOR_PURPLE, toptext..": ", color_white, wep.PrintName)         else             self:CenterNotify({killicon = class}, " ", COLOR_PURPLE, toptext..": ", color_white, wep.PrintName)         end     elseif amount then         self:CenterNotify(COLOR_PURPLE, toptext..": ", color_white, amount.." "..class)     else         self:CenterNotify(COLOR_PURPLE, toptext)     end end  function GM:TypewriterFont()     return self.ZSFont == 0 end  function PlayMenuOpenSound()     MySelf:EmitSound("buttons/lightswitch2.wav", 100, 30) end  function PlayMenuCloseSound()     MySelf:EmitSound("buttons/lightswitch2.wav", 100, 20) end  function ExplosiveEffect(pos, maxrange, damage, dmgtype)     local pos2 = pos + Vector(0, 0, 12)     for _, pl in pairs(player.GetAll()) do         local rag = pl:GetRagdollEntity()         if rag:IsValid() and not rag.Frozen then             local phys = rag:GetPhysicsObject()             if phys:IsValid() then                 local physpos = phys:GetPos()                 local dist = physpos:Distance(pos)                 if dist < maxrange then                     for i=0, rag:GetPhysicsObjectCount() do                         local subphys = rag:GetPhysicsObjectNum(i)                         if subphys then                             subphys:Wake()                         end                     end                      if dmgtype == DMGTYPE_FIRE then                         phys:ApplyForceOffset(damage * 1000 * maxrange / dist * (physpos - pos):GetNormal(), pos2)                         if not rag.Burnt then                             local effectdata = EffectData()                                 effectdata:SetOrigin(physpos)                                 effectdata:SetEntity(pl)                             util.Effect("fire_death", effectdata)                             rag:EmitSound("ambient/fire/mtov_flame2.wav", 50, math.random(105, 110))                         end                     else                         phys:ApplyForceOffset(damage * 1000 * maxrange / dist * (physpos - pos):GetNormal(), pos2)                     end                 end             end         end     end end  function GM:AnnouncePlayerReady(steamid)     local friend = self.ZSFriends[steamid]      if friend then         net.Start("zs_zsfriends_from_client")             net.WriteTable({                 [steamid] = true             })         net.SendToServer()     end end  function GM:PlayerClassChanged(ply, newID) end