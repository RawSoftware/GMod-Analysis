function player.GetAllActive()  local t = {}      local pl_table = SERVER and player.GetAllFastMutable() or player.GetAll()  for _, pl in pairs(pl_table) do  if not pl:IsSpectator() then  t[#t + 1] = pl  end  end   return t end  function player.GetAllSpectators()  local t = {}   for _, pl in pairs(player.GetAll()) do  if pl:IsSpectator() then  t[#t + 1] = pl  end  end   return t end  function FindStartingItem(id)  local item = FindItem(id)  if item and item.WorthShop then return item end end  function FindItem(id)  return GAMEMODE.Items[id] end  local TrueVisibleTrace = {mask = MASK_SHOT} function TrueVisibleFilters(posa, posb, ent1, ent2, ent3)  TrueVisibleTrace.start = posa  TrueVisibleTrace.endpos = posb  TrueVisibleTrace.filter = function(ent)  local filtered_ents = ent1 and ent1 == ent or    ent2 and ent2 == ent or        ent3 and ent3 == ent   if filtered_ents or ent:IsPlayer() or ent.RealProjectile or ent.IgnoreTraces or ent.NoBlockExplosions then  return false  end   return true  end  TrueVisibleTrace.mask = MASK_SHOT   return not util.TraceLine(TrueVisibleTrace).Hit end TrueVisible = TrueVisibleFilters  MASK_SHOT_OPAQUE = bit.bor(MASK_SHOT, CONTENTS_OPAQUE)   local LightVisibleTrace = {mask = MASK_SHOT_OPAQUE} function LightVisible(posa, posb, ...)  local filter  if ... ~= nil then  filter = {...}  end   LightVisibleTrace.start = posa  LightVisibleTrace.endpos = posb  LightVisibleTrace.filter = filter   return not util.TraceLine(LightVisibleTrace).Hit end  local WorldVisibleTrace = {mask = MASK_SOLID_BRUSHONLY} function WorldVisible(posa, posb)  WorldVisibleTrace.start = posa  WorldVisibleTrace.endpos = posb  return not util.TraceLine(WorldVisibleTrace).Hit end  function CosineInterpolation(y1, y2, mu)  local mu2 = (1 - math.cos(mu * math.pi)) / 2  return y1 * (1 - mu2) + y2 * mu2 end  function CubicInterpolate(y0, y1, y2, y3, mu)  local mu2 = mu * mu  local a0 = y3 - y2 - y0 + y1  local a1 = y0 - y1 - a0  local a2 = y2 - y0   return a0 * mu * mu2 + a1 * mu2 + a2 * mu + y1 end     function CatmullInterpolate(previous, start, last, nextp, elapsedTime, duration)  local percentComplete = elapsedTime / duration  local percentCompleteSquared = percentComplete * percentComplete  local percentCompleteCubed = percentCompleteSquared * percentComplete   return previous * (-0.5 * percentCompleteCubed +     percentCompleteSquared -  0.5 * percentComplete) +  start * (1.5 * percentCompleteCubed +     -2.5 * percentCompleteSquared + 1.0) +  last * (-1.5 * percentCompleteCubed +  2.0 * percentCompleteSquared +  0.5 * percentComplete) +  nextp * (0.5 * percentCompleteCubed -  0.5 * percentCompleteSquared) end  function string.AndSeparate(list)  local length = #list  if length <= 0 then return "" end  if length == 1 then return list[1] end  if length == 2 then return list[1].." and "..list[2] end   return table.concat(list, ", ", 1, length - 1)..", and "..list[length] end  function util.SkewedDistance(a, b, skew)  if a.z > b.z then  return math.sqrt((b.x - a.x) ^ 2 + (b.y - a.y) ^ 2 + ((a.z - b.z) * skew) ^ 2)  end   return a:Distance(b) end  function util.IsServerOrClient()  return SERVER and "SERVER" or "CLIENT" end  function util.Blood(pos, amount, dir, force, noprediction)  local effectdata = EffectData()  effectdata:SetOrigin(pos)  effectdata:SetMagnitude(amount)  effectdata:SetNormal(dir)  effectdata:SetScale(math.max(128, force))  util.Effect("bloodstream", effectdata, nil, noprediction) end  local aoe_table = {AreaOfEffect = true} function util.BlastDamagePlayer(inf, att, center, radius, damage, damagetype, taperfactor, ignoretab)     local att_pl = att:IsValidPlayer()  if not att_pl then         ErrorNoHalt("[BlastDamagePlayer] Tried to use a nonplayer")     else         att:WrappedFlagDamageFunction(aoe_table, function()             util.BlastDamageEx(inf, att, center, radius * (att.ExpDamageRadiusMul or 1), damage * (att.ExplosiveDamageMul or 1), damagetype, taperfactor, ignoretab)         end)     end end  function util.EntExplosionVisible(epicenter, nearest, inflictor, attacker, ent)  return TrueVisibleFilters(epicenter, nearest, inflictor, attacker, ent)  or TrueVisibleFilters(epicenter, ent:EyePos(), inflictor, attacker, ent)  or TrueVisibleFilters(epicenter, ent:WorldSpaceCenter(), inflictor, attacker, ent) end  function util.BlastDamageExAlloc(inflictor, attacker, epicenter, radius, damage, damagetype, taperfactor, ignoretab)  local dmg  local t = {}  local tab = ignoretab or {}   for _, ent in pairs(ents.FindInSphere(epicenter, radius)) do  if ent:IsValid() then  local nearest = ent:NearestPoint(epicenter)  if util.EntExplosionVisible(epicenter, nearest, inflictor, attacker, ent) and not tab[ent] then  dmg = ((radius - nearest:Distance(epicenter)) / radius) * damage  ent:TakeSpecialDamage(dmg, damagetype, attacker, inflictor, nearest)   t[ent] = dmg  end  end  end   return t end  function util.ToMinutesSeconds(seconds)  local minutes = math.floor(seconds / 60)  seconds = seconds - minutes * 60   return string.format("%02d:%02d", minutes, math.floor(seconds)) end    function util.ToMinutesSecondsCD(seconds)  seconds = math.ceil(seconds)  local minutes = math.floor(seconds / 60)  seconds = seconds - minutes * 60   return string.format("%02d:%02d", minutes, seconds) end  function util.ToMinutesSecondsMilliseconds(seconds)  local minutes = math.floor(seconds / 60)  seconds = seconds - minutes * 60   local milliseconds = math.floor(seconds % 1 * 100)   return string.format("%02d:%02d.%02d", minutes, math.floor(seconds), milliseconds) end  function util.RemoveAll(class)  for _, ent in pairs(ents.FindByClass(class)) do  ent:Remove()  end end      function util.CompressBitTable(t)  local buf = ""  local maxvalue = 0   t = table.ToAssoc(t)   for k in pairs(t) do  if k > maxvalue then maxvalue = k end  end  local num_bytes = math.ceil(maxvalue / 8)   for on_byte = 1, num_bytes do  local byte = 0   for bit_slot = 1, 8 do  if t[bit_slot + 8 * (on_byte - 1)] then  byte = bit.bor(byte, 2 ^ (bit_slot - 1))  end  end   buf = buf..string.char(byte)  end   return buf end  function util.DecompressBitTable(str, associative)  local t = {}   for on_byte = 1, #str do  local byte = str:sub(on_byte, on_byte):byte()  for bit_slot = 1, 8 do  if bit.band(byte, 1) == 1 then  local v = bit_slot + 8 * (on_byte - 1)  if associative then  t[v] = true  else  t[#t + 1] = v  end  end  byte = bit.arshift(byte, 1)  end  end   return t end  function table.IsAssoc(t)  for _, v in pairs(t) do  if v == true then  return true  end   return false  end end  function table.ToAssoc(t)  if not table.IsAssoc(t) then  local t2 = {}   for k, v in pairs(t) do  t2[v] = true  end   return t2  end   return t end  function table.ToKeyValues(t)  if table.IsAssoc(t) then  local t2 = {}   for k, v in pairs(t) do  if v then  t2[#t2 + 1] = k  end  end   return t2  end   return t end  local function TooNear(spawn, tab, dist)  dist = dist * dist   local spawnpos = spawn:GetPos()  for _, ent in pairs(tab) do  if ent:GetPos():DistToSqr(spawnpos) <= dist then  return true  end  end   return false end function team.GetSpawnPointGrouped(teamid, dist)  dist = dist or 200   local tab = {}  local spawns = team.GetSpawnPoint(teamid)   for _, spawn in pairs(spawns) do  if not TooNear(spawn, tab, dist) then  table.insert(tab, spawn)  end  end   return tab end  function AccessorFuncDT(tab, membername, type, id)  local emeta = FindMetaTable("Entity")  local setter = emeta["SetDT"..type]  local getter = emeta["GetDT"..type]   tab["Set"..membername] = function(me, val)  setter(me, id, val)  end   tab["Get"..membername] = function(me)  return getter(me, id)  end end  local E_Meta = FindMetaTable("Entity") local E_GetTable = E_Meta.GetTable  function team.GetValidSpawnPoint(teamid)     local t = {}     local tbl = team.GetSpawnPoint(teamid)     if not tbl then return t end      for i = 1, #tbl do         local ent = tbl[i]         if not ent:IsValid() then continue end          if not E_GetTable(ent).Disabled then             t[#t + 1] = ent         end     end      return t end  local limited_gib_count = {     ["prop_playergib"] = 0 } hook.Add("OnEntityCreated", "LimitedEntityCountCreate", function(ent)     local e_class = ent:GetClass()  if limited_gib_count[e_class] then  limited_gib_count[e_class] = limited_gib_count[e_class] + 1  end end)  hook.Add("EntityRemoved", "LimitedEntityCountRemove", function(ent)     local e_class = ent:GetClass()  if limited_gib_count[e_class] then  limited_gib_count[e_class] = limited_gib_count[e_class] - 1  end end)  function ents.CreateLimited(class, limit)  if (limited_gib_count[class] or #ents.FindByClass(class)) >= (limit or 32) then         return NULL     end   return ents.Create(class) end  function string.CommaSeparate(num)  local k  for ___=1, 10000 do  num, k = string.gsub(num, "^(-?%d+)(%d%d%d)", "%1,%2")  if k == 0 then break end  end  return num end  function tonumbersafe(a)  local n = tonumber(a)   if n then  if n == 0 or n < 0 or n > 0 then  return n  end      return 0  end   return nil end  function util.ClippedName(str, am)  if #str > am then  str = string.sub(str, 1, am-2)..".."  end   return str end  local pulseeffect = EffectData() pulseeffect:SetRadius(8) pulseeffect:SetMagnitude(1) pulseeffect:SetScale(1) function util.CreatePulseImpactEffect(hitpos, hitnormal)  pulseeffect:SetOrigin(hitpos)  pulseeffect:SetNormal(hitnormal)  util.Effect("AR2Impact", pulseeffect) end  function util.Map(func, array)  local new_array = {}  for i,v in pairs(array) do  new_array[i] = func(v)  end  return new_array end  function util.AngleCompCheck(ang_comp, degree)     degree = degree or 180      return ang_comp <= (degree/2) or ang_comp >= (360 - degree/2) end