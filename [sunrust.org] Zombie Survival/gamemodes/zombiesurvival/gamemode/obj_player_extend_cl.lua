local meta = FindMetaTable("Player")  local M_Entity = FindMetaTable("Entity") local E_GetTable = M_Entity.GetTable  function meta:FloatingScore(victim, effectname, frags, flags)     if MySelf == self then         gamemode.Call("FloatingScore", victim, effectname, frags, flags)     end end  function meta:FixModelAngles(velocity)     local eye = self:EyeAngles()     self:SetLocalAngles(eye)     self:SetRenderAngles(eye)     self:SetPoseParameter("move_yaw", math.NormalizeAngle(velocity:Angle().yaw - eye.y)) end  function meta:RemoveAllStatus(bSilent, bInstant) end  function meta:RemoveStatus(sType, bSilent, bInstant, sExclude) end  function meta:HasWon()     return self:Team() == TEAM_HUMAN and self:GetObserverMode() == OBS_MODE_ROAMING end  function meta:GetStatus(sType)     local ent = E_GetTable(self)["status_"..sType]      if ent then return ent end end  function meta:GiveStatus(sType, fDie) end  function meta:KnockDown(time) end  local ViewHullMins = Vector(-8, -8, -8) local ViewHullMaxs = Vector(8, 8, 8)  local third_filter = function(ent)     return not (ent:IsPlayer() or ent:IsProjectile()) end  function meta:GetThirdPersonCameraPos(origin, angles)     local tr = util.TraceHull({start = origin, endpos = origin + angles:Forward() * -math.max(36, self:Team() == TEAM_UNDEAD and self:GetZombieClassTable().CameraDistance or self:BoundingRadius()), mask = MASK_SHOT, filter = third_filter, mins = ViewHullMins, maxs = ViewHullMaxs})     return tr.HitPos + tr.HitNormal * 3 end  function meta:IsFriend()     return self.m_IsFriend end  timer.Create("checkfriend", 5, 0, function()           for _, pl in pairs(player.GetAll()) do         pl.m_IsFriend = pl:GetFriendStatus() == "friend"     end end)  if not meta.SetGroundEntity then     function meta:SetGroundEntity(ent) end end  if not meta.Kill then     function meta:Kill() end end  if not meta.HasWeapon then     function meta:HasWeapon(class)         for _, wep in pairs(self:GetWeapons()) do             if wep:GetClass() == class then return true end         end          return false     end end  function meta:SetMaxHealth(num)     self:SetDTInt(0, math.ceil(num)) end  meta.OldGetMaxHealth = FindMetaTable("Entity").GetMaxHealth function meta:GetMaxHealth()     return self:GetDTInt(0) end  function meta:DoHulls(classid, teamid)     teamid = teamid or self:Team()     classid = classid or self:GetZombieClass()      if teamid == TEAM_UNDEAD then         self:SetIK(false)          local classtab = GAMEMODE.ZombieClasses[classid]         if classtab then             if classtab.ModelScale then                 self:SetModelScale(classtab.ModelScale, 0)             elseif self:GetModelScale() ~= DEFAULT_MODELSCALE then                 self:SetModelScale(DEFAULT_MODELSCALE, 0)             end              if not classtab.Hull or not classtab.HullDuck then                 self:ResetHull()             end             if classtab.ViewOffset then                 self:SetViewOffset(classtab.ViewOffset)             elseif self:GetViewOffset() ~= DEFAULT_VIEW_OFFSET then                 self:SetViewOffset(DEFAULT_VIEW_OFFSET)             end             if classtab.ViewOffsetDucked then                 self:SetViewOffsetDucked(classtab.ViewOffsetDucked)             elseif self:GetViewOffsetDucked() ~= DEFAULT_VIEW_OFFSET_DUCKED then                 self:SetViewOffsetDucked(DEFAULT_VIEW_OFFSET_DUCKED)             end             if classtab.HullDuck then                 self:SetHullDuck(classtab.HullDuck[1], classtab.HullDuck[2])             end             if classtab.Hull then                 self:SetHull(classtab.Hull[1], classtab.Hull[2])             end             if classtab.StepSize then                 self:SetStepSize(classtab.StepSize)             elseif self:GetStepSize() ~= DEFAULT_STEP_SIZE then                 self:SetStepSize(DEFAULT_STEP_SIZE)             end             if classtab.JumpPower then                 self:SetJumpPower(classtab.JumpPower)             elseif self:GetJumpPower() ~= DEFAULT_JUMP_POWER then                 self:SetJumpPower(DEFAULT_JUMP_POWER)             end             if classtab.Gravity then                 self:SetGravity(classtab.Gravity)             elseif self:GetGravity() ~= 1 then                 self:SetGravity(1)             end              if classtab.ClientsideModelScale then                 self.ClientsideModelScale = Vector(1, 1, 1) * classtab.ClientsideModelScale                 local m = Matrix()                 m:Scale(self.ClientsideModelScale)                 self:EnableMatrix("RenderMultiply", m)             end             self.NoCollideAll = classtab.NoCollideAll or (classtab.ModelScale or 1) ~= DEFAULT_MODELSCALE                           self.AllowTeamDamage = classtab.AllowTeamDamage             self.NeverAlive = classtab.NeverAlive             self.KnockbackScale = classtab.KnockbackScale             local phys = self:GetPhysicsObject()             if phys:IsValid() then                 phys:SetMass(classtab.Mass or DEFAULT_MASS)             end         end     else         self:SetIK(true)          self:SetModelScale(DEFAULT_MODELSCALE, 0)         self:ResetHull()         self:SetViewOffset(DEFAULT_VIEW_OFFSET)         self:SetViewOffsetDucked(DEFAULT_VIEW_OFFSET_DUCKED)         self:SetStepSize(DEFAULT_STEP_SIZE)         self:SetJumpPower(DEFAULT_JUMP_POWER)         self:SetGravity(1)          if self.ClientsideModelScale then             self.ClientsideModelScale = nil             self:DisableMatrix("RenderMultiply")         end         self.NoCollideAll = nil                   self.AllowTeamDamage = nil         self.NeverAlive = nil         self.KnockbackScale = nil         local phys = self:GetPhysicsObject()         if phys:IsValid() then             phys:SetMass(DEFAULT_MASS)         end     end end  function meta:GivePenalty(amount)     surface.PlaySound("ambient/alarms/klaxon1.wav") end  function meta:SetZombieClass(cl)     self:CallZombieFunction0("SwitchedAway")      local classtab = GAMEMODE.ZombieClasses[cl]     if classtab then         self.Class = classtab.Index or cl         self:CallZombieFunction0("SwitchedTo")     end end  function meta:GetRateOfPalsy(ft, frightened, health, threshold, gunsway)     local healthth = health <= threshold and (((threshold - health) / threshold) * 7) or 0      return ft * (                     (frightened and 14 or healthth) * (MySelf.AimShakeMul or 1) +                     (gunsway and (3 * (MySelf.AimSpreadMul or 1)) or 0)                 ) end  GM.CachedResupplyAmmoType = "scrap" timer.Create("CacheResupplyAmmoType", 0.3333, 0, function()     if not GAMEMODE or not MySelf or not MySelf.GetResupplyAmmoType then return end      GAMEMODE.CachedResupplyAmmoType = MySelf:GetResupplyAmmoType() end)  net.Receive("zs_penalty", function(length)     local penalty = net.ReadUInt(16)      MySelf:GivePenalty(penalty) end)  net.Receive("zs_dohulls", function(length)     local ent = net.ReadEntity()     local classid = net.ReadUInt(8)     local is_zombie = net.ReadBool()      if ent:IsValid() then         ent:DoHulls(classid, is_zombie and TEAM_UNDEAD or TEAM_HUMAN)     end end)  net.Receive("zs_zclass", function(length)     local ent = net.ReadEntity()     local id = net.ReadUInt(8)      if ent:IsValidPlayer() then         ent:SetZombieClass(id)     end end)  net.Receive("zs_floatscore", function(length)     local victim = net.ReadEntity()     local effectname = net.ReadString()     local frags = net.ReadInt(24)     local flags = net.ReadUInt(8)      GAMEMODE.LastPointFloater = frags     GAMEMODE.LastPointFloaterTime = CurTime() + 2      if victim and victim:IsValid() then         MySelf:FloatingScore(victim, effectname, frags, flags)     end end)  net.Receive("zs_floatscore_vec", function(length)     local pos = net.ReadVector()     local effectname = net.ReadString()     local frags = net.ReadInt(24)     local flags = net.ReadUInt(8)      GAMEMODE.LastPointFloater = frags     GAMEMODE.LastPointFloaterTime = CurTime() + 2      MySelf:FloatingScore(pos, effectname, frags, flags) end)  function meta:AddNewCooldown(key, wait)     if not GAMEMODE.Cooldowns then         GAMEMODE.Cooldowns = {}     end      GAMEMODE.Cooldowns[key] = CurTime() + wait end  function meta:CooldownReady(key)     if not GAMEMODE.Cooldowns then         GAMEMODE.Cooldowns = {}     end      return not GAMEMODE.Cooldowns[key] or CurTime() > GAMEMODE.Cooldowns[key] end  local math_random = math.random local function RemoveFLHook(fl)     fl:Remove()     hook.Remove("CalcView", "CalcView.Flashlight") end  local M_Player = FindMetaTable("Player") local P_Team = M_Player.Team  local UpdateFL = false function meta:UpdateFlashlight(pos, ang)     local flashlight = self.E_FL     if P_Team(self) == TEAM_UNDEAD then RemoveFLHook(flashlight) return end      if pos or ang then         flashlight:SetPos(pos)         flashlight:SetAngles(ang)         UpdateFL = true     end      if UpdateFL then         UpdateFL = false         flashlight:Update()     end end  local function CalcViewFL(ply, pos, angles, fov)     if GAMEMODE.OverTheShoulder then         local BoneIndx = ply:LookupBone("ValveBiped.Bip01_Head1")          if BoneIndx then             local newpos, _ = ply:GetBonePosition(BoneIndx)             ply:UpdateFlashlight(newpos and newpos or pos, angles)         else             ply:UpdateFlashlight(pos, angles)         end     else         ply:UpdateFlashlight(pos, angles)     end end  local mat_flashlight = "effects/flashlight001" function meta:CreateFlashlight()     if IsValid(self.E_FL) then RemoveFLHook(self.E_FL) return end      local light = ProjectedTexture()     if IsValid(light) then         light:SetColor(color_white)         light:SetEnableShadows(false)         light:SetTexture(mat_flashlight)         light:SetFOV(GAMEMODE.FlashLightZFOV or 65)         light:SetFarZ(GAMEMODE.FlashLightZFAR or 1000)         light:SetNearZ(2)         self.E_FL = light                   self:UpdateFlashlight(EyePos(), EyeAngles(), true)          hook.Add("CalcView", "CalcView.Flashlight", CalcViewFL, HOOK_MONITOR_HIGH)     end end  function meta:Turn_FL(bOn)     if self ~= MySelf or not self:Alive() then return end      self:EmitSound("items/flashlight1.wav", 75, bOn and math_random(105, 110) or math_random(95, 100))      if bOn then         self:CreateFlashlight()     else         if IsValid(self.E_FL) then             RemoveFLHook(self.E_FL)         end     end end