local meta = FindMetaTable("Entity")  local vector_origin = vector_origin local util_SharedRandom = util.SharedRandom local util_TraceHull = util.TraceHull local util_TraceLine = util.TraceLine local TEAM_HUMAN = TEAM_HUMAN local TEAM_UNDEAD = TEAM_UNDEAD local HITGROUP_HEAD = HITGROUP_HEAD local MASK_SHOT = MASK_SHOT local pairs = pairs  local M_Player = FindMetaTable("Player") local P_Team = M_Player.Team local E_IsValid = meta.IsValid local E_GetTable = meta.GetTable  local rawset = rawset local getmetatable = getmetatable    local CONTENTS_LIQUID = bit.bor(CONTENTS_WATER, CONTENTS_SLIME) local MASK_SHOT_HIT_WATER = bit.bor(MASK_SHOT, CONTENTS_LIQUID)  local bullet_tr = {} local bullet_water_tr = {} local temp_angle = Angle(0, 0, 0) local temp_ignore_team local temp_has_spread local method_to_use, base_ang local bullet_trace = {mask = MASK_SHOT, output = bullet_tr} local temp_shooter = NULL local temp_attacker = NULL local attacker_player, inflictor_weapon local temp_pen_ents = {} local function BaseBulletFilter(ent)     if ent == temp_shooter         or ent == temp_attacker         or temp_pen_ents[ent]         or ent:IsPlayer() and P_Team(ent) == temp_ignore_team then             return false     end      local e_tb = E_GetTable(ent)      if e_tb.NeverAlive         or e_tb.SpawnProtection         or e_tb.IgnoreBullets then             return false     end      if e_tb.AlwaysImpactBullets then         return true     end      return true end local ze_flags = bit.bor(MASK_SHOT, CONTENTS_GRATE) local ze_bullet_trace = {mask = ze_flags, output = bullet_tr} local ze_ExcludeBossClass = {     ["func_breakable"] = true,     ["func_physbox"] = true,     ["func_physbox_multiplayer"] = true,     ["prop_dynamic"] = true,     ["prop_dynamic_override"] = true, }  local function HandleShotImpactingWater(damage)           bullet_trace.mask = MASK_SHOT_HIT_WATER     bullet_trace.output = bullet_water_tr     util_TraceLine(bullet_trace)     bullet_trace.output = bullet_tr     bullet_trace.mask = MASK_SHOT      if bullet_water_tr.AllSolid then return false end      local contents = util.PointContents(bullet_water_tr.HitPos - bullet_water_tr.HitNormal * 0.1)     if bit.band(contents, CONTENTS_LIQUID) == 0 then return false end      if IsFirstTimePredicted() then         local effectdata = EffectData()         effectdata:SetOrigin(bullet_water_tr.HitPos)         effectdata:SetNormal(bullet_water_tr.HitNormal)         effectdata:SetScale(math.Clamp(damage * 0.25, 5, 30))         effectdata:SetFlags(bit.band(contents, CONTENTS_SLIME) ~= 0 and 1 or 0)         util.Effect("gunshotsplash", effectdata)     end      return true end  local wspawn = Entity(0) local function CheckFHB(tr)     local ent = tr.Entity     if not ent or ent == wspawn then return end      if E_IsValid(ent) and E_GetTable(ent).FHB then         tr.Entity = ent:GetParent()     end end  local bullet_trace_tb  = {} local bullet_inter_tb  = {} local bullet_effect_tb = {}  local has_hit_world = false  local vec_up = Vector(0, 0, 1) local function DoLuaBulletInteraction(me, i)     local damage     = bullet_inter_tb.damage     local inflictor  = bullet_inter_tb.inflictor     local callback   = bullet_inter_tb.callback     local dir        = bullet_trace_tb.dir     local num        = bullet_inter_tb.num     local attacker   = temp_attacker      local damageinfo = DamageInfo()     damageinfo:SetDamageType(DMG_BULLET)     damageinfo:SetDamage(damage)     damageinfo:SetDamagePosition(bullet_tr.HitPos)     damageinfo:SetAttacker(attacker)     damageinfo:SetInflictor(inflictor or me)     damageinfo:SetDamageForce(vec_up)      local use_tracer = true     local use_impact = true     local use_ragdoll_impact = true     local use_damage = true      if callback then         local ret = callback(attacker, bullet_tr, damageinfo, bullet_inter_tb.curpen)         if ret then             if ret.donothing then return end              if ret.tracer ~= nil then use_tracer = ret.tracer end             if ret.impact ~= nil then use_impact = ret.impact end             if ret.ragdoll_impact ~= nil then use_ragdoll_impact = ret.ragdoll_impact end             if ret.damage ~= nil then use_damage = ret.damage end         end     end      rawset(bullet_effect_tb, "rag_impact", use_ragdoll_impact)     rawset(bullet_effect_tb, "use_impact", use_impact)     rawset(bullet_effect_tb, "usetracer", use_tracer)     rawset(bullet_effect_tb, "use_damage", use_damage)      local ent = bullet_tr.Entity     if E_IsValid(ent) and use_damage then         if ent:IsPlayer() then             if SERVER then                 ent:SetLastHitGroup(bullet_tr.HitGroup)                 if bullet_tr.HitGroup == HITGROUP_HEAD then                     ent:SetWasHitInHead()                 end             end              temp_pen_ents[ent] = true         elseif attacker:IsValidPlayer() then             local phys = ent:GetPhysicsObject()             if ent:GetMoveType() == MOVETYPE_VPHYSICS and phys:IsValid() and phys:IsMoveable() then                 ent:SetPhysicsAttacker(attacker)             end         end          if SERVER or not GAMEMODE.DisableBloodImpact then             if GAMEMODE.ZombieEscape then                 if not ze_ExcludeBossClass[ent:GetClass()] then                       ent:DispatchTraceAttack(damageinfo, bullet_tr, dir)                 end             else                 ent:DispatchTraceAttack(damageinfo, bullet_tr, dir)             end         end     end      if SERVER and ((num > 1 and i == num - 1) or FORCE_POP_DAMAGE) and attacker_player then         local dmg, dmgpos, haspl = attacker:PopDamageNumberSession()          if dmg and dmg > 0 and dmgpos then             GAMEMODE:DamageFloater(attacker, ent, dmgpos, dmg, haspl, bullet_tr.HitGroup and bullet_tr.HitGroup == HITGROUP_HEAD)         end     end end  local borer_type = {     ["pistol"]      = 0.25,     ["ar2"]         = 0.21,     ["357"]         = 0.3 } local pen_condition_met = true local head_hitbox = false function meta:FireBulletsLua(src, dir, spread, num, damage, attacker, force_mul, tracer, callback, hull_size, hit_own_team, max_distance, filter, inflictor, attach_ent, attach_id)     max_distance = max_distance or 56756     attacker = attacker or self     if not E_IsValid(attacker) then attacker = self end     force_mul = force_mul or 1      temp_shooter = self     temp_attacker = attacker     attacker_player = attacker:IsPlayer()     inflictor_weapon = inflictor and inflictor:IsWeapon()      bullet_trace.start = src     if filter then         bullet_trace.filter = filter     else         bullet_trace.filter = BaseBulletFilter         if not hit_own_team and attacker_player then             temp_ignore_team = P_Team(attacker)         else             temp_ignore_team = nil         end     end      if hull_size then         bullet_trace.maxs = Vector(hull_size, hull_size, hull_size) * 0.5         bullet_trace.mins = bullet_trace.maxs * -1         method_to_use = util_TraceHull     else         method_to_use = util_TraceLine     end      base_ang = dir:Angle()     temp_has_spread = spread > 0      local inf_tb = E_GetTable(inflictor)     local att_tb = E_GetTable(attacker)      local bore_pens = 0     local bore_val     if attacker_player and (inf_tb.Tier or 1) <= 3 then         local bore = att_tb.BulletModBore         if bore and bore > 0 then             bore_pens = 1             bore_val = bore         end     end      local total_pens = (inf_tb.Pens or 0) + bore_pens      if SERVER and total_pens == 0 and (FORCE_DAMAGE_NUMBER_COMBO or num > 1) and attacker_player then         attacker:StartDamageNumberSession()     end      bullet_trace_tb.spread       = spread     bullet_trace_tb.pattern      = inf_tb.SpreadPattern     bullet_trace_tb.src          = src     bullet_trace_tb.dir          = dir     bullet_trace_tb.max_dist     = max_distance      for i=0, num - 1 do         temp_pen_ents = {}         has_hit_world = false         pen_condition_met = true          for pens=0, total_pens do             if not pen_condition_met then continue end              local b_dmg = damage             if bore_pens == 1 then                 b_dmg = damage * 0.8                  if pens == 1 then                     local res_ammo_as = inf_tb.ResistanceAmmoAs                     local ammo_type   = res_ammo_as and res_ammo_as ~= "dummy" and res_ammo_as or                                         inf_tb.Primary and inf_tb.Primary.Ammo                      b_dmg = damage * (ammo_type and borer_type[string.lower(ammo_type)] or 0.17) * bore_val                 end             end              if total_pens >= 1 and inf_tb.PenTaper and (bore_pens ~= 1 or pens ~= 1) then                 local stagger = bore_pens == 1 and pens >= 1 and 1 or 0                  b_dmg = damage * (inf_tb.PenTaper ^ (pens - stagger))             end              bullet_inter_tb.damage    = b_dmg             bullet_inter_tb.inflictor = inflictor             bullet_inter_tb.callback  = callback             bullet_inter_tb.curpen    = pens             bullet_inter_tb.num       = num              self:PerformLuaBulletTrace(i)              if total_pens >= 1 and inf_tb.PenHeadOnly and not head_hitbox then                 pen_condition_met = false             end              bullet_effect_tb.attacker = attacker             bullet_effect_tb.src      = src             bullet_effect_tb.tracer   = tracer             bullet_effect_tb.ath_ent  = attach_ent             bullet_effect_tb.ath_id   = attach_id              DoLuaBulletInteraction(self, i)              local do_effects = true             if total_pens >= 1 then                 do_effects = pens == total_pens or has_hit_world             end             if do_effects then                 self:DoLuaBulletEffects(i)             end              if GAMEMODE.ZombieEscape then                 self:SecondZETrace()             end              if has_hit_world then break end         end     end end  function meta:PerformLuaBulletTrace(i)     local spread          = bullet_trace_tb.spread     local pattern         = bullet_trace_tb.pattern     local src             = bullet_trace_tb.src     local dir             = bullet_trace_tb.dir     local max_dist        = bullet_trace_tb.max_dist     local damage          = bullet_inter_tb.damage      if pattern and pattern[i+1] then         local pattern_x, pattern_y = pattern[i+1][1], pattern[i+1][2]          temp_angle:Set(base_ang)         temp_angle:RotateAroundAxis(temp_angle:Forward(), pattern_x)         temp_angle:RotateAroundAxis(temp_angle:Up(), pattern_y * spread)          dir = temp_angle:Forward()     elseif temp_has_spread then         temp_angle:Set(base_ang)          local rotation_index = shoot_system .. i         temp_angle:RotateAroundAxis(             temp_angle:Forward(),             inflictor_weapon and util_SharedRandom(rotation_index .. "r", 0, 360) or math.Rand(0, 360)         )         temp_angle:RotateAroundAxis(             temp_angle:Up(),             inflictor_weapon and util_SharedRandom(rotation_index .. "a", -spread, spread) or math.Rand(-spread, spread)         )          dir = temp_angle:Forward()     end      bullet_trace.endpos = src + dir * max_dist      if attacker_player and DO_BULLET_LAG_COMP then         temp_attacker:LagCompensation(true)     end     bullet_tr = method_to_use(bullet_trace)     if attacker_player and DO_BULLET_LAG_COMP then         temp_attacker:LagCompensation(false)     end      CheckFHB(bullet_tr)      bullet_effect_tb.hitwater = false     if bit.band(util.PointContents(bullet_tr.HitPos), CONTENTS_LIQUID) ~= 0 then         bullet_effect_tb.hitwater = HandleShotImpactingWater(damage)     end      local hb = bullet_tr.HitGroup     head_hitbox = hb and hb == HITGROUP_HEAD      has_hit_world = bullet_tr.HitWorld or not bullet_tr.Hit end  local bullet_count = 0 function meta:DoLuaBulletEffects(i)     local hitwater        = bullet_effect_tb.hitwater     local rag_impact      = bullet_effect_tb.rag_impact     local use_impact      = bullet_effect_tb.use_impact     local use_tracer      = bullet_effect_tb.usetracer     local tracer          = bullet_effect_tb.tracer     local ath_ent         = bullet_effect_tb.ath_ent     local ath_id          = bullet_effect_tb.ath_id      local src             = bullet_effect_tb.src     local ent             = bullet_tr.Entity      if IsFirstTimePredicted() then         if SERVER and not FORCE_B_EFFECT then             if bullet_count < 5 then                 bullet_count = bullet_count + 1                 return             else                 bullet_count = 1             end         end          local effectdata = EffectData()         effectdata:SetOrigin(bullet_tr.HitPos)         effectdata:SetStart(src)         effectdata:SetNormal(bullet_tr.HitNormal)          if hitwater then                           if rag_impact then                 util.Effect("RagdollImpact", effectdata)             end         elseif use_impact and not bullet_tr.HitSky and bullet_tr.Fraction < 1 then             effectdata:SetSurfaceProp(bullet_tr.SurfaceProps)             effectdata:SetDamageType(DMG_BULLET)             effectdata:SetHitBox(bullet_tr.HitBox)             effectdata:SetEntity(ent)             util.Effect("Impact", effectdata)         end          if use_tracer then             if self:IsPlayer() and E_IsValid(self:GetActiveWeapon()) then                 effectdata:SetFlags( 0x0003 )                   effectdata:SetEntity(ath_ent or self:GetActiveWeapon())                 effectdata:SetAttachment(ath_id or 1)             else                 effectdata:SetEntity(self)                 effectdata:SetFlags( 0x0001 )               end             effectdata:SetScale(5000)                if SERVER and not FORCE_B_EFFECT then                 SuppressHostEvents(self)             end             util.Effect(tracer or "Tracer", effectdata)             if SERVER and not FORCE_B_EFFECT then                 SuppressHostEvents(NULL)             end         end     end end  function meta:SecondZETrace()     local src        = bullet_effect_tb.src     local dir        = bullet_trace_tb.dir     local max_dist   = bullet_trace_tb.max_dist     local damage     = bullet_inter_tb.damage     local inflictor  = bullet_inter_tb.inflictor     local attacker   = temp_attacker      ze_bullet_trace.start = src     ze_bullet_trace.filter = function(ent)         if ent == temp_shooter or ent == temp_attacker or ent.IgnoreBullets or ent:IsPlayer() then             return false         end          return true     end      ze_bullet_trace.endpos = src + dir * max_dist     ze_bullet_tr = util_TraceLine(ze_bullet_trace)      local ze_damageinfo = DamageInfo()     ze_damageinfo:SetDamageType(DMG_BULLET)     ze_damageinfo:SetDamage(damage)     ze_damageinfo:SetDamagePosition(ze_bullet_tr.HitPos)     ze_damageinfo:SetAttacker(attacker)     ze_damageinfo:SetInflictor(inflictor or self)     ze_damageinfo:SetDamageForce(Vector(0, 0, 1))      local func = ze_bullet_tr.Entity     if E_IsValid(func) and bullet_effect_tb.use_damage then         func:DispatchTraceAttack(ze_damageinfo, ze_bullet_tr, dir)     end end  function meta:IsValidPlayer()     return E_IsValid(self) and getmetatable(self) == M_Player end  function meta:IsValidHuman()     return E_IsValid(self) and getmetatable(self) == M_Player and P_Team(self) == TEAM_HUMAN end  function meta:IsValidZombie()     return E_IsValid(self) and getmetatable(self) == M_Player and P_Team(self) == TEAM_UNDEAD end  function meta:IsHuman()     return self:IsPlayer() and P_Team(self) == TEAM_HUMAN end  function meta:IsZombie()     return self:IsPlayer() and P_Team(self) == TEAM_UNDEAD end  function meta:IsValidLivingPlayer()     return self:IsValidPlayer() and self:Alive() end  function meta:IsValidLivingHuman()     return self:IsValidHuman() and self:Alive() end  function meta:IsValidLivingZombie()     return self:IsValidZombie() and self:Alive() end  function meta:ApplyPlayerProperties(ply)     self.GetPlayerColor = function() return ply:GetPlayerColor() end     self:SetBodygroup( ply:GetBodygroup(1), 1 )     self:SetMaterial( ply:GetMaterial() )     self:SetSkin( ply:GetSkin() or 1 ) end  function meta:GetVolume()     local mins, maxs = self:OBBMins(), self:OBBMaxs()     return (maxs.x - mins.x) + (maxs.y - mins.y) + (maxs.z - mins.z) end  function meta:TakeSpecialDamage(damage, damagetype, attacker, inflictor, hitpos, damageforce)     if self:IsPlayer() and not self:Alive() then return end     if not attacker or not E_IsValid(attacker) then attacker = game.GetWorld() end     if not inflictor or not E_IsValid(inflictor) then inflictor = attacker end      local dmginfo = DamageInfo()     dmginfo:SetDamage(damage)     if attacker then         dmginfo:SetAttacker(attacker)     end      local nearestpos = self:NearestPoint(inflictor:NearestPoint(self:LocalToWorld(self:OBBCenter())))      if inflictor then         dmginfo:SetInflictor(inflictor)         if hitpos then             dmginfo:SetDamagePosition(hitpos)         elseif E_IsValid(inflictor) then             dmginfo:SetDamagePosition(nearestpos)         end     else         dmginfo:SetDamagePosition(hitpos or nearestpos)     end     dmginfo:SetDamageType(damagetype)      local vel = self:GetVelocity()     self:TakeDamageInfo(dmginfo)     if self:IsPlayer() and attacker ~= self then         self:SetLocalVelocity(vel)     end      return dmginfo end  function meta:NearestBone(pos)     local count = self:GetBoneCount()     if count == 0 then return end      local nearest     local nearestdist      for boneid = 1, count - 1 do         local bonepos = self:GetBonePositionMatrixed(boneid)         local dist = bonepos:DistToSqr(pos)          if not nearest or dist < nearestdist then             nearest = boneid             nearestdist = dist         end     end      return nearest end  function meta:IsProjectile()     if self == NULL then return end     if not IsValid(self) then return end      return self:GetCollisionGroup() == COLLISION_GROUP_PROJECTILE or self.AlwaysProjectile end  function meta:SetupGenericProjectile(gravity)     if SERVER then         local g,f = GetProjectileFlags(self)         self:SetCustomGroupAndFlags(g,f, true)         self:SetCollisionGroup(COLLISION_GROUP_PROJECTILE)         self.RealProjectile = true     end      local phys = self:GetPhysicsObject()     if phys:IsValid() then         phys:SetMass(1)         phys:SetBuoyancyRatio(0.0001)         phys:EnableMotion(true)         if not gravity then phys:EnableGravity(gravity) end         phys:EnableDrag(false)         phys:Wake()     end end  function meta:ProjectileDamageSource()     return (self.ProjSource and E_IsValid(self.ProjSource)) and self.ProjSource or self end  function meta:ResetBones(onlyscale)     local v = Vector(1, 1, 1)     local bcount = self.BuildingBones or self:GetBoneCount() - 1     if onlyscale then         for i=0, bcount do             self:ManipulateBoneScale(i, v)         end     else         local a = Angle(0, 0, 0)         for i=0, bcount do             self:ManipulateBoneScale(i, v)             self:ManipulateBoneAngles(i, a)             self:ManipulateBonePosition(i, vector_origin)         end     end end  function meta:GetBarricadeHealth()     return self:GetDTFloat(1) end  function meta:GetMaxBarricadeHealth()     return self:GetDTFloat(2) end  function meta:GetBarricadeRepairs()     return self:GetDTFloat(3) end  function meta:GetMaxBarricadeRepairs()     return self:GetMaxBarricadeHealth() * GAMEMODE.BarricadeRepairCapacity end  function meta:GetBonePositionMatrixed(index)     local matrix = self:GetBoneMatrix(index)     if matrix then         return matrix:GetTranslation(), matrix:GetAngles()     end      return self:GetPos(), self:GetAngles() end    function meta:CollisionRulesChanged()     if not self.m_OldCollisionGroup then self.m_OldCollisionGroup = self:GetCollisionGroup() end     self:SetCollisionGroup(self.m_OldCollisionGroup == COLLISION_GROUP_DEBRIS and COLLISION_GROUP_WORLD or COLLISION_GROUP_DEBRIS)     self:SetCollisionGroup(self.m_OldCollisionGroup)     self.m_OldCollisionGroup = nil end  function meta:GetAlpha()     return self:GetColor().a end  function meta:SetAlpha(a)     local col = self:GetColor()     col.a = a     self:SetColor(col) end  function meta:IsBarricadeProp()     return self.IsBarricadeObject or self:IsNailed() end  function meta:GetHolder()     for _, ent in pairs(ents.FindByClass("status_human_holding")) do         if ent:GetObject() == self then             local owner = ent:GetOwner()             if owner:IsPlayer() and owner:Alive() then return owner, ent end         end     end end  function meta:ThrowFromPosition(pos, force, noknockdown)     if force == 0 or self:IsProjectile() or self.NoThrowFromPosition then return false end      if self:IsPlayer() then         if self:ActiveBarricadeGhosting() then return false end          force = force * (self.KnockbackScale or 1)     end      if self:GetMoveType() == MOVETYPE_VPHYSICS then         local phys = self:GetPhysicsObject()         if phys:IsValid() and phys:IsMoveable() then             local nearest = self:NearestPoint(pos)             phys:ApplyForceOffset(force * 50 * (nearest - pos):GetNormalized(), nearest)         end          return true     elseif self:GetMoveType() >= MOVETYPE_WALK and self:GetMoveType() < MOVETYPE_PUSH then         self:SetGroundEntity(NULL)         if SERVER and not noknockdown and self:IsPlayer() then             local absforce = math.abs(force)             if absforce >= 512 or (self.IsClumsy and self:CooldownReady("clumsy")) and P_Team(self) == TEAM_HUMAN and absforce >= 32 then                 if self.IsClumsy then                     self:AddNewCooldown("clumsy", 7)                 end                 self:KnockDown()             end         end         self:SetVelocity(force * (self:LocalToWorld(self:OBBCenter()) - pos):GetNormalized())          return true     end end  function meta:ThrowFromPositionSetZ(pos, force, zmul, noknockdown)     if force == 0 or self:IsProjectile() or self.NoThrowFromPosition then return false end     zmul = zmul or 0.7      if self:IsPlayer() then         if self:ActiveBarricadeGhosting() or self.SpawnProtection then return false end          force = force * (self.KnockbackScale or 1)     end      if self:GetMoveType() == MOVETYPE_VPHYSICS then         local phys = self:GetPhysicsObject()         if phys:IsValid() and phys:IsMoveable() then             local nearest = self:NearestPoint(pos)             local dir = nearest - pos             dir.z = 0             dir:Normalize()             dir.z = zmul             phys:ApplyForceOffset(force * 50 * dir, nearest)         end          return true     elseif self:GetMoveType() >= MOVETYPE_WALK and self:GetMoveType() < MOVETYPE_PUSH then         self:SetGroundEntity(NULL)         if SERVER and not noknockdown and self:IsPlayer() then             local absforce = math.max(math.abs(force) * math.abs(zmul), math.abs(force))             if absforce >= 512 or self.IsClumsy and P_Team(self) == TEAM_HUMAN and absforce >= 32 then                 self:KnockDown()             end         end          local dir = self:LocalToWorld(self:OBBCenter()) - pos         dir.z = 0         dir:Normalize()         dir.z = zmul         self:SetVelocity(force * dir)          return true     end end  util.PrecacheSound("player/pl_pain5.wav") util.PrecacheSound("player/pl_pain6.wav") util.PrecacheSound("player/pl_pain7.wav") function meta:PoisonDamage(damage, attacker, inflictor, hitpos, noreduction, instant)     damage = damage or 1      local dmginfo = DamageInfo()      if self:IsPlayer() then         if P_Team(self) ~= TEAM_HUMAN then return end          local mywep = self:GetActiveWeapon()         local dif = math.abs(self:GetForward():Angle().yaw - (inflictor:IsProjectile() and (self:GetPos() - inflictor:GetPos()) or attacker:GetForward()):Angle().yaw)         local behind = util.AngleCompCheck(dif)         if mywep and mywep:IsValid() and mywep.IsBlocking and mywep.Stability then             local required_stamina = self:GetRequiredStabilityStamina(mywep.Stability, damage, behind)              if mywep:IsBlocking() and self:CurrentDecimalStamina() >= 0 then                 if inflictor:IsProjectile() then                     if mywep.ShieldBlock then                         if CurTime() >= self.ProjBlockGrace then                             self.ProjBlockGrace = CurTime() + 0.1                             self:AddDecimalStamina(-required_stamina)                         end                          damage = damage * mywep.BlockReduction                         self:ViewPunch(Angle(math.random(-1, 1), math.random(-1, 1), math.random(-2, 2)))                          if SERVER then                             self:BlockAttackEffect(damage)                             self:AddPoints(damage * 0.035)                         end                     end                 else                     damage = damage * mywep.BlockReduction                     self:ViewPunch(Angle(math.random(-1, 1), math.random(-1, 1), math.random(-2, 2)))                      self:AddDecimalStamina(-required_stamina)                      if SERVER then                         self:BlockAttackEffect(damage)                     end                 end             end         end          if self.PoisonDamageTakenMul then             damage = damage * self.PoisonDamageTakenMul         end          if inflictor:IsProjectile() and self.ProjDamageTakenMul then             damage = damage * self.ProjDamageTakenMul         end          if damage > 1 then             self:ViewPunch(Angle(math.random(-5, 5), math.random(-5, 5), math.random(-10, 10)))             self:EmitSound(string.format("player/pl_pain%d.wav", math.random(5, 7)))         end          if not instant then             if SERVER then                 local dmg = math.floor(damage * 0.75)                 if dmg > 0 then                     self:AddPoisonDamage(dmg, attacker)                 end             end              damage = math.ceil(damage * 0.25)         end     elseif self.GetObjectHealth then         dmginfo:SetDamageType(DMG_ACID)     else         dmginfo:SetDamageType(DMG_SLASH)            damage = math.ceil(damage * 0.75)     end      if damage ~= 0 then         attacker = attacker or self         inflictor = inflictor or attacker          dmginfo:SetDamagePosition(hitpos or self:NearestPoint(inflictor:NearestPoint(self:LocalToWorld(self:OBBCenter()))))         dmginfo:SetDamage(damage)         dmginfo:SetAttacker(attacker)         dmginfo:SetInflictor(inflictor)         self:TakeDamageInfo(dmginfo)     end end    local OldSequenceDuration = meta.SequenceDuration function meta:SequenceDuration(seqid)     return OldSequenceDuration(self, seqid) or 0 end    local OldDispatch = meta.DispatchTraceAttack function meta:DispatchTraceAttack(dmginfo, tr, dir)     if self.NoTraceAttack then         self:TakeDamageInfo(dmginfo)     else         OldDispatch(self, dmginfo, tr, dir)     end end  function meta:IsPhysicsModel(mdl)     return string.sub(self:GetClass(), 1, 12) == "prop_physics" and (not mdl or string.lower(self:GetModel()) == string.lower(mdl)) end  local string_sub = string.sub function meta:IsPhysicsProp()     local result = string_sub(self:GetClass(), 1, 12) == "prop_physics" or string_sub(self:GetClass(), 1, 12) == "func_physbox"     self.IsPhysicsProp = result and DUMMY_TRUE or DUMMY_FALSE     return result end  local HollowGroups = {     [COLLISION_GROUP_DEBRIS] = true,     [COLLISION_GROUP_DEBRIS_TRIGGER] = true,     [COLLISION_GROUP_IN_VEHICLE] = true,     [COLLISION_GROUP_WEAPON] = true,     [COLLISION_GROUP_WORLD] = true, }  function meta:ShouldBlockPlayer()     return not HollowGroups[self:GetCollisionGroup()] end  function meta:IsStaticProp()     return bit.band(self:GetCustomCollisionGroup(), ZS_COLLISIONFLAGS_HUMAN_PHASE) ~= 0 end