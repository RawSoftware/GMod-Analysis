local PANEL = {}  function PANEL:SetModel(strModelName)  if IsValid(self.Entity) then  self.Entity:Remove()  self.Entity = nil  end    if self.WElements then  for k, v in pairs( self.WElements ) do  if IsValid( v.modelEnt ) then  v.modelEnt:Remove()  v.modelEnt = nil  end  end  self.WElements = nil  end    self.Mins = nil  self.Maxs = nil  self.LookAt = nil  self.ShowWorldModel = true  self.UseOriginalModel = false  self.FixBonelessAngles = false  self.UseAutoCam = false   if not ClientsideModel then return end   self.Entity = ClientsideModel(strModelName, RENDER_GROUP_OPAQUE_ENTITY)  if not IsValid(self.Entity) then return end   self.Entity:SetNoDraw(true)   local iSeq = self.Entity:LookupSequence("walk")  if iSeq <= 0 then iSeq = self.Entity:LookupSequence("Run1") end  if iSeq <= 0 then iSeq = self.Entity:LookupSequence("walk_all") end  if iSeq <= 0 then iSeq = self.Entity:LookupSequence("WalkUnarmed_all") end  if iSeq <= 0 then iSeq = self.Entity:LookupSequence("walk_all_moderate") end  if iSeq > 0 then self.Entity:ResetSequence(iSeq) end end  function PANEL:SetUseAutoCam( bool )  self.UseAutoCam = bool end    function PANEL:AutoCam()   local zoom = 0.8    if IsValid(self.Entity) then  local mins, maxs = self.Entity:GetRenderBounds()  local center = (mins + maxs) / 2  local center_local = self.Entity:LocalToWorld( center )    local cam_pos = mins:Distance(maxs) * Vector( zoom or 0.5, 0.5, 0.5)  cam_pos.x = math.max( cam_pos.x, maxs.x * 1.75, maxs.y * 1.75, maxs.z * 1.75 )    self:SetCamPos( cam_pos )  self:SetLookAt( center_local )    if self.UseOriginalModel then return end    if self.WElements then    if not self.Mins and not self.Maxs and not self.LookAt then    local has_worldmodel = true  if self.ShowWorldModel == false then  has_worldmodel = false  end    local count = 0   for k, v in pairs( self.WElements ) do  if v and IsValid( v.modelEnt ) then  count = count + 1  local mins2, maxs2 = v.modelEnt:GetRenderBounds()   mins2, maxs2 = mins2 * v.size,  maxs2 * v.size  mins2, maxs2 = mins2 + v.pos,  maxs2 + v.pos    center = center + (mins2 + maxs2) / 2    mins.x, mins.y, mins.z = math.min( mins.x, mins2.x ), math.min( mins.y, mins2.y ), math.min( mins.z, mins2.z )  maxs.x, maxs.y, maxs.z = math.max( maxs.x, maxs2.x ), math.max( maxs.y, maxs2.y ), math.max( maxs.z, maxs.z )  end  end  if count >= 1 then  self.LookAt = center / ( count + 1 )    self.Mins = mins  self.Maxs = maxs  end  end              if not self.LookAt then return end    local look_at = self.Entity:LocalToWorld( self.LookAt )  look_at.z = center_local.z  local dist = self.Mins:Distance(self.Maxs)    cam_pos = Vector( dist * ( zoom or 0.5 ), dist * 0.5, look_at.z + 10 )  cam_pos.x = math.max( cam_pos.x, self.Maxs.x * 1.75)    self:SetCamPos( cam_pos )  self:SetLookAt( look_at )    end  end end  function PANEL:SetupSCK( swep_tab )    if !swep_tab then return end  if !swep_tab.WElements then return end  if !IsValid(self.Entity) then return end    self.WElements = table.FullCopy( swep_tab.WElements )    local count = 0  local last_model    for k, v in pairs( self.WElements ) do    count = count + 1    if (v.type == "Model" and v.model and v.model != "" and (!IsValid(v.modelEnt) or v.createdModel != v.model) and  string.find(v.model, ".mdl") and file.Exists (v.model, "GAME") ) then   v.modelEnt = ClientsideModel(v.model, RENDER_GROUP_VIEW_MODEL_OPAQUE)  if IsValid(v.modelEnt) then  v.modelEnt:SetPos(self.Entity:GetPos())  v.modelEnt:SetAngles(self.Entity:GetAngles())  v.modelEnt:SetParent(self.Entity)  v.modelEnt:SetNoDraw(true)  v.createdModel = v.model  last_model = ""..v.model..""  else  v.modelEnt = nil  end   elseif (v.type == "Sprite" and v.sprite and v.sprite != "" and (!v.spriteMaterial or v.createdSprite != v.sprite)  and file.Exists ("materials/"..v.sprite..".vmt", "GAME")) then   local name = v.sprite.."-"  local params = { ["$basetexture"] = v.sprite }   local tocheck = { "nocull", "additive", "vertexalpha", "vertexcolor", "ignorez" }  for i, j in pairs( tocheck ) do  if (v[j]) then  params["$"..j] = 1  name = name.."1"  else  name = name.."0"  end  end   v.createdSprite = v.sprite  v.spriteMaterial = CreateMaterial(name,"UnlitGeneric",params)   end  end        if count == 1 and last_model == swep_tab.WorldModel then  self.UseOriginalModel = true  else  self.ShowWorldModel = swep_tab.ShowWorldModel    local bone = self.Entity:LookupBone( "ValveBiped.Bip01_R_Hand" )    if not bone then  bone = self.Entity:LookupBone( "ValveBiped.Bip01_L_Hand" )  end     if not bone then  self.FixBonelessAngles = true  end    end  end  PANEL.wRenderOrder = nil function PANEL:DrawSCKModels()    if (!self.WElements) then return end  if !IsValid(self.Entity) then return end  if self.UseOriginalModel then return end   if (!self.wRenderOrder) then   self.wRenderOrder = {}   for k, v in pairs( self.WElements ) do  if (v.type == "Model") then  table.insert(self.wRenderOrder, 1, k)  elseif (v.type == "Sprite" or v.type == "Quad") then  table.insert(self.wRenderOrder, k)  end  end   end   bone_ent = self.Entity   for k, name in pairs( self.wRenderOrder ) do   local v = self.WElements[name]  if (!v) then self.wRenderOrder = nil break end  if (v.hide) then continue end   local pos, ang   pos, ang = self:GetBoneOrientation( self.WElements, v, bone_ent, "ValveBiped.Bip01_R_Hand" )   if (!pos) then continue end   local model = v.modelEnt  local sprite = v.spriteMaterial   if (v.type == "Model" and IsValid(model)) then   model:SetPos(pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z )  ang:RotateAroundAxis(ang:Up(), v.angle.y)  ang:RotateAroundAxis(ang:Right(), v.angle.p)  ang:RotateAroundAxis(ang:Forward(), v.angle.r)   model:SetAngles(ang)    local matrix = Matrix()  matrix:Scale(v.size)  model:EnableMatrix( "RenderMultiply", matrix )   if (v.material == "") then  model:SetMaterial("")  elseif (model:GetMaterial() != v.material) then  model:SetMaterial( v.material )  end   if (v.skin and v.skin != model:GetSkin()) then  model:SetSkin(v.skin)  end   if (v.bodygroup) then  for k, v in ipairs( v.bodygroup ) do  if (model:GetBodygroup(k) != v) then  model:SetBodygroup(k, v)  end  end  end   if (v.surpresslightning) then  render.SuppressEngineLighting(true)  end   render.SetColorModulation(v.color.r/255, v.color.g/255, v.color.b/255)  render.SetBlend(v.color.a/255)  model:DrawModel()  render.SetBlend(1)  render.SetColorModulation(1, 1, 1)   if (v.surpresslightning) then  render.SuppressEngineLighting(false)  end   elseif (v.type == "Sprite" and sprite) then   local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z  render.SetMaterial(sprite)  render.DrawSprite(drawpos, v.size.x, v.size.y, v.color)   elseif (v.type == "Quad" and v.draw_func) then   local drawpos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z  ang:RotateAroundAxis(ang:Up(), v.angle.y)  ang:RotateAroundAxis(ang:Right(), v.angle.p)  ang:RotateAroundAxis(ang:Forward(), v.angle.r)   cam.Start3D2D(drawpos, ang, v.size)  v.draw_func( self )  cam.End3D2D()   end   end   end  function PANEL:GetBoneOrientation( basetab, tab, ent, bone_override )   local bone, pos, ang  if (tab.rel and tab.rel != "") then   local v = basetab[tab.rel]   if (!v) then return end   pos, ang = self:GetBoneOrientation( basetab, v, ent )   if (!pos) then return end   pos = pos + ang:Forward() * v.pos.x + ang:Right() * v.pos.y + ang:Up() * v.pos.z  ang:RotateAroundAxis(ang:Up(), v.angle.y)  ang:RotateAroundAxis(ang:Right(), v.angle.p)  ang:RotateAroundAxis(ang:Forward(), v.angle.r)   else   bone = ent:LookupBone(bone_override or tab.bone)   if !bone then   bone = ent:LookupBone("ValveBiped.Bip01_L_Hand")  end     if !bone then   bone = 0  end   pos, ang = Vector(0,0,0), Angle(0,0,0)  local m = ent:GetBoneMatrix(bone)  if (m) then  pos, ang = m:GetTranslation(), m:GetAngles()  end   end   return pos, ang end  function PANEL:LayoutEntity( Entity )    if ( self.bAnimated ) then  self:RunAnimation()  end    local ang = Angle( 0, RealTime() * 10 % 360, 0 )    if self.FixBonelessAngles then  ang.p = 90  end    Entity:SetAngles( ang )   if self.UseAutoCam then  self:AutoCam()  end   end  function PANEL:DrawModel()   local curparent = self  local rightx = self:GetWide()  local leftx = 0  local topy = 0  local bottomy = self:GetTall()  local previous = curparent  while( curparent:GetParent() != nil ) do  curparent = curparent:GetParent()  local x, y = previous:GetPos()  topy = math.Max( y, topy + y )  leftx = math.Max( x, leftx + x )  bottomy = math.Min( y + previous:GetTall(), bottomy + y )  rightx = math.Min( x + previous:GetWide(), rightx + x )  previous = curparent  end  render.SetScissorRect( leftx, topy, rightx, bottomy, true )   local ret = self:PreDrawModel( self.Entity )  if ( ret != false ) then  if self.ShowWorldModel == false then render.SetBlend(0) end  self.Entity:DrawModel()  if self.ShowWorldModel == false then render.SetBlend(1) end   self:DrawSCKModels()  self:PostDrawModel( self.Entity )  end   render.SetScissorRect( 0, 0, 0, 0, false )  end  function PANEL:OnRemove()  if ( IsValid( self.Entity ) ) then  self.Entity:Remove()  end  if self.WElements then  for k, v in pairs( self.WElements ) do  if IsValid( v.modelEnt ) then  v.modelEnt:Remove()  v.modelEnt = nil  end  end  self.WElements = nil  end end  vgui.Register("DModelPanelEx", PANEL, "DModelPanel") 