include("shared.lua")  function ENT:Initialize()  self.TrailPositions = {}  self.LastDist = Vector(0)  self.AmbientSound = CreateSound(self, ")ambient/levels/citadel/extract_loop1.wav")   local enty = self  hook.Add("CreateMove", tostring(enty), function(cmd)  if not IsValid(enty) then return end  if enty:GetOwner() ~= MySelf then return end   local buttons = cmd:GetButtons()   cmd:ClearMovement()   if bit.band(buttons, IN_JUMP) ~= 0 then  buttons = buttons - IN_JUMP  buttons = buttons + IN_BULLRUSH  end       if bit.band(buttons, IN_ATTACK) ~= 0 then  buttons = buttons - IN_ATTACK  end   cmd:SetButtons(buttons)  end)  hook.Add("ShouldDrawLocalPlayer", tostring(enty), function(pl)  if not IsValid(enty) then return end  if enty:GetOwner() ~= MySelf then return end   return true  end)  hook.Add("CalcView", tostring(enty), function(pl, origin, angles, fov, znear, zfar)  if not IsValid(enty) then return end  if enty:GetOwner() ~= pl then return end   return {origin = GAMEMODE.ZombieThirdPerson and enty:GetThirdPersonCameraPos(enty:GetShootPos(), angles) or enty:GetShootPos()}  end) end  function ENT:Think()  local mypos = self:GetShootPos()   if self.LastDist:DistToSqr(mypos) > 25 then  self.LastDist = mypos  table.insert(self.TrailPositions, 1, mypos)  if self.TrailPositions[60] then  table.remove(self.TrailPositions, 60)  end  elseif self:GetVelocity():LengthSqr() < 900  then  table.remove(self.TrailPositions, #self.TrailPositions)  end   local dist = 0  for i=1, #self.TrailPositions do  if self.TrailPositions[i]:DistToSqr(mypos) > dist then  self:SetRenderBoundsWS(self.TrailPositions[i], mypos, Vector(16, 16, 16))  dist = self.TrailPositions[i]:DistToSqr(mypos)  end  end   self.AmbientSound:PlayEx(1, 115) end  function ENT:OnRemove()  hook.Remove("CreateMove", tostring(self))  hook.Remove("ShouldDrawLocalPlayer", tostring(self))  hook.Remove("CalcView", tostring(self))   self.AmbientSound:Stop() end  local matTrail = Material("trails/laser") local colTrail = Color(0, 180, 255) local colEye = Color(0, 180, 255, 255) local matGlow = Material("sprites/light_glow02_add") local matEye = Material("effects/blueflare1") local matEye2 = Material("effects/fluttercore") local vector_origin = vector_origin  ENT.NextEmit = 0  function ENT:Draw()         local owner = self:GetOwner()  if not owner:IsValid() then return end  local pos = self:GetShootPos()   if CurTime() >= self.NextEmit then  self.NextEmit = CurTime() + 0.02  local emitter = ParticleEmitter(pos)  emitter:SetNearClip(16, 24)   local particle = emitter:Add("effects/blueflare1", pos + VectorRand():GetNormalized() * math.random(15))  particle:SetDieTime(0.8)  particle:SetStartSize(math.Rand(3, 5))  particle:SetEndSize(0)  local col = math.random(2) == 1 and color_white or Color(0, 180, 255)  particle:SetColor(col.r, col.g, col.b)  particle:SetGravity(Vector(0,0,-120))  particle:SetRoll(math.Rand(0, 360))   emitter:Finish() emitter = nil collectgarbage("step", 64)  end   if self:GetNextTeleport() ~= 0 then  local pos2 = self:GetPos() - Vector(0, 0, owner:KeyDown(IN_DUCK) and 0 or 36)  local emitter = ParticleEmitter(pos2)  emitter:SetNearClip(16, 24)   for i=1,4 do  local particle = emitter:Add("effects/blueflare1", pos2 + Vector(math.Rand(-16, 16), math.Rand(-16, 16), 0))  particle:SetDieTime(0.3)  particle:SetStartSize(math.Rand(5, 7))  particle:SetEndSize(3)  local col = math.random(2) == 1 and Color(0, 0, 255) or Color(0, 180, 255)  particle:SetColor(col.r, col.g, col.b)  particle:SetVelocity(Vector(0, 0, 300))  particle:SetRoll(math.Rand(0, 360))  end   emitter:Finish() emitter = nil collectgarbage("step", 64)  end   if MySelf ~= owner or (MySelf == owner and GAMEMODE.ZombieThirdPerson) then  render.SetMaterial(matGlow)  local size = math.abs(math.sin(CurTime() * 3) * 40 * math.Rand(0, 1))  render.DrawSprite(pos, 50 + size, 50 + size, Color(0, 180, 255, 200))  local aimvec = owner:GetAimVector()  local aimright = aimvec:Angle():Right()  render.SetMaterial(matEye)  render.DrawSprite(pos + aimvec * 5 + aimright * 3, 8, 8, colEye)  render.DrawSprite(pos + aimvec * 5 + aimright * -3, 8, 8, colEye)  render.DrawSprite(pos + aimvec * 5 + aimright * 3, 2, 20, colEye)  render.DrawSprite(pos + aimvec * 5 + aimright * -3, 2, 20, colEye)   render.SetMaterial(matTrail)  for i=1, #self.TrailPositions do  if self.TrailPositions[i+1] then  colTrail.a = 255 - 255 * (i/#self.TrailPositions)   render.DrawBeam(self.TrailPositions[i], self.TrailPositions[i+1], 20, 1, 0, colTrail)  end  end  end end 