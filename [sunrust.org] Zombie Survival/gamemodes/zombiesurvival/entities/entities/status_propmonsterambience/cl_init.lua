include("shared.lua")  ENT.RenderGroup = RENDERGROUP_TRANSLUCENT  ENT.NextEmit = 0  local vec_rand = VectorRand local math_random = math.random  local col_glow = Color( 35, 250, 10, 255 )  ENT.VOX = {  "armor_gone",  "automedic_on",  "biohazard_detected",  "bleeding_stopped",  "biohazard_detected",  "major_lacerations",  "blood_loss",  "blood_toxins",  "chemical_detected",  "evacuate_area",  "health_critical",  "health_dropping",  "heat_damage",  "hev_critical_fail",  "innsuficient_medical",  "internal_bleeding",  "major_fracture",  "near_death",  "power_restored",  "powermove_overload",  "radiation_detected",  "seek_medic",  "shock_damage",  "targetting_system",  "wound_sterilized",  "bio_reading",  "hev_damage",  "torniquette_applied",  "voice_on" }  ENT.Intro = {  "vo/breencast/br_collaboration11.wav",    }  function ENT:Initialize()  self:DrawShadow(false)   self:SetRenderBounds( Vector( -50, -50, -50 ), Vector( 60, 60, 60 ) )      self.AmbientSound = CreateSound(self, "ambient/levels/citadel/zapper_ambient_loop1.wav")  self.AmbientSound:SetDSP(55)   self:EmitSound( self.Intro[ math_random( #self.Intro )], 100, math_random(35,45) )  end  function ENT:OnRemove()  if self.AmbientSound then  self.AmbientSound:Stop()  end end  function ENT:Think()  if self.AmbientSound then  self.AmbientSound:PlayEx(0.7, 130)  end   self.NextVOX = self.NextVOX or CurTime() + 30  self.NextVOXDelayed = self.NextVOXDelayed or 0  self.NextVOXQueue = self.NextVOXQueue or 0  self.CurVOX = self.CurVOX or 1   if self.NextVOXQueue > 0 then  if self.NextVOXDelayed < CurTime() then  self:EmitSound( "hl1/fvox/"..self.VOX[ self.CurVOX ]..".wav", 100, math_random(45,55) + self.NextVOXQueue * 5 )  self.NextVOXDelayed = CurTime() + 0.2  self.NextVOXQueue = self.NextVOXQueue - 1  end  end   self:PlayVOXDelayed()  end  function ENT:PlayVOXDelayed()  if self.NextVOX > CurTime() then return end  self.NextVOX = CurTime() + math_random(20, 25)  self.NextVOXQueue = 3  self.CurVOX = math_random( #self.VOX ) end   local vec_up = vector_up ENT.BeamTable = {     [1] = { 13, 12, 11, 10 },     [2] = { 13, 36, 37, 38, 39 },     [3] = { 13, 22, 23, 24, 25 },     [4] = { 13, 22, 23, 24, 25 },     [5] = { 13, 14, 15, 16, 17 }, }  ENT.BeamTableHand = {  [1] = { "dummy1", "dummy1+" },  [2] = { "dummy2", "dummy2+", "dummy2++" },  [3] = { "dummy3", "dummy3+", "dummy3++" }, }  local mat_energy = Material( "effects/tool_tracer" ) local mat_glow = Material("sprites/glow04_noz")  function ENT:Draw()   local owner = self:GetOwner()  if not self:ShouldDrawStatusEffect(owner) then return end   local pos, ang = owner:GetBonePosition( 13 )  local dir = vec_rand():GetNormal()   if pos and ang then  pos = pos - ang:Right() * 15   local bits = math_random( 6, 10 )  local dist = math_random( 25, 45 )   render.SetMaterial( mat_glow )  render.DrawSprite( pos, dist * 2, dist * 2, col_glow)   render.SetMaterial( mat_energy )   local prev_pos  for i=1, bits do  local cur_off = dir * ( i * dist / bits ) + vec_rand() * 5  local prev_off = dir * ( ( i - 1 ) * dist / bits ) + vec_rand() * 3  render.DrawBeam( pos + cur_off, pos + ( prev_pos or prev_off ), 14 - i , RealTime()*0.1, RealTime()*0.1 + 0.2, col_glow )  prev_pos = prev_off  end  end   if self.BeamTable then  for k=1, #self.BeamTable do  if self.BeamTable[k] then  for i=2, #self.BeamTable[k] do  if self.BeamTable[k][i] then  local start_pos, start_ang = owner:GetBonePosition( self.BeamTable[k][i-1] )  local pos, ang = owner:GetBonePosition( self.BeamTable[k][i] )  if start_pos and start_ang and pos and ang then   if i == 2 then  start_pos = start_pos - start_ang:Right() * 15  end   render.SetMaterial( mat_energy )  render.DrawBeam( pos + vec_rand() * i * 0.4 * ( k == 3 and 4 or 1), start_pos + vec_rand() * i * 0.4 * ( k == 3 and 4 or 1), ( k == 3 and -14 or 0 ) + 30 - i + math.sin( RealTime() * 1 ) * 5, RealTime()*0.7, RealTime()*0.7 + 0.4 + (k == 3 and 0.5 or 0) + math.cos( RealTime() * 1 )*0.1, col_glow )   local dist = math_random( 5, 10 )  render.SetMaterial( mat_glow )  render.DrawSprite( pos, dist * ( 9 - i ), dist * ( 9 - i ), col_glow)  end  end  end  end  end  end   local wep = owner:GetActiveWeapon()   if self.BeamTableHand and wep and wep.WElements then  for k=1, #self.BeamTableHand do  if self.BeamTableHand[k] then  for i=1, #self.BeamTableHand[k] do  if self.BeamTableHand[k][i] and wep.WElements[self.BeamTableHand[k][i]] and wep.WElements[self.BeamTableHand[k][i]].modelEnt then  local start_pos, start_ang  if i == 1 then  start_pos, start_ang = owner:GetBonePosition( 25 )  else  start_pos, start_ang = wep.WElements[self.BeamTableHand[k][i-1]].modelEnt:GetPos(), wep.WElements[self.BeamTableHand[k][i-1]].modelEnt:GetAngles()  end   local pos, ang = wep.WElements[self.BeamTableHand[k][i]].modelEnt:GetPos(), wep.WElements[self.BeamTableHand[k][i]].modelEnt:GetAngles()  if start_pos and start_ang and pos and ang then  render.SetMaterial( mat_energy )  render.DrawBeam( pos + vec_rand() * i * 0.4, start_pos + vec_rand() * i * 0.4, 20 - i + math.sin( RealTime() * 1 ) * 5, RealTime()*0.7, RealTime()*0.7 + 0.4 + math.cos( RealTime() * 1 )*0.1, col_glow )   local dist = math_random( 5, 10 )  render.SetMaterial( mat_glow )  render.DrawSprite( pos, dist * ( 6 - i ), dist * ( 6 - i ), col_glow)  end  end  end  end  end  end  end 