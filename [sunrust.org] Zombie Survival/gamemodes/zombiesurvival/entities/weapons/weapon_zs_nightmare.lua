AddCSLuaFile()  SWEP.PrintName = "Nightmare"  SWEP.Base = "weapon_zs_zombie" local BaseClass = baseclass.Get("weapon_zs_zombie")  SWEP.WorldModel = "models/player/charple.mdl"  SWEP.ShowWorldModel = false  SWEP.MeleeDamage = 17 SWEP.BleedDamage = 12 SWEP.SlowDownScale = 8.4 SWEP.MeleeDamageVsProps = 53 SWEP.EnfeebleDurationMul = 10 / SWEP.MeleeDamage  AccessorFuncDT(SWEP, "DarkBlock", "Bool", 10)  function SWEP:Reload()  self:SecondaryAttack() end  function SWEP:PlayAlertSound()  self:GetOwner():EmitSound("npc/barnacle/barnacle_tongue_pull"..math.random(3)..".wav") end SWEP.PlayIdleSound = SWEP.PlayAlertSound  function SWEP:PlayAttackSound()  self:EmitSound("npc/barnacle/barnacle_bark"..math.random(2)..".wav") end  function SWEP:MeleeHit(ent, trace, damage, forcescale)  if not ent:IsPlayer() then  damage = self.MeleeDamageVsProps  end   BaseClass.MeleeHit(self, ent, trace, damage, forcescale) end  function SWEP:ApplyMeleeDamage(ent, trace, damage)  if SERVER and ent:IsPlayer() then  local owner = self:GetOwner()   ent:GiveStatus("debuff_dimvision", 10, owner)   ent:AddWounds(math.ceil(damage))  ent:AddBleedDamage(self.BleedDamage, owner)  end   BaseClass.ApplyMeleeDamage(self, ent, trace, damage) end  function SWEP:SecondaryAttack() end  function SWEP:Think()  BaseClass.Think(self)   local owner = self:GetOwner()  local holdingright = owner:KeyDown(IN_ATTACK2)  local swinging = CurTime() < self:GetNextPrimaryFire() + 0.5  local dark_block = self:GetDarkBlock()   if holdingright and not swinging and not dark_block then  self:SetDarkBlock(true)  elseif (not holdingright or swinging) and dark_block then  self:SetDarkBlock(false)  end end  if not CLIENT then return end  local matRefraction = Material("refract_ring") local matGlow = Material("effects/rollerglow") local color_red = Color(155, 10, 0)  function SWEP:ViewModelDrawn()  render.ModelMaterialOverride(0)   local owner = self:GetOwner()  if owner:IsValid() and not owner.ShadowMan then  local boneindex = owner:LookupBone("valvebiped.bip01_r_hand")  if boneindex then  local pos, _ = owner:GetBonePosition(boneindex)  if pos and self:GetDarkBlock() then  local curvel = owner:GetVelocity() * 1  local emitter = ParticleEmitter(pos)  emitter:SetNearClip(24, 48)   for i=1, math.min(8, math.ceil(FrameTime() * 100)) do  local particle = emitter:Add("particle/snow", pos)  particle:SetVelocity(curvel + VectorRand():GetNormalized() * 30)  particle:SetDieTime(0.4)  particle:SetStartAlpha(150)  particle:SetEndAlpha(0)  particle:SetStartSize(1)  particle:SetEndSize(math.Rand(5, 7))  particle:SetAirResistance(30)  particle:SetColor(100, 35, 25)  end  emitter:Finish() emitter = nil collectgarbage("step", 64)   local size = 50   render.SetMaterial(matGlow)  render.DrawSprite(pos, size * 1.45, size * 1.45, color_red)  matRefraction:SetFloat("$refractamount", math.sin(0.1 * math.pi + CurTime() * 0.5) * 0.1 + 0.22)  render.SetMaterial(matRefraction)  render.UpdateRefractTexture()  render.DrawSprite(pos, size, size, color_white)  end  end  end end  local matSheet = Material("Models/Charple/Charple1_sheet") function SWEP:PreDrawViewModel(vm)  render.ModelMaterialOverride(matSheet) end  function SWEP:Initialize()  self:SCKInit() end  function SWEP:DrawWorldModel()  self:SCKWorldModel()   local owner = self:GetOwner()  if owner:IsValid() and not owner.ShadowMan then  local boneindex = owner:LookupBone("valvebiped.bip01_r_hand")  if boneindex then  local pos, _ = owner:GetBonePosition(boneindex)  if pos and self:GetDarkBlock() then  local curvel = owner:GetVelocity() * 1  local emitter = ParticleEmitter(pos)  emitter:SetNearClip(24, 48)   for i=1, math.min(8, math.ceil(FrameTime() * 100)) do  local particle = emitter:Add("particle/snow", pos)  particle:SetVelocity(curvel + VectorRand():GetNormalized() * 30)  particle:SetDieTime(0.4)  particle:SetStartAlpha(150)  particle:SetEndAlpha(0)  particle:SetStartSize(1)  particle:SetEndSize(math.Rand(5, 7))  particle:SetAirResistance(30)  particle:SetColor(100, 35, 25)  end  emitter:Finish() emitter = nil collectgarbage("step", 64)   local size = 50   render.SetMaterial(matGlow)  render.DrawSprite(pos, size * 1.45, size * 1.45, color_red)  matRefraction:SetFloat("$refractamount", math.sin(0.1 * math.pi + CurTime() * 0.5) * 0.1 + 0.22)  render.SetMaterial(matRefraction)  render.UpdateRefractTexture()  render.DrawSprite(pos, size, size, color_white)  end  end  end end  local adjustments_table = {  ["ValveBiped.Bip01_Head1"] = { add = Vector( 4, 0, 0 ), rot = Angle( 0, 0, 0 ) },  ["ValveBiped.Bip01_Neck1"] = { add = Vector( 0, 0, 0 ), rot = Angle( 0, 0, 180 ) }, }  SWEP.WElements = {     ["body"] = { type = "Model", bbp = function( ent, bc ) BONEMERGE_SHAKING(ent, bc, adjustments_table) end, model = "models/player/charple.mdl", bone = "ValveBiped.Bip01_Spine", rel = "", pos = Vector(0, 0, 0), angle = Angle(0, 0, 0), size = Vector(1, 1, 1), color = Color(255, 255, 255, 255), surpresslightning = false, material = "", skin = 0, bodygroup = {} } }  local shake_delay = 0.04 local shake_max = 4  local shake_table = {}  function BONEMERGE_SHAKING(ent, bonecount, adjustments_table)   local pl = ent:GetParent()   if pl and pl:IsValid() then   local shake = false   ent.NextShake = ent.NextShake or 0   if ent.NextShake < CurTime() then  shake = true  ent.NextShake = CurTime() + shake_delay + math.Rand(0.03, 0.05)  end   for i=0, bonecount do   local shake_vec = nil   if shake then  shake_vec = VectorRand() * math.Rand( 0, shake_max )    shake_table[i] = shake_vec  else  shake_vec = shake_table[i]  end   local name = ent:GetBoneName( i )   if not name then continue end   local bone = i  local bone_pl = pl:LookupBone( name )   if bone then   local m = ent:GetBoneMatrix( bone )   if bone_pl then   local m_pl = pl:GetBoneMatrix( bone_pl )   if m and m_pl then   m:SetTranslation( m_pl:GetTranslation() )  m:SetAngles( m_pl:GetAngles() )   if adjustments_table and adjustments_table[ name ] then   local v = adjustments_table[ name ]   if v.add then  m:Translate( v.add )  end  if v.rot then  m:Rotate( v.rot )  end  if v.sc then  m:SetScale( v.sc )  end   end   if shake_vec then  m:Translate( shake_vec )  end   ent:SetBoneMatrix( bone, m )   end  else       if i == 0 then   local root = pl:GetBoneMatrix( 0 )   if root then   m:SetTranslation( root:GetTranslation() )   if adjustments_table and adjustments_table[ name ] then   local v = adjustments_table[ name ]   if v.add then  m:Translate( v.add )  end  if v.rot then  m:Rotate( v.rot )  end  if v.sc then  m:SetScale( v.sc )  end   end    ent:SetBoneMatrix( i, m )   end   else   local m_p = ent:GetBoneMatrix( ent:GetBoneParent( i ) )  if m then   if m_p then  m:SetTranslation( m_p:GetTranslation() )  m:SetAngles( m_p:GetAngles() )   if adjustments_table and adjustments_table[ name ] then   local v = adjustments_table[ name ]   if v.add then  m:Translate( v.add )  end  if v.rot then  m:Rotate( v.rot )  end  if v.sc then  m:SetScale( v.sc )  end   end   ent:SetBoneMatrix( i, m )   else  m:SetScale( vector_origin )  ent:SetBoneMatrix( i, m )  end  end  end  end   end   end  end end