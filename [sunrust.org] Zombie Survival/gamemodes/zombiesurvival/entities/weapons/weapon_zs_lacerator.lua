AddCSLuaFile()  SWEP.Base = "weapon_zs_zombie" local BaseClass = baseclass.Get("weapon_zs_zombie")  SWEP.PrintName = "Lacerator"  SWEP.ViewModel = Model("models/weapons/v_pza.mdl") SWEP.WorldModel = ""  if CLIENT then  SWEP.ViewModelFOV = 48 end  SWEP.MeleeDelay = 0.8 SWEP.MeleeDamage = 27 SWEP.BleedDamageMul = 13 / SWEP.MeleeDamage SWEP.MeleeDamageVsProps = 20 SWEP.Primary.Delay = 1.7  SWEP.SwingAnimSpeed = 0.6  SWEP.PounceDamage = 30 SWEP.PounceDamageVsPlayerMul = 0 SWEP.PounceDamageType = DMG_IMPACT SWEP.PounceBleedDamageMul = 15 / SWEP.PounceDamage SWEP.PounceReach = 26 SWEP.PounceSize = 12 SWEP.PounceStartDelay = 0.5 SWEP.PounceDelay = 1.25 SWEP.PounceRecovery = 0.15 SWEP.PounceVelocity = 610  SWEP.Secondary.Automatic = false  SWEP.PassiveMoan = false  SWEP.NextAllowPounce = 0 function SWEP:Think()  self.BaseClass.Think(self)   local curtime = CurTime()  local owner = self:GetOwner()   if self.NextAllowJump and self.NextAllowJump <= curtime then  self.NextAllowJump = nil   owner:ResetJumpPower()  end   if self:GetPouncing() then  if owner:IsOnGround() or owner:WaterLevel() >= 2 then  self:StopPounce()  else  local dir = owner:GetAimVector()  dir.z = math.Clamp(dir.z, -0.5, 0.9)  dir:Normalize()   local traces = owner:CompensatedPenetratingMeleeTrace(self.PounceReach, self.PounceSize, owner:WorldSpaceCenter(), dir)  local damage = self:GetDamage(self:GetTracesNumPlayers(traces), self.PounceDamage)   local hit = false  for _, trace in ipairs(traces) do  if not trace.Hit then continue end   if trace.HitWorld then  if trace.HitNormal.z < 0.8 then  hit = true  self:MeleeHitWorld(trace)  end  else  local ent = trace.Entity  if ent and ent:IsValid() then  hit = true  self:MeleeHit(ent, trace, damage * (ent:IsPlayer() and self.PounceDamageVsPlayerMul or ent.PounceWeakness or 1), 1)  if SERVER and ent:IsPlayer() then  ent:GiveStatus("debuff_slow", 3, owner)  ent:AddBleedDamage(damage * self.PounceBleedDamageMul, self:GetOwner())  end  end  end  end   if SERVER and hit then  owner:EmitSound("physics/flesh/flesh_strider_impact_bullet1.wav")  owner:EmitSound("npc/fast_zombie/wake1.wav", 75, math.random(75, 80))  end   if hit then  self:StopPounce()  end  end  elseif self:GetPounceTime() > 0 and curtime >= self:GetPounceTime() then  self:StartPounce()  end   self:NextThink(curtime)  return true end  function SWEP:Move(mv)  if self:IsPouncing() or self:GetPounceTime() > 0 then  mv:SetMaxSpeed(0)  mv:SetMaxClientSpeed(0)  end end  function SWEP:PrimaryAttack()  if self:IsPouncing() or self:GetPounceTime() > 0 then return end   self.BaseClass.PrimaryAttack(self) end  function SWEP:MeleeHit(ent, trace, damage, forcescale)  if not ent:IsPlayer() and not (self:IsPouncing() or self:GetPounceTime() > 0) then  damage = self.MeleeDamageVsProps  end   self.BaseClass.MeleeHit(self, ent, trace, damage, forcescale) end   function SWEP:ApplyMeleeDamage(ent, trace, damage)  if SERVER and ent:IsPlayer() and not (self:IsPouncing() or self:GetPounceTime() > 0) then  ent:AddBleedDamage(damage * self.BleedDamageMul, self:GetOwner())  end   self.BaseClass.ApplyMeleeDamage(self, ent, trace, damage) end  function SWEP:SecondaryAttack()  if self:IsPouncing() or self:GetPounceTime() > 0 or CurTime() < self:NextAlternateAbility() then return end   if self:GetOwner():IsOnGround() then  if CurTime() < self:GetNextPrimaryFire() or CurTime() < self:GetNextSecondaryFire() or CurTime() < self.NextAllowPounce then return end   self:SetNextPrimaryFire(math.huge)  self:SetPounceTime(CurTime() + self.PounceStartDelay)   self:GetOwner():ResetJumpPower()  if SERVER then  self:GetOwner():EmitSound("npc/fast_zombie/leap1.wav", 75, math.random(75,80))  end  end end  function SWEP:StartPounce()  if self:IsPouncing() then return end   self:SetPounceTime(0)   local owner = self:GetOwner()  if owner:IsOnGround() then  self:SetPouncing(true)   self.m_ViewAngles = owner:EyeAngles()   if SERVER then  owner:EmitSound("npc/ichthyosaur/attack_growl1.wav", 75, math.random(100,116))  end   local ang = owner:EyeAngles()  ang.pitch = math.min(-20, ang.pitch)   owner:SetGroundEntity(NULL)  owner:SetVelocity((1 - 0.5 * (owner:GetLegDamage() / GAMEMODE.MaxLegDamage)) * self.PounceVelocity * ang:Forward())  owner:SetAnimation(PLAYER_JUMP)  else  self:SetNextSecondaryFire(CurTime())  self.m_ViewAngles = nil  self.NextAllowJump = CurTime()  self.NextAllowPounce = CurTime() + self.PounceDelay  self:SetNextPrimaryFire(CurTime() + self.PounceRecovery)  self:GetOwner():ResetJumpPower()  end end  function SWEP:StopPounce()  if not self:IsPouncing() then return end   self:SetPouncing(false)  self:SetNextSecondaryFire(CurTime())  self.m_ViewAngles = nil  self.NextAllowJump = CurTime() + 0.25  self.NextAllowPounce = CurTime() + self.PounceDelay  self:SetNextPrimaryFire(CurTime() + self.PounceRecovery)  self:GetOwner():ResetJumpPower() end  function SWEP:Reload()  self.BaseClass.SecondaryAttack(self) end  function SWEP:OnRemove()  self.Removing = true   local owner = self:GetOwner()  if owner and owner:IsValid() then  owner:ResetJumpPower()  end   self.BaseClass.OnRemove(self) end  function SWEP:Holster()  local owner = self:GetOwner()  if owner and owner:IsValid() then  owner:ResetJumpPower()  end   self.BaseClass.Holster(self) end  function SWEP:ResetJumpPower(power)  if self.Removing then return end   if self.NextAllowJump and CurTime() < self.NextAllowJump or self:IsPouncing() or self:GetPounceTime() > 0 then  return 1  end end  function SWEP:PlayAttackSound()  self:EmitSound("npc/antlion_guard/angry"..math.random(3)..".wav") end  function SWEP:PlayAlertSound()  self:GetOwner():EmitSound("npc/zombie/zombie_alert"..math.random(1,3)..".wav", 75, math.random(80,85)) end SWEP.PlayIdleSound = SWEP.PlayAlertSound  function SWEP:SetPounceTime(time)  self:SetDTFloat(1, time) end  function SWEP:GetPounceTime()  return self:GetDTFloat(1) end  function SWEP:SetPouncing(leaping)  self:SetDTBool(2, leaping) end  function SWEP:GetPouncing()  return self:GetDTBool(2) end SWEP.IsPouncing = SWEP.GetPouncing 