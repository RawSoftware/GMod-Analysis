include("shared.lua")  SWEP.DrawAmmo = false SWEP.DrawCrosshair = false SWEP.ViewModelFOV = 60  SWEP.Slot = 0 SWEP.SlotPos = 0  function SWEP:TranslateFOV(fov)     return GAMEMODE.FOVLerp * fov end  function SWEP:DrawWeaponSelection(x, y, w, h, alpha)     self:BaseDrawWeaponSelection(x, y, w, h, alpha) end  local scrap = Material("zombiesurvival/killicons/scrap_ammo_icon") local colBG = Color(16, 16, 16, 90) local colRed = Color(220, 0, 0, 230) local colWhite = Color(220, 220, 220, 230) function SWEP:DrawHUD()     local owner = self:GetOwner()     local screenscale = BetterScreenScale()      local wid, hei = 180 * screenscale, 64 * screenscale     local x, y = ScrW() - wid - screenscale * 128, ScrH() - hei - screenscale * 72     if owner:IsSkillActive(SKILL_SCRAPWEAPONS) and (self.Tier or 1) <= 2 then  local spare = owner:GetAmmoCount("scrap")   draw.RoundedBox(16, x, y, wid, hei, colBG)  draw.SimpleTextBlurry(spare, spare >= 1000 and "ZSHUDFont" or "ZSHUDFontBig", x + wid * 0.3, y + hei * 0.55, spare == 0 and colRed or colWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)          surface.SetMaterial(scrap)         surface.SetDrawColor(150, 150, 150, 150)         surface.DrawTexturedRect(x + wid * 0.66, y + hei * 0.12, 48 * screenscale, 48 * screenscale)     end      if GetConVar("crosshair"):GetInt() ~= 1 then return end     self:DrawCrosshairDot()      if GAMEMODE.CooldownRingDisplay then         self:DrawCooldowns()     end      local build = self.WeaponBuildup     if self.WeaponBuildup then         local yy = ScrH() - hei * 2 - screenscale * 84          local source = table.Copy(build.Colour)         if self:GetWeaponBuildup() >= 1 then             local pulse = math.abs(math.sin(CurTime() * 4))             source[1] = build.Colour[1] + pulse * 100             source[2] = build.Colour[2] + pulse * 100             source[3] = build.Colour[3] + pulse * 100         end          self:DrawWeaponBar(x + wid * 0.25 - wid/4, yy + hei * 0.2, wid, hei, source)         draw.SimpleTextBlurry(build.Name, "ZSHUDFont", x + wid * 0.5, yy + hei * 0.45, Color(unpack(source)), TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)     end      local fm = self:GetFireMode()     if self.FireModes > 1 then         local fmname = self.FireModeNames[fm + 1] or "-"         draw.SimpleTextBlurry(fmname, "ZSHUDFont", x + wid * 0.5, y + hei + 32 * screenscale, colWhite, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)     end end  function SWEP:DrawWeaponBar(x, y, wid, hei, color)     local buildup = self:GetWeaponBuildup()     local barheight = 20     local bary = y + hei * 0.6     local barwid = buildup * (wid - 12)      surface.SetDrawColor(0, 0, 0, 220)     surface.DrawRect(x, bary, wid - 8, barheight)     surface.SetDrawColor(unpack(color))     surface.DrawRect(x + 4, bary + 4, barwid, barheight - 8)     surface.SetDrawColor(100, 0, 0, 255)     surface.DrawRect(x - 12 + wid, bary - 4, 4, barheight + 8) end  local ringSize = 0 local ringSpacing = 0 local ringValDistance local cooldown local cooldownMaximum local color function SWEP:DrawCooldowns()     local screenscale = BetterScreenScale()     local ring_x = ScrW() * 0.5     local ring_y = ScrH() * 0.5      ringSize = 4 * GAMEMODE.CooldownRingSize     ringSpacing = 1 + GAMEMODE.CooldownRingSpacing     ringValDistance = (ringSpacing * (ringSize + (50 + ringSize))) * screenscale            local ringStart = (ringSpacing * (19 + GAMEMODE.CooldownRingSize)) * screenscale     local ringLength = (ringSpacing * (21 + ringSize)) * screenscale     cooldown = self:GetNextPrimaryFire() - CurTime()     cooldownMaximum = self.Primary.Delay     color = GAMEMODE.CooldownRingPrimaryColor      if cooldown ~= math.huge and cooldownMaximum ~= math.huge then         self:DrawCooldownRing(ring_x, ring_y, ringStart, ringLength, cooldown, cooldownMaximum, color, ringValDistance * -1 )     end      ringSpacing = ringSpacing * ringSpacing            ringStart = (ringSpacing * (23 + (4 * GAMEMODE.CooldownRingSize))) * screenscale     ringLength = (ringSpacing * (ringSize + (24 + ringSize))) * screenscale     cooldown = self:GetSwingEnd() - CurTime()     cooldownMaximum = self.SwingTime     color = GAMEMODE.CooldownRingSecondaryColor      if cooldown ~= math.huge and cooldownMaximum ~= math.huge then         self:DrawCooldownRing(ring_x, ring_y, ringStart, ringLength, cooldown, cooldownMaximum, color, ringValDistance )     end end  local ringTexture = surface.GetTextureID("vgui/white") function SWEP:DrawCooldownRing(x, y, ringStart, ringLength, valCurrent, valMaximum, ringColour, xValue)     if valMaximum and valCurrent > 0 and valMaximum ~= 0 then         local screenscale = BetterScreenScale()          local vertextable = {{}}         local steps = 0 + math.Round((valCurrent / valMaximum) * 36 )         local ringx = x         local ringy = y         ringstart = 19 * screenscale         ringlength = 20 * screenscale          if AngDiff then             ringx = ringx + (AngDiff.x/1.5 or 0)             ringy = ringy - (AngDiff.y/1.5 or 0)         end          local function lengthdirx(length, dir)             return length*math.cos(math.rad(dir))         end          local function lengthdiry(length, dir)             return length*math.sin(math.rad(dir))         end          surface.SetTexture( ringTexture )         surface.SetDrawColor( ringColour )          if steps > 0 then             for k=1, steps do                 vertextable = {}                 vertextable[1] = {}                 vertextable[2] = {}                 vertextable[3] = {}                 vertextable[4] = {}                 vertextable[1]["x"] = ringx+lengthdirx(ringStart,(k-1)*10-90)                 vertextable[1]["y"] = ringy+lengthdiry(ringStart,(k-1)*10-90)                 vertextable[1]["u"] = 0                 vertextable[1]["v"] = 0                 vertextable[2]["x"] = ringx+lengthdirx(ringLength,(k-1)*10-90)                 vertextable[2]["y"] = ringy+lengthdiry(ringLength,(k-1)*10-90)                 vertextable[2]["u"] = 1                 vertextable[2]["v"] = 0                 vertextable[3]["x"] = ringx+lengthdirx(ringLength,k*10-90)                 vertextable[3]["y"] = ringy+lengthdiry(ringLength,k*10-90)                 vertextable[3]["u"] = 0                 vertextable[3]["v"] = 1                 vertextable[4]["x"] = ringx+lengthdirx(ringStart,k*10-90)                 vertextable[4]["y"] = ringy+lengthdiry(ringStart,k*10-90)                 vertextable[4]["u"] = 1                 vertextable[4]["v"] = 1                 surface.DrawPoly( vertextable )             end         end          if GAMEMODE.CooldownRingValueDisplay then             draw.SimpleText(math.Round(valCurrent,1), "ZSHUDFontSmallest", x + xValue, y, ringColour, TEXT_ALIGN_CENTER, TEXT_ALIGN_CENTER)         end     end end  function SWEP:OnRemove()     self:SCKOnRemove() end  function SWEP:ViewModelDrawn()     self:SCKViewModel() end  function SWEP:PreDrawViewModel(vm)     if self.ShowViewModel == false then         render.SetBlend(0)     end end  function SWEP:PostDrawViewModel(vm)     if self.ShowViewModel == false then         render.SetBlend(1)     end end  local E_GetTable = FindMetaTable("Entity").GetTable function SWEP:DrawWorldModel()     local owner = self:GetOwner()     local owner_valid = IsValid(owner)      if not owner_valid then return end     local owner_table = E_GetTable(owner)     if FrameNumber() - (owner_table.LastDrawFrame or 0) > 30 then return end     if owner_table.ShadowMan or owner_table.SpawnProtection then return end     if GAMEMODE.NoDrawHumanWeaponsAsZombie and MySelf and MySelf:Team() == TEAM_UNDEAD and owner:Team() == TEAM_HUMAN then return end      self:SCKWorldModel() end  local ghostlerp = 0 local add_lerp = Vector(0, 0, 0) local add_angle = Angle(0, 0, 0)  function SWEP:GetViewModelPosition(pos, ang)     local owner = self:GetOwner()      if self:IsSwinging() or self:IsWinding() then         local rot = self.SwingRotation         local offset = self.SwingOffset          ang = Angle(ang.pitch, ang.yaw, ang.roll)            local power = 0         if self:IsSwinging() then             local armdelay = owner:GetMeleeSpeedMul()             local swingtime = self.SwingTime * (owner.MeleeSwingDelayMul or 1) * armdelay             local swingend = self:GetSwingEnd()             local delta = swingtime - math.Clamp(swingend - CurTime(), 0, swingtime - (self:IsHeavy() and swingtime/2 or 0))             power = CosineInterpolation(0, 1, delta / swingtime)         else             local windstart = self:GetWindStart()             local delta = math.Clamp((CurTime() - windstart) * 1, 0, 1)              power = CosineInterpolation(0, 1, delta)         end          local new_lerp = offset.x * power * ang:Right() + offset.y * power * ang:Forward() + offset.z * power * ang:Up()         local new_ang = Angle(rot.pitch * power, rot.yaw * power, rot.roll * power)          add_lerp = LerpVector(0.03, add_lerp, new_lerp)         add_angle = LerpAngle(0.05, add_angle, new_ang)          pos = pos + add_lerp          ang:RotateAroundAxis(ang:Right(), add_angle.pitch)         ang:RotateAroundAxis(ang:Up(), add_angle.yaw)         ang:RotateAroundAxis(ang:Forward(), add_angle.roll)     else         local rot = self.BlockRotation         local offset = -self.BlockOffset          ang = Angle(ang.pitch, ang.yaw, ang.roll)            local swingend = self:GetBlockEnd()         local delta = 0.3 - math.Clamp(swingend - CurTime(), 0, 0.3)         local power = CosineInterpolation(0, 1, delta / 0.3)         power = self:IsBlocking() and power or 1 - power          local new_lerp = offset.x * power * ang:Right() + offset.y * power * ang:Forward() + offset.z * power * ang:Up()         local new_ang = Angle(rot.pitch * power, rot.yaw * power, rot.roll * power)          add_lerp = LerpVector(0.13 * FrameTime() * 100, add_lerp, new_lerp)         add_angle = LerpAngle(0.05 * FrameTime() * 100, add_angle, new_ang)          pos = pos + add_lerp          ang:RotateAroundAxis(ang:Right(), add_angle.pitch)         ang:RotateAroundAxis(ang:Up(), add_angle.yaw)         ang:RotateAroundAxis(ang:Forward(), add_angle.roll)     end      if owner:GetBarricadeGhosting() then         ghostlerp = math.min(1, ghostlerp + FrameTime() * 4)     elseif ghostlerp > 0 then         ghostlerp = math.max(0, ghostlerp - FrameTime() * 5)     end      if ghostlerp > 0 then         pos = pos + 3.5 * ghostlerp * ang:Up()         ang:RotateAroundAxis(ang:Right(), -30 * ghostlerp)     end      return pos, ang end 