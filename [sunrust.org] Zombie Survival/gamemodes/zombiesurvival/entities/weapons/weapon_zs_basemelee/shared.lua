SWEP.ViewModel = "models/weapons/v_axe/v_axe.mdl" SWEP.WorldModel = "models/weapons/w_axe.mdl"  SWEP.Primary.ClipSize = -1 SWEP.Primary.DefaultClip = -1 SWEP.Primary.Automatic = true SWEP.Primary.Ammo = "none" SWEP.Primary.Delay = 1  SWEP.MeleeDamage = 30 SWEP.MeleeRange = 65 SWEP.MeleeSize = 1.5 SWEP.MeleeKnockBack = 0  SWEP.Secondary.ClipSize = 1 SWEP.Secondary.DefaultClip = 1 SWEP.Secondary.Ammo = "dummy" SWEP.Secondary.Automatic = true  SWEP.WalkSpeed = SPEED_FAST  SWEP.IsMelee = true SWEP.MeleeFlagged = false  SWEP.HoldType = "melee" SWEP.SwingHoldType = "grenade" SWEP.BlockHoldType = "revolver"  SWEP.DamageType = DMG_SLASH  SWEP.BloodDecal = "Blood" SWEP.HitDecal = "Impact.Concrete"  SWEP.HitAnim = ACT_VM_HITCENTER SWEP.MissAnim = ACT_VM_MISSCENTER  SWEP.SwingTime = 0 SWEP.SwingRotation = Angle(0, 0, 0) SWEP.SwingOffset = Vector(0, 0, 0)  SWEP.BlockRotation = Angle(0, 0, 0) SWEP.BlockOffset = Vector(0, 0, 0)  SWEP.Stability = nil SWEP.BlockReduction = nil  SWEP.BashDelay = 1 SWEP.BashMaximum = 305 SWEP.BashAdd = 160  SWEP.AllowQualityWeapons = false  SWEP.HeavyMulti = 1.55  SWEP.Weight = 4  SWEP.FireModes = 1 SWEP.FireModeNames = {"Default"} SWEP.StaminaUsage = 0.1  local MAT_FLESH = MAT_FLESH local MAT_BLOODYFLESH = MAT_BLOODYFLESH local MAT_ANTLION = MAT_ANTLION local MAT_ALIENFLESH = MAT_ALIENFLESH  AccessorFuncDT(SWEP, "DodgeEnd", "Float", 11) AccessorFuncDT(SWEP, "DodgeDir", "Vector", 11) AccessorFuncDT(SWEP, "WeaponBuildup", "Float", 20)  function SWEP:Initialize()     GAMEMODE:DoChangeDeploySpeed(self)     self:SetWeaponHoldType(self.HoldType)     self:SetWeaponSwingHoldType(self.SwingHoldType)     self:SetWeaponBlockHoldType(self.BlockHoldType)      if CLIENT then         self:SCKInit()     end end  function SWEP:SetupDataTables()     self:NetworkVar("Int", 0, "PowerCombo") end  function SWEP:SetWeaponSwingHoldType(t)     local old = self.ActivityTranslate     self:SetWeaponHoldType(t)     local new = self.ActivityTranslate     self.ActivityTranslate = old     self.ActivityTranslateSwing = new end  function SWEP:SetWeaponBlockHoldType(t)     local old = self.ActivityTranslate     self:SetWeaponHoldType(t)     local new = self.ActivityTranslate     self.ActivityTranslate = old     self.ActivityTranslateBlock = new end  function SWEP:Deploy()     gamemode.Call("WeaponDeployed", self:GetOwner(), self)     self.IdleAnimation = CurTime() + self:SequenceDuration()      if self.Stability then         local blocking = self:IsBlocking()         if blocking then             local owner = self:GetOwner()             local timesincelast = math.Clamp(self:GetBlockEnd() - CurTime(), 0, 0.5)              self:SetBlocking(false)             self:SetBlockEnd(CurTime() + (0.3 - timesincelast))              if SERVER and owner:IsSkillActive(SKILL_GUARDIAN) then                 net.Start("zs_guardian_state")                     net.WriteEntity(owner)                     net.WriteBool(false)                 net.Broadcast()             end              owner:ResetSpeed()         end     end      return true end  function SWEP:Think()     if self.IdleAnimation and self.IdleAnimation <= CurTime() then         self.IdleAnimation = nil         self:SendWeaponAnim(ACT_VM_IDLE)     end      local dodge_end = self:GetDodgeEnd()     if dodge_end ~= 0 and dodge_end < CurTime() then         self:SetDodgeEnd(0)          local owner = self:GetOwner()         local myvel = owner:GetVelocity()         local newvel = (-1 * owner:GetRight()) * math.min(myvel:Length2D(), owner:GetMaxSpeed() * 2)         newvel.z = myvel.z          hook.Remove("Move", tostring(self))     end      local owner = self:GetOwner()     local holdingleft = owner:KeyDown(IN_ATTACK)     local swinging = self:IsSwinging()     local winding = self:IsWinding()      local windend = CurTime() - self:GetWindStart() > self.Primary.Delay * 0.5     local under_heavy_stam = owner:CurrentDecimalStamina() <= self.StaminaUsage * 0.4     if winding and (not holdingleft or windend or (self.Primary.Delay < 0.55 and not self.AlwaysCanCharge) or self.NoWind or owner:GetInfo("zs_nochargeattack") == "1" or under_heavy_stam) then         self:SetHeavy(CurTime() - self:GetWindStart() > self.Primary.Delay * 0.4)         self:StopWind()         self:StartSwinging()         self:SetNextAttack()     end      if swinging and self:GetSwingEnd() <= CurTime() then         self:StopSwinging()         self:MeleeSwing()         self:SetHeavy(false)     end      local blocking = self:IsBlocking()     local holdingright = owner:KeyDown(IN_ATTACK2)     local canattack = self:GetNextPrimaryFire() - 0.3 <= CurTime()      if self.Stability then         local block_end = self:GetBlockEnd()         local timesincelast = math.Clamp(block_end - CurTime(), 0, 0.5)          if not blocking and block_end ~= 0 and block_end < CurTime() then             owner:ResetSpeed()             owner:ResetStaminaRegen()              self:SetBlockEnd(0)         end          if not self.IsDodge then             if (swinging or not canattack or not holdingright) and blocking then                 self:SetBlocking(false)                 self:SetBlockEnd(CurTime() + (0.3 - timesincelast))                  if SERVER and owner:IsSkillActive(SKILL_GUARDIAN) then                     net.Start("zs_guardian_state")                         net.WriteEntity(owner)                         net.WriteBool(false)                     net.Broadcast()                 end                  owner:ResetSpeed()                 owner:ResetStaminaRegen()             elseif (CurTime() < self:GetSwingEnd() or canattack) and holdingright and not blocking and not owner:GetBarricadeGhosting() then                 self:SetBlocking(true)                 self:SetBlockEnd(CurTime() + (0.3 - timesincelast))                  if SERVER and owner:IsSkillActive(SKILL_GUARDIAN) then                     net.Start("zs_guardian_state")                         net.WriteEntity(owner)                         net.WriteBool(true)                     net.Broadcast()                 end                  owner:ResetSpeed()                 owner:ResetStaminaRegen()                  self:OnStartBlocking()                  if self:IsSwinging() then                     self:StopSwinging()                     self:SetHeavy(false)                     self:SetNextPrimaryFire(CurTime())                 end             end         elseif self.IsDodge and holdingright then             self:Bash()         end     end end  function SWEP:GetWalkSpeed()     return self.WalkSpeed end  function SWEP:OnStartBlocking()  end  function SWEP:SecondaryAttack() end  function SWEP:Reload()     return false end  function SWEP:CanPrimaryAttack()     local owner = self:GetOwner()     if owner:IsHolding() or owner:GetBarricadeGhosting() then return false end      return self:GetNextPrimaryFire() <= CurTime() and not self:IsSwinging() and not self:IsWinding() and owner:CurrentDecimalStamina() > 0 end  function SWEP:PlaySwingSound()     self:EmitSound("weapons/iceaxe/iceaxe_swing1.wav") end  function SWEP:PlayStartSwingSound() end  function SWEP:PlayHitSound()     self:EmitSound("weapons/melee/golf club/golf_hit-0"..math.random(4)..".ogg") end  function SWEP:PlayHitFleshSound()     self:EmitSound("physics/body/body_medium_break"..math.random(2, 4)..".wav") end  function SWEP:PrimaryAttack()     if not self:CanPrimaryAttack() then return end      if self:IsBlocking() and not self.IsDodge then         self:Bash()     else         self:SetNextAttack()          if self.SwingTime == 0 then             self:MeleeSwing()         else             self:StartWinding()         end     end end  function SWEP:SetNextAttack()     local owner = self:GetOwner()     local armdelay = owner:GetMeleeSpeedMul()     local swinging = self:IsSwinging()      self:SetNextPrimaryFire(CurTime() + self.Primary.Delay * armdelay * (swinging and 0.87 or 1)) end  function SWEP:Holster()     if CurTime() >= self:GetSwingEnd() then         if CLIENT then             self:SCKHolster()         end          return true     end      return false end  function SWEP:StartSwinging()     local owner = self:GetOwner()      if self.StartSwingAnimation then         self:SendWeaponAnim(self.StartSwingAnimation)         self.IdleAnimation = CurTime() + self:SequenceDuration()     end     self:PlayStartSwingSound()      local armdelay = owner:GetMeleeSpeedMul()     self:SetSwingEnd(CurTime() + self.SwingTime * (owner.MeleeSwingDelayMul or 1) * armdelay) end  function SWEP:StartWinding()     self:SetWindStart(CurTime()) end  function SWEP:DoMeleeAttackAnim()     self:GetOwner():DoAttackEvent() end  function SWEP:TryCleaveScrap()     local owner = self:GetOwner()     local over = owner:GetAmmoCount("scrap") >= self.CleaveScrap      return over end  function SWEP:GetMeleeRange()     local owner = self:GetOwner()      local tier = self.Tier or 1     local range_mul = (owner.MeleeRangeMul or 1) + (tier <= 2 and owner:IsSkillActive(SKILL_SCRAPWEAPONS) and 0.09 or 0)      return (self.MeleeRange * range_mul) + (owner.MeleeRangeFlat or 1) end  local charge_trinket_cooldowns = {} function SWEP:DoSpecialTrinketCharges()     if SERVER and (self.Tier or 1) <= 5 then         local owner = self:GetOwner()          if not charge_trinket_cooldowns[owner] or charge_trinket_cooldowns[owner] < CurTime() then             local blade_charge_eff = owner.BladeChargeEff or 0             if blade_charge_eff > 0 then                 local velocity = math.min(1000, 1000 / self.Primary.Delay)                  self:ShootProjectile(self.MeleeDamage * blade_charge_eff, 0, "projectile_charge_blade", velocity,                     function(angle) angle:RotateAroundAxis(angle:Up(), 90) end,                     function(angle) angle:RotateAroundAxis(angle:Up(), 22) end                 )                 self:ShootProjectile(self.MeleeDamage * blade_charge_eff, 0, "projectile_charge_blade", velocity,                     function(angle) angle:RotateAroundAxis(angle:Up(), 90) end                 )                 self:ShootProjectile(self.MeleeDamage * blade_charge_eff, 0, "projectile_charge_blade", velocity,                     function(angle) angle:RotateAroundAxis(angle:Up(), 90) end,                     function(angle) angle:RotateAroundAxis(angle:Up(), -22) end                 )                  charge_trinket_cooldowns[owner] = CurTime() + 5             end         end     end end  local scaled_trinket_effect = {     [1] = 1,     [2] = 5/6,     [3] = 4/6,     [4] = 4/6,     [5] = 3/6,     [6] = 1/6 }  local do_stamina_use = false function SWEP:MeleeSwing()     local owner = self:GetOwner()      self:DoMeleeAttackAnim()      local heavy = self:IsHeavy()     local tier = self.Tier or 1      local scrap_count = owner:GetAmmoCount("scrap")      local bonus = scaled_trinket_effect[tier] or 1/6      local sharp  =   owner.MeleeScalingDamageMul and                             owner.MeleeScalingDamageMul > 0 and (owner.MeleeScalingDamageMul * bonus) or                             0     local scrap_weapons = tier <= 2 and owner:IsSkillActive(SKILL_SCRAPWEAPONS)     local damagemultiplier = (owner:Team() == TEAM_HUMAN and owner.MeleeDamageMultiplier or 1)                             + sharp                             + (scrap_weapons and scrap_count >= 1 and 0.19 or 0)      damagemultiplier = damagemultiplier * (scrap_weapons and scrap_count <= 0 and 0.33 or 1)      if heavy then         damagemultiplier = damagemultiplier * self.HeavyMulti         if owner:GetInfo("zs_noheavyviewpunch") == "0" and IsFirstTimePredicted() then             local r = math.Rand(0.8, 1) * 3             owner:ViewPunch(Angle(-1 * r, 0, r * (math.random(2) == 1 and -1 or 1)))         end          self:OnHeavy()         self:DoSpecialTrinketCharges()     end      damagemultiplier = self:BeforeSwing(damagemultiplier)     do_stamina_use = false      if self.WrenchRepairTool then         GAMEMODE:SetMeleeButRepairFlag(true)     end      local can_cleave = not self.CleaveScrap or self:TryCleaveScrap()     local tr =             can_cleave and self.CustomCleave and self:CustomCleave() or             can_cleave and self.Cleave       and owner:CompensatedPenetratingMeleeTrace(self:GetMeleeRange(), self.MeleeSize, nil, nil, nil, true) or                                                  owner:CompensatedMeleeTrace(self:GetMeleeRange(), self.MeleeSize, nil, nil, nil, nil, true)      if self.WrenchRepairTool then         GAMEMODE:SetMeleeButRepairFlag()     end      local cleave_trace = can_cleave and (self.Cleave or self.CustomCleave)     if cleave_trace then         self:ResolveCleaveSwing(tr, damagemultiplier)     else         self:ResolveSwing(tr, damagemultiplier)     end      if self.StaminaUsage > 0 then         local stam_multiplier = (do_stamina_use and 1.2 or (self.OnlyOnHit and 0 or 1.7)) * (cleave_trace and 1.1 or 0.95)          owner:AddDecimalStamina(-self.StaminaUsage * (heavy and 1.35 or 1) * owner:GetMeleeStaminaUseMul() * stam_multiplier)     end     self:AfterSwing() end  function SWEP:OnHeavy()  end  function SWEP:AfterSwing() end  function SWEP:BeforeSwing(damagemultiplier)     return damagemultiplier end  function SWEP:ResolveSwing(tr, damagemultiplier)     local owner = self:GetOwner()      if not tr.Hit then         if self.MissAnim then             self:SendWeaponAnim(self.MissAnim)         end         self.IdleAnimation = CurTime() + self:SequenceDuration()         self:PlaySwingSound()          if owner.MeleePowerAttackMul and owner.MeleePowerAttackMul > 1 then             self:SetPowerCombo(0)         end          if self.PostOnMeleeMiss then self:PostOnMeleeMiss(tr) end          return     end      local hitent = tr.Entity     local hitflesh = tr.MatType == MAT_FLESH or tr.MatType == MAT_BLOODYFLESH or tr.MatType == MAT_ANTLION or tr.MatType == MAT_ALIENFLESH      if self.HitAnim then         self:SendWeaponAnim(self.HitAnim)     end     self.IdleAnimation = CurTime() + self:SequenceDuration()      if hitflesh then         util.Decal(self.BloodDecal, tr.HitPos + tr.HitNormal, tr.HitPos - tr.HitNormal)         self:PlayHitFleshSound()          if SERVER then             self:ServerHitFleshEffects(hitent, tr, damagemultiplier)         end          if not self.NoHitSoundFlesh then             self:PlayHitSound()         end          do_stamina_use = true     else                   self:PlayHitSound()     end      if self.OnMeleeHit and self:OnMeleeHit(hitent, hitflesh, tr) then         return     end      if SERVER then         self:ServerMeleeHitEntity(tr, hitent, damagemultiplier)     end      self:MeleeHitEntity(tr, hitent, damagemultiplier)      if self.PostOnMeleeHit then self:PostOnMeleeHit(hitent, hitflesh, tr) end      if SERVER then         self:ServerMeleePostHitEntity(tr, hitent, damagemultiplier)     end end  function SWEP:GetTracesNumPlayers(traces)     local numplayers = 0      local ent     for _, trace in pairs(traces) do         ent = trace.Entity         if ent and ent:IsValidPlayer() then             numplayers = numplayers + 1         end     end      return numplayers end  function SWEP:ResolveCleaveSwing(tr, damagemultiplier)     self:SendWeaponAnim(self.MissAnim)     self.IdleAnimation = CurTime() + self:SequenceDuration()      local owner = self:GetOwner()     local hit, ent     local base_damage = self.GetDamage and self:GetDamage(tr) or self.MeleeDamage     local damage = base_damage      table.SortByMember(tr, "Fraction")      local dmgs = 0     for _, trace in ipairs(tr) do         if not trace.Hit then continue end         if damage <= base_damage * 0.2 then break end          ent = trace.Entity          hit = true          local hitflesh = trace.MatType == MAT_FLESH or trace.MatType == MAT_BLOODYFLESH or trace.MatType == MAT_ANTLION or trace.MatType == MAT_ALIENFLESH          if hitflesh then             util.Decal(self.BloodDecal, trace.HitPos + trace.HitNormal, trace.HitPos - trace.HitNormal)              if SERVER then                 self:ServerHitFleshEffects(ent, trace, damagemultiplier)             end          end          if ent and ent:IsValid() then             if self.OnMeleeHit and self:OnMeleeHit(ent, hitflesh, trace) then                 continue             end              if not do_stamina_use then                 do_stamina_use = true             end              if SERVER then                 self:ServerMeleeHitEntity(trace, ent, damagemultiplier)             end              if dmgs >= 1 then                 owner.Cleaving = true             end             self:MeleeHitEntity(trace, ent, damagemultiplier, damage)              damage = damage * (self.CleaveTaper or 0.5)             dmgs = dmgs + 1              if SERVER then                 self:ServerMeleePostHitEntity(trace, ent, damagemultiplier)             end         end          if self.PostOnMeleeHit then self:PostOnMeleeHit(ent, hitflesh, trace) end     end      owner.Cleaving = false      if hit then         self:PlayHitSound()          if SERVER and dmgs >= 2 and self.CleaveScrap then             owner:RemoveAmmo(self.CleaveScrap, "scrap")         end     else         self:PlaySwingSound()          if owner.MeleePowerAttackMul and owner.MeleePowerAttackMul > 1 then             self:SetPowerCombo(0)         end     end end  function SWEP:MeleeHitEntity(tr, hitent, damagemultiplier, damage)     if not IsFirstTimePredicted() then return end      if self.MeleeFlagged then self.IsMelee = true end      local owner = self:GetOwner()     local tier  = self.Tier or 1     local scrap_weapons = tier <= 2 and owner:IsSkillActive(SKILL_SCRAPWEAPONS)      if owner:IsSkillActive(SKILL_MASTERCHEF) and self.Culinary then         damagemultiplier = damagemultiplier * 0.9     end      local ignore_region = CLIENT or self.RespectHitGroup or not hitent:IsPlayer()      damage = (damage or self.MeleeDamage) * damagemultiplier * (         ignore_region and 1 or hitent:DetermineMeleeRegion(tr.HitPos, self, owner)     )      local dmginfo = DamageInfo()     dmginfo:SetDamagePosition(tr.HitPos)     dmginfo:SetAttacker(owner)     dmginfo:SetInflictor(self)     dmginfo:SetDamageType(self.DamageType)     dmginfo:SetDamage(damage)     dmginfo:SetDamageForce(math.min(self.MeleeDamage, 50) * 50 * owner:GetAimVector())      local vel     if hitent:IsPlayer() then         self:PlayerHitUtil(owner, damage, hitent, dmginfo)          if scrap_weapons and owner:GetAmmoCount("scrap") >= 1 then             owner.ScrapUsage = (owner.ScrapUsage or 0) + self.Primary.Delay              if owner.ScrapUsage >= 2.4 then                 owner.ScrapUsage = owner.ScrapUsage - 2.4                 owner:RemoveAmmo(1, "scrap")             end         end          if SERVER then             hitent:SetLastHitGroup(tr.HitGroup)             if tr.HitGroup == HITGROUP_HEAD then                 hitent:SetWasHitInHead()             end              if hitent:WouldDieFrom(damage, tr.HitPos) then                 dmginfo:SetDamageForce(math.min(self.MeleeDamage, 50) * 400 * owner:GetAimVector())             end         end          vel = hitent:GetVelocity()     else         if owner.MeleePowerAttackMul and owner.MeleePowerAttackMul > 1 then             self:SetPowerCombo(0)         end     end      self:PostHitUtil(owner, hitent, dmginfo, tr, vel) end  function SWEP:PlayerHitUtil(owner, damage, hitent, dmginfo)     if owner.MeleePowerAttackMul and owner.MeleePowerAttackMul > 1 then         damage = damage + damage * (owner.MeleePowerAttackMul - 1) * (self:GetPowerCombo()/4)         dmginfo:SetDamage(damage)          self:SetPowerCombo(self:GetPowerCombo() + 1)          if self:GetPowerCombo() >= 4 then             self:SetPowerCombo(0)             if SERVER then                 local pitch = math.Clamp(math.random(90, 110) + 15 * (1 - damage/45), 50 , 200)                 owner:EmitSound("npc/strider/strider_skewer1.wav", 75, pitch)             end         end     end      hitent:MeleeViewPunch(damage * (self.MeleeViewPunchScale or 1) * 0.5)     if hitent:IsHeadcrab() then         damage = damage + 15         dmginfo:SetDamage(damage)     end end  function SWEP:PostHitUtil(owner, hitent, dmginfo, tr, vel)     if self.PointsMultiplier then         POINTSMULTIPLIER = self.PointsMultiplier     end     hitent:DispatchTraceAttack(dmginfo, tr, owner:GetAimVector())     if self.PointsMultiplier then         POINTSMULTIPLIER = nil     end      if vel then         hitent:SetLocalVelocity(vel)     end            if hitent:IsPlayer() then         local knockback = self.MeleeKnockBack * (owner.MeleeKnockbackMultiplier or 1)         if knockback > 0 then             hitent:ThrowFromPositionSetZ(tr.StartPos, knockback, nil, true)         end          if owner.MeleeLegDamageAdd and owner.MeleeLegDamageAdd > 0 then             hitent:AddLegDamage(owner.MeleeLegDamageAdd)         end     end      local effectdata = EffectData()     effectdata:SetOrigin(tr.HitPos)     effectdata:SetStart(tr.StartPos)     effectdata:SetNormal(tr.HitNormal)     util.Effect("RagdollImpact", effectdata)     if not tr.HitSky then         effectdata:SetSurfaceProp(tr.SurfaceProps)         effectdata:SetDamageType(self.DamageType)         effectdata:SetHitBox(tr.HitBox)         effectdata:SetEntity(hitent)         util.Effect("Impact", effectdata)     end      if self.MeleeFlagged then self.IsMelee = nil end end  SWEP.Speed = 490 SWEP.SlowDownThreshold = 0.15  local function dodge(enty)     return function(pl, move)         if not IsValid(enty) then return end         if pl ~= enty:GetOwner() then return end          local state_end = enty:GetDodgeEnd()         local delta = state_end - CurTime()         if delta > 0 then             local vec = enty:GetDodgeDir() or -1 * pl:GetForward()              local basespeed = enty.Speed * math.Clamp(delta / enty.SlowDownThreshold, 0.2, 1)             local vel = math.max(pl:GetMaxSpeed(), basespeed) * vec             vel.z = math.Clamp(move:GetVelocity().z, -800, 256)              pl:SetGroundEntity(NULL)             move:SetVelocity(vel)         end     end end  function SWEP:CalcDodgeDir()     local owner = self:GetOwner()     local dir = Vector(0, 0, 0)     if owner:KeyDown(IN_BACK) then dir = dir - owner:GetForward() end     if owner:KeyDown(IN_MOVERIGHT) then dir = dir + owner:GetRight() end     if owner:KeyDown(IN_MOVELEFT) then dir = dir - owner:GetRight() end     dir:Normalize()     if dir == vector_origin then dir = -1 * owner:GetForward() end      return dir end  function SWEP:Dodge()     local owner = self:GetOwner()     local consume = self.IsDodge * (owner.DodgeStaminaMul or 1)     if owner:CurrentDecimalStamina() <= (consume * 0.33) then return end      local impetus = owner:IsSkillActive(SKILL_IMPETUS)     local armdelay = owner:GetMeleeSpeedMul()     self:SetBashEnd(CurTime() + self.BashDelay * armdelay * (impetus and 2 or 1))      owner:AddDecimalStamina(-consume)      if IsFirstTimePredicted() then         owner:ViewPunch(Angle(0, 0, self:GetDodgeDir() * -8))          if CLIENT then             owner:EmitSound("npc/zombie_poison/pz_right_foot1.wav", 65, 170)         end          hook.Add("Move", tostring(self), dodge(self))     end      local dodge_time = 0.33 * (owner.DodgeDurationMul or 1)      self:SetDodgeEnd(CurTime() + dodge_time)     self:SetDodgeDir(self:CalcDodgeDir())      owner.IFrames = CurTime() + dodge_time end  function SWEP:Bash()     if CurTime() < self:GetBashEnd() then return end      if self.IsDodge then         self:Dodge()         return     end      local owner = self:GetOwner()     local consume = (self.BashConsume or 1) * 0.25     local parry = not self.ShieldBlock and owner:IsSkillActive(SKILL_PARRY)     consume = (parry and 2 or 1) * consume     if owner:CurrentDecimalStamina() <= consume then return end      owner:AddDecimalStamina(-consume)      local impetus = owner:IsSkillActive(SKILL_IMPETUS)     local armdelay = owner:GetMeleeSpeedMul()     self:SetBashEnd(CurTime() + self.BashDelay * armdelay * (impetus and 2 or 1))     if self.MissAnim then         self:SendWeaponAnim(self.MissAnim)     end     self.IdleAnimation = CurTime() + self:SequenceDuration()     self:EmitSound("weapons/iceaxe/iceaxe_swing1.wav", 75, math.random(43, 46))      owner:MeleeViewPunch(15)     owner:AnimRestartGesture(GESTURE_SLOT_ATTACK_AND_RELOAD, ACT_GMOD_GESTURE_MELEE_SHOVE_2HAND, true)      local tr = owner:CompensatedMeleeTrace(61, math.min(12, self.MeleeSize * 3))      if tr.Hit and tr.Entity:IsValidLivingZombie() then         local hitent = tr.Entity         hitent:EmitSound("npc/antlion_guard/shove1.wav", 75, 245, 1, CHAN_WEAPON + 1)          local bash_return = self:BashEffect(tr, hitent)          if not bash_return or (bash_return and not bash_return.no_knock) then             local knockback = math.min(self.BashMaximum, self.MeleeKnockBack + self.BashAdd) * (owner.BashForceMul or 1) * (owner.MeleeKnockbackMultiplier or 1)             hitent:ThrowFromPositionSetZ(tr.StartPos, knockback, nil, true)             hitent:AddLegDamage(7 * (owner.BashForceMul or 1))         end          if impetus then             hitent.BashedRecently = CurTime() + 3             hitent.BashedWeapon = self         end          if owner.BlockBashDamage > 0 and self.ShieldBlock then             hitent:TakeSpecialDamage(owner.BlockBashDamage, DMG_SLASH, owner, self)         end          if parry then             local wep = hitent:GetActiveWeapon()             if wep and wep:IsValid() then                 local valid_swinger = wep.GetSlowSwingEnd or wep.GetSwingEnd or wep.GetSwingEndTime                  if valid_swinger then                     local endtime = valid_swinger(wep)                     local curtime = CurTime()                      local window_to_old_st = self.Stability / 30                      local window = math.max(0, (5 - window_to_old_st) * 0.04) + 0.06                      if curtime > (endtime - window) and curtime < endtime then                         if SERVER then                             hitent:EmitSound("npc/roller/blade_out.wav", 75, 65)                             hitent:AddLegDamage(16)                              if hitent:GetBossTier() == 0 then                                 local status = hitent:GiveStatus("stun", 2.5)                                 status.Applier = owner                             end                         end                          owner:AddDecimalStamina(consume * 0.3)                          if wep.StopSwinging then                             wep:StopSwinging()                         end                         for i = 0, 10 do                             timer.Simple(i * 0.01, function()                                 hitent:AnimSetGestureWeight(GESTURE_SLOT_ATTACK_AND_RELOAD, 1 - i * 0.07)                             end)                         end                     end                 end             end         end     end end  function SWEP:BashEffect(tr, ent) end  function SWEP:StopSwinging()     self:SetSwingEnd(0) end  function SWEP:IsSwinging()     return self:GetSwingEnd() > 0 end  function SWEP:SetSwingEnd(swingend)     self:SetDTFloat(0, swingend) end  function SWEP:GetSwingEnd()     return self:GetDTFloat(0) end  function SWEP:StopWind()     self:SetWindStart(0) end  function SWEP:IsWinding()     return self:GetWindStart() > 0 end  function SWEP:SetWindStart(windstart)     self:SetDTFloat(3, windstart) end  function SWEP:GetWindStart()     return self:GetDTFloat(3) end  function SWEP:SetBlockEnd(swingend)     self:SetDTFloat(1, swingend) end  function SWEP:GetBlockEnd()     return self:GetDTFloat(1) end  function SWEP:SetBashEnd(swingend)     self:SetDTFloat(2, swingend) end  function SWEP:GetBashEnd()     return self:GetDTFloat(2) end  function SWEP:IsBlocking()     return self:GetDTBool(3) end  function SWEP:SetBlocking(block)     self:SetDTBool(3, block) end  function SWEP:IsHeavy()     return self:GetDTBool(4) end  function SWEP:SetHeavy(heavy)     self:SetDTBool(4, heavy) end  local ActIndex = {     [ "pistol" ]  = ACT_HL2MP_IDLE_PISTOL,     [ "smg" ]  = ACT_HL2MP_IDLE_SMG1,     [ "grenade" ]  = ACT_HL2MP_IDLE_GRENADE,     [ "ar2" ]  = ACT_HL2MP_IDLE_AR2,     [ "shotgun" ]  = ACT_HL2MP_IDLE_SHOTGUN,     [ "rpg" ]   = ACT_HL2MP_IDLE_RPG,     [ "physgun" ]  = ACT_HL2MP_IDLE_PHYSGUN,     [ "crossbow" ]  = ACT_HL2MP_IDLE_CROSSBOW,     [ "melee" ]  = ACT_HL2MP_IDLE_MELEE,     [ "slam" ]  = ACT_HL2MP_IDLE_SLAM,     [ "normal" ] = ACT_HL2MP_IDLE,     [ "fist" ] = ACT_HL2MP_IDLE_FIST,     [ "melee2" ] = ACT_HL2MP_IDLE_MELEE2,     [ "passive" ] = ACT_HL2MP_IDLE_PASSIVE,     [ "knife" ] = ACT_HL2MP_IDLE_KNIFE,     [ "duel" ]       = ACT_HL2MP_IDLE_DUEL,     [ "revolver" ] = ACT_HL2MP_IDLE_REVOLVER,     [ "camera" ] = ACT_HL2MP_IDLE_CAMERA }  function SWEP:SetWeaponHoldType( t )      t = string.lower( t )     local index = ActIndex[ t ]      if ( index == nil ) then         Msg( "SWEP:SetWeaponHoldType - ActIndex[ \""..t.."\" ] isn't set! (defaulting to normal)\n" )         t = "normal"         index = ActIndex[ t ]     end      self.ActivityTranslate = {}     self.ActivityTranslate [ ACT_MP_STAND_IDLE ]  = index     self.ActivityTranslate [ ACT_MP_WALK ]  = index+1     self.ActivityTranslate [ ACT_MP_RUN ]  = index+2     self.ActivityTranslate [ ACT_MP_CROUCH_IDLE ]  = index+3     self.ActivityTranslate [ ACT_MP_CROUCHWALK ]  = index+4     self.ActivityTranslate [ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]  = index+5     self.ActivityTranslate [ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ] = index+5     self.ActivityTranslate [ ACT_MP_RELOAD_STAND ]   = index+6     self.ActivityTranslate [ ACT_MP_RELOAD_CROUCH ]   = index+6     self.ActivityTranslate [ ACT_MP_JUMP ]  = index+7     self.ActivityTranslate [ ACT_RANGE_ATTACK1 ]  = index+8     self.ActivityTranslate [ ACT_MP_SWIM_IDLE ]  = index+8     self.ActivityTranslate [ ACT_MP_SWIM ]  = index+9            if t == "normal" then         self.ActivityTranslate [ ACT_MP_JUMP ] = ACT_HL2MP_JUMP_SLAM     end end  SWEP:SetWeaponHoldType("melee")  function SWEP:TranslateActivity( act )     if self:GetSwingEnd() ~= 0 or self:IsWinding() and self.ActivityTranslateSwing and self.ActivityTranslateSwing[act] then         return self.ActivityTranslateSwing[act] or -1     end      if self:IsBlocking() and self.ActivityTranslateBlock[act] then         return self.ActivityTranslateBlock[act] or -1     end      return self.ActivityTranslate and self.ActivityTranslate[act] or -1 end  function SWEP:SetFireMode(mode)     self:SetDTInt(DT_WEAPON_BASE_INT_FIREMODE, mode) end  function SWEP:GetFireMode()     return self:GetDTInt(DT_WEAPON_BASE_INT_FIREMODE) end  function SWEP:FireModeChanged(fm) end  function SWEP:PlayFireModeSwitchSound(fm) end 