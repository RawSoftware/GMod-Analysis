SWEP.Base = "weapon_zs_zombie" local BaseClass = baseclass.Get("weapon_zs_zombie")  SWEP.PrintName = "Sigilite" SWEP.WorldModel = "models/player/breen.mdl" SWEP.ViewModel = "models/Weapons/v_zombiearms_new.mdl"  SWEP.MeleeDelay = 0.72 SWEP.Primary.Delay = 1.1  SWEP.MeleeDamage = 34 SWEP.MeleeDamageVsProps = 55 SWEP.ShatteredDuration = 60 / SWEP.MeleeDamage  SWEP.Secondary.Automatic = false SWEP.Secondary.Delay = 3.5  function SWEP:Initialize()  if CLIENT then  self:SCKInit()  end end  function SWEP:Reload()  self:SecondaryAttack() end  function SWEP:MeleeHit(ent, trace, damage, forcescale)  if not ent:IsPlayer() then  damage = self.MeleeDamageVsProps  end   BaseClass.MeleeHit(self, ent, trace, damage, forcescale) end  function SWEP:ApplyMeleeDamage(ent, trace, damage)  local owner = self:GetOwner()  if SERVER and ent:IsPlayer() then  ent:GiveStatus("debuff_shattered", damage * self.ShatteredDuration, owner)  end   BaseClass.ApplyMeleeDamage(self, ent, trace, damage) end  function SWEP:StartMoaning() end  function SWEP:StopMoaning() end  function SWEP:IsMoaning()  return false end  function SWEP:PlayHitSound()  self:EmitSound("npc/zombie/claw_strike"..math.random(3)..".wav", 75, math.random(80, 90), nil, CHAN_AUTO)  self:EmitSound("physics/concrete/concrete_break"..math.random(2,3)..".wav", 70, 90, nil, CHAN_AUTO) end  function SWEP:PlayMissSound()  self:EmitSound("npc/zombie/claw_miss"..math.random(2)..".wav", 75, math.random(80, 90), nil, CHAN_AUTO) end  local attacksound = {"npc/dog/dog_alarmed1.wav", "npc/dog/dog_angry2.wav", "npc/dog/dog_angry3.wav"} function SWEP:PlayAttackSound()     local rs = table.Random(attacksound)     self:EmitSound(rs, 75, 110)     self:EmitSound(rs, 75, 115, nil, CHAN_AUTO) end  function SWEP:PlayAlertSound() end  function SWEP:PlayIdleSound() end  local map = util.Map  function SWEP:Reload()  local owner = self:GetOwner()  if CurTime() < self:GetNextPrimaryFire() or CurTime() < self:GetNextSecondaryFire() then return end   self:SetNextSecondaryFire(CurTime() + 3.5)  self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)   if SERVER then  local owner_beacons = map(function(beacon)  return beacon:GetOwner() == owner and beacon  end, ents.FindByClass("prop_sigilite_beacon"))   for _, v in pairs(owner_beacons) do  if v then v:Remove() end  end   local ent = ents.Create("prop_sigilite_beacon")  if ent:IsValid() then  ent:SetPos(owner:GetPos())   local angle = owner:GetAimVector():Angle()  ent:SetAngles(angle)  ent:SetOwner(owner)   ent:Spawn()  end  end end  function SWEP:SecondaryAttack()  local owner = self:GetOwner()   if owner.SigiliteProj and owner.SigiliteProj:IsValid() then  self:SetNextSecondaryFire(math.max(CurTime() + 0.1, self:GetNextSecondaryFire()))  else  if CurTime() < self:GetNextPrimaryFire() or CurTime() < self:GetNextSecondaryFire() then return end   self:SetNextSecondaryFire(CurTime() + 3.5)  self:SetNextPrimaryFire(CurTime() + self.Primary.Delay)   if SERVER then  timer.Simple(0.15, function()  if not (owner:IsValidLivingZombie() and self:IsValid()) then return end   local owner_beacons = map(function(beacon)  return beacon:GetOwner() == owner and beacon  end, ents.FindByClass("prop_sigilite_beacon"))   local point, dist = NULL, 0  for _, v in pairs(owner_beacons) do  if v and dist < v:GetPos():DistToSqr(owner:GetPos()) then  point = v  dist = v:GetPos():DistToSqr(owner:GetPos())  end  end   if owner.SigiliteProj and owner.SigiliteProj:IsValid() then point = owner.SigiliteProj end   if not IsValid(point) then return end   if CurTime() >= (owner.NextSigilTeleportationEffect or 0) then  owner.NextSigilTeleportationEffect = CurTime() + 0.25   local effect = "sigil_teleport"   owner:EmitSound("ambient/machines/teleport1.wav", 85, 110)   local effectdata = EffectData()  effectdata:SetOrigin(owner:WorldSpaceCenter())  effectdata:SetEntity(owner)  util.Effect(effect, effectdata, true, true)  util.Effect("explosion_sigiliteteleport", effectdata, true, true)  effectdata:SetOrigin(point:WorldSpaceCenter())  util.Effect(effect, effectdata, true, true)  end   local movepos = point:GetPos() % 2   for i=1, 5 do  owner:SetPos(movepos)  owner:SetLocalPos(movepos)  end  hook.Add("Move", tostring(owner), function(_, p, mv)  if p == owner then  hook.Remove("Move", tostring(owner))  mv:SetOrigin(movepos)  end  end)   local fragents = {}  local tr = {mask = CONTENTS_EMPTY, mins = Vector(-16, -16, 0), maxs = Vector(16, 16, 72)}  tr.start = point:GetPos()  tr.endpos = tr.start  tr.filter = function(ent) if ent:IsValidLivingHuman() then fragents[#fragents + 1] = ent end end  util.TraceHull(tr)  for _, idiot in pairs(fragents) do  idiot:TakeSpecialDamage(1000, DMG_DISSOLVE, owner)  end  end)  end  end end 