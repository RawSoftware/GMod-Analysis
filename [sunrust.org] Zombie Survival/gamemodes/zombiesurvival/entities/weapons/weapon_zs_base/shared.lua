local meta = FindMetaTable("Entity") local E_GetTable = meta.GetTable  SWEP.Primary.Sound = Sound("weapons/pistol/pistol_fire2.wav") SWEP.DryFireSound = Sound("weapons/pistol/pistol_empty.wav") SWEP.Primary.Damage = 30 SWEP.Primary.KnockbackScale = 1 SWEP.Primary.NumShots = 1 SWEP.Primary.Delay = 0.15  SWEP.ConeMax = 1.5 SWEP.ConeMin = 0.5 SWEP.ConeRamp = 2  SWEP.CSMuzzleFlashes = true  SWEP.Primary.ClipSize = 8 SWEP.Primary.DefaultClip = 0 SWEP.Primary.Automatic = false SWEP.Primary.Ammo = "pistol" SWEP.RequiredClip = 1  SWEP.Secondary.ClipSize = 1 SWEP.Secondary.DefaultClip = 1 SWEP.Secondary.Automatic = false SWEP.Secondary.Ammo = "dummy"  SWEP.WalkSpeed = SPEED_NORMAL  SWEP.HoldType = "pistol" SWEP.IronSightsHoldType = "ar2"  SWEP.IronSightsPos = Vector(0, 0, 0)  SWEP.EmptyWhenPurchased = true SWEP.AllowQualityWeapons = true  SWEP.Recoil = 0  SWEP.ReloadSpeed = 1.0 SWEP.FireAnimSpeed = 1.0  SWEP.IdleActivity = ACT_VM_IDLE  SWEP.ResistanceAmmoAs = "dummy"  SWEP.Weight = 5  SWEP.FireModes = 1 SWEP.FireModeNames = {"Default"} SWEP.FireModeNames3D = {"DFLT"}  function SWEP:Initialize()     if not self:IsValid() then return end        self:SetWeaponHoldType(self.HoldType)     GAMEMODE:DoChangeDeploySpeed(self)            if self.Weight and self.Tier then         self.Weight = self.Weight + self.Tier     end      if CLIENT then         self:CheckCustomIronSights()         self:SCKInit()     end end  function SWEP:PrimaryAttack()     if not self:CanPrimaryAttack() then return end      self:SetNextPrimaryFire(CurTime() + self:GetFireDelay())      local stbl = E_GetTable(self)     local self_primary = stbl.Primary      self:EmitFireSound()     self:TakeAmmo()     self:ShootBullets(self_primary.Damage, self_primary.NumShots, self:GetCone()) end  function SWEP:SecondaryAttack()     if self:GetNextSecondaryFire() <= CurTime() and not self:GetOwner():IsHolding() and self:GetReloadFinish() == 0 then         self:SetIronsights(true)     end end  function SWEP:Reload()     local owner = self:GetOwner()     if owner:IsHolding() then return end      if self:GetIronsights() then         self:SetIronsights(false)     end            if self:CanReload() then         self.IdleAnimation = CurTime() + self:SequenceDuration()         self:SetNextReload(self.IdleAnimation)         self:SetReloadStart(CurTime())          self:SendReloadAnimation()         self:ProcessReloadEndTime()          owner:DoReloadEvent()         owner:ResetStaminaRegen()          self:EmitReloadSound()     end end  function SWEP:GetPrimaryClipSize()     local owner = self:GetOwner()     local mag_mul       = owner.MagSizeEightMul or 1     local mag_mul_four  = owner.MagSizeFourEightMul or 1      local ratio = self.Primary.ClipSize/self.RequiredClip     local multi = ratio >= 8 and mag_mul or                   ratio >= 4 and ratio <= 7 and mag_mul_four                   or 1      return math.floor(self.Primary.ClipSize * multi) end  function SWEP:FinishReload()     self:SendWeaponAnim(ACT_VM_IDLE)     self:SetNextReload(0)     self:SetReloadStart(0)     self:SetReloadFinish(0)     self:EmitReloadFinishSound()      local owner = self:GetOwner()     if not owner:IsValid() then return end      owner:ResetStaminaRegen()      local max1 = self:GetPrimaryClipSize()     local max2 = self:GetMaxClip2()      if max1 > 0 then         local ammotype = self:GetPrimaryAmmoType()         local spare = owner:GetAmmoCount(ammotype)         local current = self:Clip1()         local needed = max1 - current          needed = math.min(spare, needed)          self:SetClip1(current + needed)         if SERVER then             local machine_wheel = owner:HasInventoryItem("trinket_machine_wheel") and math.random(100) < 20             local spend = math.ceil(needed * (self.ReloadConsumption or 1))              owner:RemoveAmmo(spend, ammotype)              if machine_wheel then                 if not owner.EnqueuedResupply then owner.EnqueuedResupply = {} end                  owner.EnqueuedResupply[#owner.EnqueuedResupply + 1] = function(pl)                     pl:GiveAmmo(math.ceil(spend * 0.5), ammotype)                 end             end         end     end      if max2 > 0 then         local ammotype = self:GetSecondaryAmmoType()         local spare = owner:GetAmmoCount(ammotype)         local current = self:Clip2()         local needed = max2 - current          needed = math.min(spare, needed)          self:SetClip2(current + needed)         if SERVER then             owner:RemoveAmmo(needed, ammotype)         end     end end  local scaled_trinket_effect = {     [1] = 1,     [2] = 5/6,     [3] = 4/6,     [4] = 4/6,     [5] = 3/6,     [6] = 1/6 }  function SWEP:GetCone()     local owner = self:GetOwner()     local otbl = E_GetTable(owner)     local stbl = E_GetTable(self)      local basecone = stbl.ConeMin     local conedelta = stbl.ConeMax - basecone      local orphic = not otbl.Orphic and 1 or self:GetIronsights() and 0.75 or 1.1     local tier = stbl.Tier or 1     local bonus_mul = scaled_trinket_effect[tier]      local trinket_mul = (otbl.AimSpreadTieredMul or 1) - 1     local spreadmul = (otbl.AimSpreadMul or 1) + trinket_mul * bonus_mul      local gunk = owner:GetStatus("debuff_gunk") and 1.25 or owner:GetStatus("debuff_waste") and 1.5 or 0      if otbl.TrueWooism then         return (basecone + conedelta * 0.5 ^ stbl.ConeRamp) * spreadmul * orphic + gunk     end      if not owner:OnGround() or stbl.ConeMax == basecone then         return stbl.ConeMax * orphic * spreadmul + gunk     end      local multiplier = math.min(owner:GetVelocity():Length() / stbl.WalkSpeed, 1) * 0.5      local ironsightmul = 0.25 * (otbl.IronsightEffMul or 1)     local ironsightdiff = 0.25 - ironsightmul     multiplier = multiplier + ironsightdiff      if not owner:Crouching() then multiplier = multiplier + 0.25 end     if not self:GetIronsights() then multiplier = multiplier + ironsightmul end      return (basecone + conedelta * (stbl.FixedAccuracy and 0.6 or multiplier) ^ stbl.ConeRamp) * spreadmul * orphic + gunk end  function SWEP:GetWalkSpeed()     local owner = self:GetOwner()     local otbl = E_GetTable(owner)     local stbl = E_GetTable(self)      if self:GetIronsights() then         return math.min(stbl.WalkSpeed, math.max(90, stbl.WalkSpeed * (otbl.Wooism and 0.75 or 0.5)))     end      return stbl.WalkSpeed end  function SWEP:EmitFireSound()     self:EmitSound(self.Primary.Sound) end  function SWEP:SetIronsights(b)     self:SetDTBool(0, b)      if self.IronSightsHoldType then         if b then             self:SetWeaponHoldType(self.IronSightsHoldType)         else             self:SetWeaponHoldType(self.HoldType)         end     end      gamemode.Call("WeaponDeployed", self:GetOwner(), self) end  function SWEP:Deploy()     self:SetNextReload(0)     self:SetReloadFinish(0)      gamemode.Call("WeaponDeployed", self:GetOwner(), self)      self:SetIronsights(false)      self.IdleAnimation = CurTime() + self:SequenceDuration()      if CLIENT then         self:CheckCustomIronSights()     end      if self.DrawSound then         self:EmitSound(self.DrawSound, 65)     end      return true end  function SWEP:Holster()     if CLIENT then         self:SCKHolster()     end      return true end  SWEP.AU = 0 function SWEP:TakeAmmo()     if self.AmmoUse then         self.AU = self.AU + self.AmmoUse         if self.AU >= 1 then             local use = math.floor(self.AU)             self:TakePrimaryAmmo(use)             self.AU = self.AU - use         end     else         self:TakePrimaryAmmo(self.RequiredClip)     end end  function SWEP:EmitReloadSound()     if self.ReloadSound and IsFirstTimePredicted() then         self:EmitSound(self.ReloadSound, 75, 100, 1, CHAN_ITEM)     end end  function SWEP:EmitReloadFinishSound()     if self.ReloadFinishSound and IsFirstTimePredicted() then         self:EmitSound(self.ReloadFinishSound, 75, 100, 1, CHAN_ITEM)     end end  function SWEP:CanReload()     return self:GetNextReload() <= CurTime() and self:GetReloadFinish() == 0 and         (             self:GetMaxClip1() > 0 and self:Clip1() < self:GetPrimaryClipSize() and self:ValidPrimaryAmmo() and self:GetOwner():GetAmmoCount(self:GetPrimaryAmmoType()) > 0             or self:GetMaxClip2() > 0 and self:Clip1() < self:GetMaxClip2() and self:ValidSecondaryAmmo() and self:GetOwner():GetAmmoCount(self:GetSecondaryAmmoType()) > 0         ) end  function SWEP:GetIronsights()     return self:GetDTBool(0) end  function SWEP:CanPrimaryAttack()     local owner = self:GetOwner()     if owner:IsHolding() or owner:GetBarricadeGhosting() or self:GetReloadFinish() > 0 then return false end      local stbl = E_GetTable(self)     if self:Clip1() < stbl.RequiredClip then         local primary_delay = math.max(0.25, stbl.Primary.Delay)          self:EmitSound(stbl.DryFireSound)         self:SetNextPrimaryFire(CurTime() + primary_delay)         self:SetNextSecondaryFire(CurTime() + primary_delay)         return false     end      return self:GetNextPrimaryFire() <= CurTime() end  function SWEP:OnRestore()     self:SetIronsights(false) end  function SWEP:SendWeaponAnimation()     self:SendWeaponAnim(ACT_VM_PRIMARYATTACK)     self:GetOwner():GetViewModel():SetPlaybackRate(self:GetIronsights() and self.IronsightAnimSpeed or self.FireAnimSpeed)     self.IdleAnimation = CurTime() + self:SequenceDuration() end  function SWEP:SendReloadAnimation()     self:SendWeaponAnim(ACT_VM_RELOAD) end  function SWEP:GetReloadSpeedMultiplier()     local owner = self:GetOwner()      local tier = self.Tier or 1     local trinket_mul = (owner.ReloadSpeedScaledMul or 1) - 1      local total_scale_mul = scaled_trinket_effect[tier] * trinket_mul      local player_reload_speed           = owner:GetTotalAdditiveModifier("ReloadSpeedMultiplier")     local player_reload_speed_effect    = (player_reload_speed - 1) * (self.PlayerReloadSpeedEffectiveness or 1)     local adj_player_reload_speed       = player_reload_speed_effect + 1      local added_scale_unscale = adj_player_reload_speed + total_scale_mul      return  added_scale_unscale *             (owner:GetStatus("debuff_frost") and 0.7 or 1) *             (owner:GetStatus("buff_agility") and 1.2 or 1)  end  function SWEP:ProcessReloadEndTime()     local reloadspeed = self.ReloadSpeed * self:GetReloadSpeedMultiplier()      self:SetReloadFinish(CurTime() + self:SequenceDuration() / reloadspeed)     if not self.DontScaleReloadSpeed then         self:GetOwner():GetViewModel():SetPlaybackRate(reloadspeed)     end end  function SWEP:GetFireDelay(divider)     local owner = self:GetOwner()      local fervor_bonus = owner:GetStatus("buff_stack_fervor")     fervor_bonus =  fervor_bonus and                     self.Primary.Delay >= 0.14 and                     not self.Primary.MaxDelayReduc and                     (1 + fervor_bonus:GetDTInt(1) * 0.08) or                     1      local orphic = not owner.Orphic and 1 or self:GetIronsights() and 0.78 or 1     local agility_scalar = 1 + (0.25 * scaled_trinket_effect[self.Tier or 1])      return self:GetMinimalTickTime(         (             self.Primary.Delay /             (owner:GetStatus("debuff_gunk") and 0.75 or 1) /             (owner:GetStatus("buff_agility") and self.Primary.Delay >= 0.14 and not self.Primary.MaxDelayReduc and agility_scalar or 1) /             fervor_bonus /             orphic         ) / (divider or 1)     ) end  function SWEP:ShootBullets(dmg, numbul, cone)     local owner = self:GetOwner()     self:SendWeaponAnimation()     owner:DoAttackEvent()     if self.Recoil > 0 then         local r = math.Rand(0.8, 1)         owner:ViewPunch(Angle(r * -self.Recoil, 0, (1 - r) * (math.random(2) == 1 and -1 or 1) * self.Recoil))     end      if self.PointsMultiplier then         POINTSMULTIPLIER = self.PointsMultiplier     end      local shoot_pos = self.CustomShootPos or owner:GetShootPos()     local aim_vec   = self.CustomAimVec or owner:GetAimVector()      local qua_tier = self.QualityTier or 0     if owner:HasInventoryItem("trinket_mini_forge") and (self.Tier or 1) <= 3 and qua_tier < 1 and util.SharedRandom("mini", 0, 100) < 25 then         numbul = numbul * 2     end      DO_BULLET_LAG_COMP = true     owner:FireBulletsLua(shoot_pos, aim_vec, cone, numbul, dmg, nil, self.Primary.KnockbackScale, self.TracerName, self.BulletCallback, self.Primary.HullSize, nil, self.Primary.MaxDistance, nil, self)     DO_BULLET_LAG_COMP = nil      if self.PointsMultiplier then         POINTSMULTIPLIER = nil     end end  function SWEP:GetWeaponBuildup()     return self:GetDTFloat(20) end  function SWEP:SetWeaponBuildup(buildup)     self:SetDTFloat(20, buildup) end  local ActIndex = {     [ "pistol" ]  = ACT_HL2MP_IDLE_PISTOL,     [ "smg" ]  = ACT_HL2MP_IDLE_SMG1,     [ "grenade" ]  = ACT_HL2MP_IDLE_GRENADE,     [ "ar2" ]  = ACT_HL2MP_IDLE_AR2,     [ "shotgun" ]  = ACT_HL2MP_IDLE_SHOTGUN,     [ "rpg" ]   = ACT_HL2MP_IDLE_RPG,     [ "physgun" ]  = ACT_HL2MP_IDLE_PHYSGUN,     [ "crossbow" ]  = ACT_HL2MP_IDLE_CROSSBOW,     [ "melee" ]  = ACT_HL2MP_IDLE_MELEE,     [ "slam" ]  = ACT_HL2MP_IDLE_SLAM,     [ "normal" ] = ACT_HL2MP_IDLE,     [ "fist" ] = ACT_HL2MP_IDLE_FIST,     [ "melee2" ] = ACT_HL2MP_IDLE_MELEE2,     [ "passive" ] = ACT_HL2MP_IDLE_PASSIVE,     [ "knife" ] = ACT_HL2MP_IDLE_KNIFE,     [ "duel" ]       = ACT_HL2MP_IDLE_DUEL,     [ "revolver" ] = ACT_HL2MP_IDLE_REVOLVER,     [ "camera" ] = ACT_HL2MP_IDLE_CAMERA }  function SWEP:SetWeaponHoldType( t )      t = string.lower( t )     local index = ActIndex[ t ]      if ( index == nil ) then         Msg( "SWEP:SetWeaponHoldType - ActIndex[ \""..t.."\" ] isn't set! (defaulting to normal) (from "..self:GetClass()..")\n" )         t = "normal"         index = ActIndex[ t ]     end      self.ActivityTranslate = {}     self.ActivityTranslate [ ACT_MP_STAND_IDLE ]  = index     self.ActivityTranslate [ ACT_MP_WALK ]  = index+1     self.ActivityTranslate [ ACT_MP_RUN ]  = index+2     self.ActivityTranslate [ ACT_MP_CROUCH_IDLE ]  = index+3     self.ActivityTranslate [ ACT_MP_CROUCHWALK ]  = index+4     self.ActivityTranslate [ ACT_MP_ATTACK_STAND_PRIMARYFIRE ]  = index+5     self.ActivityTranslate [ ACT_MP_ATTACK_CROUCH_PRIMARYFIRE ] = index+5     self.ActivityTranslate [ ACT_MP_RELOAD_STAND ]   = index+6     self.ActivityTranslate [ ACT_MP_RELOAD_CROUCH ]   = index+6     self.ActivityTranslate [ ACT_MP_JUMP ]  = index+7     self.ActivityTranslate [ ACT_RANGE_ATTACK1 ]  = index+8     self.ActivityTranslate [ ACT_MP_SWIM_IDLE ]  = index+8     self.ActivityTranslate [ ACT_MP_SWIM ]  = index+9            if t == "normal" then         self.ActivityTranslate [ ACT_MP_JUMP ] = ACT_HL2MP_JUMP_SLAM     end            if t == "knife" or t == "melee2" then         self.ActivityTranslate [ ACT_MP_CROUCH_IDLE ] = nil     end end  SWEP:SetWeaponHoldType("pistol")  function SWEP:TranslateActivity(act)     if self:GetIronsights() and self.ActivityTranslateIronSights then         return self.ActivityTranslateIronSights[act] or -1     end      return self.ActivityTranslate and self.ActivityTranslate[act] or -1 end  function SWEP:SetFireMode(mode)     self:SetDTInt(DT_WEAPON_BASE_INT_FIREMODE, mode) end  function SWEP:GetFireMode()     return self:GetDTInt(DT_WEAPON_BASE_INT_FIREMODE) end  function SWEP:FireModeChanged(fm)     fm = tonumber(fm)     self.Primary.Automatic = fm ~= 1 end  function SWEP:PlayFireModeSwitchSound(fm)     fm = tonumber(fm)     if CLIENT then         if fm == 1 then             surface.PlaySound("weapons/smg1/switch_single.wav")         else             surface.PlaySound("weapons/smg1/switch_burst.wav")         end     end end 