 EFFECT.LifeTime = 0.1  function EFFECT:GetDelta()     return math.Clamp(self.DieTime - CurTime(), 0, self.LifeTime) / self.LifeTime end  function EFFECT:Init(data)     self.StartPos = self:GetTracerShootPos(data:GetStart(), data:GetEntity(), data:GetAttachment())     self.EndPos = data:GetOrigin()     self.HitNormal = data:GetNormal() * -1     self.Color = Color(0,255,0)     self.LifeTime = 0.15 + 0.013 * ((self.StartPos - self.EndPos):Length() ^ 0.5)       self.DieTime = CurTime() + self.LifeTime     self.Normal = (self.EndPos - self.StartPos):GetNormalized()      local emitter = ParticleEmitter(self.EndPos)     emitter:SetNearClip(24, 32)      local normal = self.EndPos - self.StartPos     normal:Normalize()      self.QuadPos = self.EndPos + self.HitNormal      for i=1, 20 do         local particle = emitter:Add("effects/blueflare1", self.QuadPos)         local vel = VectorRand():GetNormal() * 30         particle:SetDieTime(0.5)         particle:SetColor(0,200,0)         particle:SetStartAlpha(200)         particle:SetEndAlpha(0)         particle:SetStartSize(10)         particle:SetEndSize(0)         particle:SetVelocity(vel)         particle:SetGravity(vel * -0.7)     end      emitter:Finish() end  function EFFECT:Think()     return CurTime() < self.DieTime end  local Mat_Impact = Material("effects/combinemuzzle2") local matBeam2 = Material("trails/physbeam") local Mat_TracePart = Material("effects/select_ring")  function EFFECT:Render()     local delta = self:GetDelta()     if delta <= 0 then return end     self.Color.a = delta * 155      local startpos = self.StartPos     local endpos = self.QuadPos      local size = delta * 17     render.SetMaterial(matBeam2)     render.DrawBeam(startpos, endpos, size * 0.5, 1, 0, self.Color)     render.DrawBeam(startpos, endpos, size, 1, 0, self.Color)      local distancevector = startpos - endpos     local dir = distancevector:Angle()     local dfwd = dir:Forward()     local dup = dir:Up()     local drgt = dir:Right()     local nlen = distancevector:Length()      for i = 0, nlen * (1 - delta), 32 do         local set = i - CurTime() * 7         local spinbeamsize = (1 - delta) * 15          local basebeampos = startpos - dfwd * i         local spinbeampos = basebeampos + dup * math.sin(set) * spinbeamsize + drgt * math.cos(set) * spinbeamsize         local spinbeampos2 = basebeampos - dup * math.sin(set) * spinbeamsize - drgt * math.cos(set) * spinbeamsize      render.SetMaterial(Mat_Impact)     render.DrawSprite(self.EndPos, 12, 12, Color(130,255,130))     render.SetMaterial(Mat_TracePart)      if not self.DoOnce then         local emitter = ParticleEmitter(self.StartPos)         for j=1, 2 do             local particle = emitter:Add(Mat_TracePart, self.StartPos)             particle:SetVelocity(self.Normal:GetNormalized() * 2 * (j * 12))             particle:SetAirResistance(8)             particle:SetColor(110,255,90)             particle:SetEndSize(8)             particle:SetDieTime(0.2)             particle:SetStartSize(5)             particle:SetStartAlpha(255)             particle:SetEndAlpha(0)             particle:SetRoll(math.Rand(0, 360))             particle:SetRollDelta(1)         end         emitter:Finish()         emitter = nil         collectgarbage("step", 64)          self.DoOnce = true     end          prevspinpos = spinbeampos         prevspinpos2 = spinbeampos2     end end