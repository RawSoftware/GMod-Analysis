local elements = {  { model = "models/gibs/scanner_gib05.mdl", pos = Vector( 17, -9, 70 ), ang = Angle( -1, -17, 29) },  { model = "models/props_c17/trappropeller_engine.mdl", pos = Vector( -5, -3, 95 ), ang = Angle( -62, -65, 30) },  { model = "models/props_c17/chair02a.mdl", pos = Vector( -36, 16, 93 ), ang = Angle( -16, -71, -98) },  { model = "models/props_junk/sawblade001a.mdl", pos = Vector( -13, -15, 78 ), ang = Angle( 47, 141, 74) },  { model = "models/props_junk/rock001a.mdl", pos = Vector( -12, -1, 82 ), ang = Angle( -13, -37, -161), shard = true, material = "!sigil_green" },  { model = "models/props_junk/propanecanister001a.mdl", pos = Vector( -29, 6, 67 ), ang = Angle( -40, -58, -56) },              { model = "models/weapons/w_rocket_launcher.mdl", pos = Vector( -10, -52, 61 ), ang = Angle( -32, 106, -89) },  { model = "models/props_combine/breenbust.mdl", pos = Vector( 18, -30, 51 ), ang = Angle( -39, 14, -33) },  { model = "models/gibs/antlion_gib_medium_2.mdl", pos = Vector( -11, -57, 67 ), ang = Angle( 0, -2, -153), material = "models/flesh" },  { model = "models/props_c17/chair_stool01a.mdl", pos = Vector( 20, -32, 57 ), ang = Angle( -44, 116, -83) },  { model = "models/props_c17/tv_monitor01.mdl", pos =  Vector( 0.6, -0.98, 71.2 ), ang = Angle( -82.63, -145.02, -34.19 ) },  { model = "models/items/healthkit.mdl", pos = Vector( -26.06, 30.2, 37.73 ), ang = Angle( 52.77, -159.16, -51.74 ) },  { model = "models/props_c17/briefcase001a.mdl", pos = Vector( -27.28, 35.5, 30.7 ), ang = Angle( 74.29, -137.59, 54.79 ) },  { model = "models/gibs/antlion_gib_large_1.mdl", pos = Vector( -37.21, 42.27, 25.74 ), ang = Angle( 18.39, 43.26, -155.67 ), material = "models/flesh" }, }  local mat_energy = Material( "effects/tool_tracer" ) local mat_glow = Material("sprites/glow04_noz")  local math_clamp = math.Clamp local math_random = math.random local math_round = math.Round  local vec_rand = VectorRand local col_glow = Color( 35, 250, 10, 255 )  function EFFECT:Init(data)  local pos = data:GetOrigin()  local ang = data:GetAngles()  local ent = data:GetEntity()   self:SetRenderBounds( Vector( -50, -50, -50 ), Vector( 60, 60, 60 ) )   self.Giblets = {}   for _, v in pairs( elements ) do   local gib = ClientsideModel(v.model, RENDERGROUP_OPAQUE)  if gib:IsValid() then   local off_pos, off_ang = LocalToWorld( v.pos, v.ang, pos, ang )  gib:SetPos( off_pos )  gib:SetAngles( off_ang )  gib:PhysicsInit( SOLID_VPHYSICS  )   if v.material then  gib:SetMaterial( v.material )  end   local phys = gib:GetPhysicsObject()  if phys:IsValid() then  phys:Wake()  phys:ApplyForceOffset(gib:GetPos() + vec_rand() * 5, vec_rand():GetNormal() * math.Rand(10, 20))  end   if v.shard then  self.Core = gib  else  table.insert( self.Giblets, gib )  end   SafeRemoveEntityDelayed(gib, math.Rand(12, 15))  end   end   if self.Core and self.Core:IsValid() then  self.Core:EmitSound( "ambient/levels/citadel/portal_open1_adpcm.wav", 77, 130 )  end   self.ExplosionTime = CurTime() + 2  self.DieTime = CurTime() + 15  end  function EFFECT:Think()   if self.Giblets and self.ExplosionTime and self.ExplosionTime <= CurTime() and not self.Exploded and self.Core then  self.Exploded = true   for k, v in pairs( self.Giblets ) do  if v and v:IsValid() and self.Core:IsValid() then  local phys = v:GetPhysicsObject()  if phys:IsValid() then   local dir = ( v:GetPos() - self.Core:GetPos() ):GetNormal()   phys:Wake()  phys:ApplyForceCenter(dir * math.Rand(200, 420) * phys:GetMass() + vector_up * phys:GetMass() * math.Rand(220, 720))   end  end  end   if self.Core:IsValid() then  self.LightningPos = self.Core:GetPos()  self.LightningTime = CurTime() + 0.5  SafeRemoveEntity( self.Core )   sound.Play("weapons/physcannon/energy_sing_explosion2.wav", self.LightningPos, 80, math.Rand(90, 95))  sound.Play("weapons/physcannon/energy_disintegrate4.wav", self.LightningPos, 80, math.Rand(100, 105))   local emitter = ParticleEmitter(self.LightningPos)   for i=1, 12 do  particle = emitter:Add("sprites/glow04_noz", self.LightningPos + vector_up * i * 30)  particle:SetVelocity(vector_up * 48 + VectorRand() * 32)  particle:SetDieTime(math.Rand(3.5, 4.5))  particle:SetStartAlpha(240)  particle:SetEndAlpha(0)  particle:SetStartSize(math_random( 150, 200 ) + ( 12 - i ) * 10)  particle:SetEndSize(0)  particle:SetColor(35, 250, 10, 255)  end   emitter:Finish() emitter = nil collectgarbage("step", 64)   end   end   return self.DieTime and self.DieTime >= CurTime() end  function EFFECT:Render()      if self.ExplosionTime and self.Core and self.Core:IsValid() then   local charge_delta = math_clamp( 1 - ( self.ExplosionTime - CurTime() ) / 2, 0, 1 )   local pos = self.Core:GetPos()  local size = math_random( 25, 30 )   render.SetMaterial( mat_glow )  render.DrawSprite( pos, size * 10 * charge_delta, size * 10 * charge_delta, col_glow )   render.SetMaterial( mat_energy )   for i = 1, math.Round( 1 + charge_delta * 13 ) do  local off = vec_rand() * ( 14 - i ) * 7 * charge_delta  render.DrawBeam( pos + off, pos - off, i * charge_delta * 5 , RealTime()*0.1, RealTime()*0.1 + 0.4, col_glow )  end  end       if self.LightningPos and self.LightningTime and self.LightningTime >= CurTime() then   self:SetPos( self.LightningPos )   if not self.LightningTbl then  self.LightningTbl = {}  end   local pos = self.LightningPos  local charge_delta = math_clamp( 1 - ( self.LightningTime - CurTime() ) / 0.5, 0, 1 )   charge_delta = charge_delta ^ .3   for k = 1, 10 do   local dir = vector_up + vec_rand():GetNormal() * 0.05   if k < 7 then  dir = vec_rand():GetNormal()  end   local root_height = math_random( 250, 400 ) * charge_delta + 200   if k < 7 then  root_height = math_random( 150, 200 )  end   local start_off = vec_rand() * 10  start_off.z = 0  if not self.LightningTbl[k] then  self.LightningTbl[k] = start_off  end   local size = math_random( 15, 20 )   local prev_pos  local bits = 10   for i = 1, bits do  local cur_off = dir * ( i * root_height / bits ) + vec_rand() * 10  local prev_off = dir * ( ( i - 1 ) * root_height / bits ) + vec_rand() * 10   render.SetMaterial( mat_energy )   render.DrawBeam( pos + self.LightningTbl[k] * ( bits - i - 1 ) + cur_off, pos + self.LightningTbl[k] * ( bits - i ) + ( prev_pos or prev_off ), ( bits - i + 1 ) * 10 , RealTime()*0.1, RealTime()*0.1 + 0.05 * i, col_glow )  prev_pos = prev_off   render.SetMaterial( mat_glow )  render.DrawSprite( pos + dir * ( i * root_height / bits ) , size * ( bits - i ), size * ( bits - i ), col_glow )  end  end  end end